diff -urNpX diff.exclude linux--2.6.11/Makefile linux--vhype--2.6.11/Makefile
--- linux--2.6.11/Makefile	2005-03-03 19:38:37.000000000 +0000
+++ linux--vhype--2.6.11/Makefile	2005-03-03 19:58:55.000000000 +0000
@@ -1,7 +1,7 @@
 VERSION = 2
 PATCHLEVEL = 6
 SUBLEVEL = 11
-EXTRAVERSION =
+EXTRAVERSION =-vhype
 NAME=Woozy Numbat
 
 # *DOCUMENTATION*
diff -urNpX diff.exclude linux--2.6.11/arch/i386/Kconfig linux--vhype--2.6.11/arch/i386/Kconfig
--- linux--2.6.11/arch/i386/Kconfig	2005-03-01 16:22:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/Kconfig	2005-03-01 21:16:59.000000000 +0000
@@ -106,6 +106,23 @@ config X86_VISWS
 	  A kernel compiled for the Visual Workstation will not run on PCs
 	  and vice versa. See <file:Documentation/sgi-visws.txt> for details.
 
+config X86_HYPERVISOR
+	bool "Hypervisor (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  This option is needed to run Linux on the vHype hypervisor.
+
+	  If you don't have such a system, you should say N here.
+
+config OPENHYPE
+	depends on X86_HYPERVISOR
+	bool "Support OpenHype control interfaces"
+	default y
+	help
+	  Enabling this option enables the /dev/hcall device that can be used
+	  to access OpenHype management interfaces.
+
+
 config X86_GENERICARCH
        bool "Generic architecture (Summit, bigsmp, ES7000, default)"
        depends on SMP
diff -urNpX diff.exclude linux--2.6.11/arch/i386/Makefile linux--vhype--2.6.11/arch/i386/Makefile
--- linux--2.6.11/arch/i386/Makefile	2005-03-01 16:16:14.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/Makefile	2005-03-01 21:12:16.000000000 +0000
@@ -82,10 +82,14 @@ mcore-$(CONFIG_X86_NUMAQ)	:= mach-defaul
 mflags-$(CONFIG_X86_BIGSMP)	:= -Iinclude/asm-i386/mach-bigsmp
 mcore-$(CONFIG_X86_BIGSMP)	:= mach-default
 
-#Summit subarch support
+# Summit subarch support
 mflags-$(CONFIG_X86_SUMMIT) := -Iinclude/asm-i386/mach-summit
 mcore-$(CONFIG_X86_SUMMIT)  := mach-default
 
+# Hypervisor subarch support
+mflags-$(CONFIG_X86_HYPERVISOR) := -Iinclude/asm-i386/mach-hypervisor
+mcore-$(CONFIG_X86_HYPERVISOR)  := mach-default
+
 # generic subarchitecture
 mflags-$(CONFIG_X86_GENERICARCH) := -Iinclude/asm-i386/mach-generic
 mcore-$(CONFIG_X86_GENERICARCH) := mach-default
diff -urNpX diff.exclude linux--2.6.11/arch/i386/boot/tools/build.c linux--vhype--2.6.11/arch/i386/boot/tools/build.c
--- linux--2.6.11/arch/i386/boot/tools/build.c	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/boot/tools/build.c	2005-03-01 21:12:16.000000000 +0000
@@ -33,7 +33,7 @@
 #include <sys/sysmacros.h>
 #include <unistd.h>
 #include <fcntl.h>
-#include <asm/boot.h>
+#include <asm-i386/boot.h>
 
 typedef unsigned char byte;
 typedef unsigned short word;
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/Makefile linux--vhype--2.6.11/arch/i386/kernel/Makefile
--- linux--2.6.11/arch/i386/kernel/Makefile	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/Makefile	2005-03-01 21:12:16.000000000 +0000
@@ -29,6 +29,8 @@ obj-$(CONFIG_KPROBES)		+= kprobes.o
 obj-$(CONFIG_MODULES)		+= module.o
 obj-y				+= sysenter.o vsyscall.o
 obj-$(CONFIG_ACPI_SRAT) 	+= srat.o
+obj-$(CONFIG_X86_HYPERVISOR)	+= hcall.o vio_arch.o openhype.o iommu.o oh_iommu.o
+obj-$(CONFIG_HVC_CONSOLE)	+= hvc_calls.o
 obj-$(CONFIG_HPET_TIMER) 	+= time_hpet.o
 obj-$(CONFIG_EFI) 		+= efi.o efi_stub.o
 obj-$(CONFIG_EARLY_PRINTK)	+= early_printk.o
@@ -44,9 +46,17 @@ $(obj)/vsyscall.o: $(obj)/vsyscall-int80
 targets += $(foreach F,int80 sysenter,vsyscall-$F.o vsyscall-$F.so)
 targets += vsyscall.lds
 
+# VSYSCALL_BASE must match <asm/fixmap.h>.
+ifeq ($(CONFIG_X86_HYPERVISOR),y)
+VSYSCALL_BASE = 0xfbffe000
+else
+VSYSCALL_BASE = 0xffffe000
+endif
+
 # The DSO images are built using a special linker script.
 quiet_cmd_syscall = SYSCALL $@
       cmd_syscall = $(CC) -nostdlib $(SYSCFLAGS_$(@F)) \
+			  -Wl,--defsym,VSYSCALL_BASE=$(VSYSCALL_BASE) \
 		          -Wl,-T,$(filter-out FORCE,$^) -o $@
 
 export CPPFLAGS_vsyscall.lds += -P -C -U$(ARCH)
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/cpu/common.c linux--vhype--2.6.11/arch/i386/kernel/cpu/common.c
--- linux--2.6.11/arch/i386/kernel/cpu/common.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/cpu/common.c	2005-03-02 15:44:28.000000000 +0000
@@ -10,6 +10,7 @@
 #include <asm/msr.h>
 #include <asm/io.h>
 #include <asm/mmu_context.h>
+#include <linux/openhype.h>
 #ifdef CONFIG_X86_LOCAL_APIC
 #include <asm/mpspec.h>
 #include <asm/apic.h>
@@ -557,6 +558,7 @@ void __init cpu_init (void)
 	int cpu = smp_processor_id();
 	struct tss_struct * t = &per_cpu(init_tss, cpu);
 	struct thread_struct *thread = &current->thread;
+	int idx;
 
 	if (cpu_test_and_set(cpu, cpu_initialized)) {
 		printk(KERN_WARNING "CPU#%d already initialized!\n", cpu);
@@ -589,8 +591,32 @@ void __init cpu_init (void)
 	memcpy(thread->tls_array, &per_cpu(cpu_gdt_table, cpu),
 		GDT_ENTRY_TLS_ENTRIES * 8);
 
+#ifdef CONFIG_X86_HYPERVISOR
+	if (hcall_set_mbox(NULL, __pa(&oh_mbox)) != H_Success)
+		BUG();
+	for (idx = GDT_ENTRY_TLS_MIN; idx < GDT_ENTRIES; idx++) {
+ 		if (hcall_dt_entry(NULL, H_DT_GDT, idx,
+				    per_cpu(cpu_gdt_table, cpu)[idx].a,
+				    per_cpu(cpu_gdt_table, cpu)[idx].b) !=
+		    H_Success)
+			BUG();
+	}
+
+	/*
+	 * 'Til now we've been running on the segment selectors vhype started
+	 * us with.  Time to switch to our own.
+	 */
+	__asm__ __volatile__("\n\t"
+		"ljmp %0,$1f\n\t"
+	    "1:  movl %1,%%ss\n\t"
+		"movl %2,%%ds\n\t"
+		"movl %2,%%es"
+		: : "i" (__KERNEL_CS), "r" (__KERNEL_DS), "r" (__USER_DS));
+
+#else
 	__asm__ __volatile__("lgdt %0" : : "m" (cpu_gdt_descr[cpu]));
 	__asm__ __volatile__("lidt %0" : : "m" (idt_descr));
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	/*
 	 * Delete NT
@@ -608,8 +634,10 @@ void __init cpu_init (void)
 
 	load_esp0(t, thread);
 	set_tss_desc(cpu,t);
+#ifndef CONFIG_X86_HYPERVISOR
 	load_TR_desc();
 	load_LDT(&init_mm.context);
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	/* Set up doublefault TSS pointer in the GDT */
 	__set_tss_desc(cpu, GDT_ENTRY_DOUBLEFAULT_TSS, &doublefault_tss);
@@ -618,17 +646,26 @@ void __init cpu_init (void)
 	asm volatile ("xorl %eax, %eax; movl %eax, %fs; movl %eax, %gs");
 
 	/* Clear all 6 debug registers: */
-
+#ifdef CONFIG_X86_HYPERVISOR
+	{
+		unsigned long drs[8] = {0};
+		if (hcall_set_drs(drs) != H_Success)
+			BUG();
+	}
+#else /* CONFIG_X86_HYPERVISOR */
 #define CD(register) __asm__("movl %0,%%db" #register ::"r"(0) );
-
+	
 	CD(0); CD(1); CD(2); CD(3); /* no db4 and db5 */; CD(6); CD(7);
-
+	
 #undef CD
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	/*
 	 * Force FPU initialization:
 	 */
 	current_thread_info()->status = 0;
 	clear_used_math();
+#ifndef CONFIG_X86_HYPERVISOR
 	mxcsr_feature_mask_init();
+#endif /* CONFIG_X86_HYPERVISOR */
 }
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/cpu/intel.c linux--vhype--2.6.11/arch/i386/kernel/cpu/intel.c
--- linux--2.6.11/arch/i386/kernel/cpu/intel.c	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/cpu/intel.c	2005-03-01 21:12:16.000000000 +0000
@@ -82,6 +82,7 @@ static void __init init_intel(struct cpu
 	unsigned int l2 = 0;
 	char *p = NULL;
 
+#ifndef CONFIG_X86_HYPERVISOR
 #ifdef CONFIG_X86_F00F_BUG
 	/*
 	 * All current models of Pentium and Pentium with MMX technology CPUs
@@ -100,6 +101,7 @@ static void __init init_intel(struct cpu
 		}
 	}
 #endif
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	select_idle_routine(c);
 	l2 = init_intel_cacheinfo(c);
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/entry.S linux--vhype--2.6.11/arch/i386/kernel/entry.S
--- linux--2.6.11/arch/i386/kernel/entry.S	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/entry.S	2005-03-02 15:46:14.000000000 +0000
@@ -74,8 +74,20 @@ DF_MASK		= 0x00000400 
 NT_MASK		= 0x00004000
 VM_MASK		= 0x00020000
 
+#ifdef CONFIG_X86_HYPERVISOR
+#define CLI(reg) \
+	leal oh_mbox, %reg; \
+	movb $0, (%reg);
+#define STI(reg) \
+	leal oh_mbox, %reg; \
+	movb $1, (%reg);
+#else
+#define CLI(reg)  cli
+#define STI(reg)  sti
+#endif
+
 #ifdef CONFIG_PREEMPT
-#define preempt_stop		cli
+#define preempt_stop		CLI(eax)
 #else
 #define preempt_stop
 #define resume_kernel		restore_all
@@ -122,12 +134,32 @@ VM_MASK		= 0x00020000
 .previous
 
 
+#ifdef CONFIG_X86_HYPERVISOR
+/* FIXME! fixup code cannot work with int 0xF1 */
+#define RESTORE_ALL	\
+	RESTORE_REGS	\
+	addl $4, %esp;	\
+1:	int $0xF1;	\
+.section .fixup,"ax";	\
+2:	STI(edx);	\
+	xorl %edx, %edx;\
+	movw %ds, %dx;	\
+	movl %edx, %ds;	\
+	movl %edx, %es;	\
+	pushl $11;	\
+	call do_exit;	\
+.previous;             \
+.section __ex_table,"a";\
+	.align 4;       \
+	.long 1b,2b;    \
+.previous
+#else
 #define RESTORE_ALL	\
 	RESTORE_REGS	\
 	addl $4, %esp;	\
 1:	iret;		\
 .section .fixup,"ax";   \
-2:	sti;		\
+2:	STI(edx);		\
 	movl $(__USER_DS), %edx; \
 	movl %edx, %ds; \
 	movl %edx, %es; \
@@ -138,6 +170,7 @@ VM_MASK		= 0x00020000
 	.align 4;	\
 	.long 1b,2b;	\
 .previous
+#endif /* CONFIG_X86_HYPERVISOR */
 
 
 ENTRY(ret_from_fork)
@@ -162,10 +195,14 @@ ret_from_intr:
 	GET_THREAD_INFO(%ebp)
 	movl EFLAGS(%esp), %eax		# mix EFLAGS and CS
 	movb CS(%esp), %al
+#ifdef CONFIG_X86_HYPERVISOR
+	testl $(VM_MASK | 1), %eax	# guest OS runs at RPL 2
+#else
 	testl $(VM_MASK | 3), %eax
+#endif
 	jz resume_kernel		# returning to kernel or vm86-space
 ENTRY(resume_userspace)
- 	cli				# make sure we don't miss an interrupt
+ 	CLI(ecx)			# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
 	movl TI_flags(%ebp), %ecx
@@ -196,7 +233,7 @@ need_resched:
 ENTRY(sysenter_entry)
 	movl TSS_sysenter_esp0(%esp),%esp
 sysenter_past_esp:
-	sti
+	STI(eax)
 	pushl $(__USER_DS)
 	pushl %ebp
 	pushfl
@@ -225,7 +262,7 @@ sysenter_past_esp:
 	jae syscall_badsys
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)
-	cli
+	CLI(ecx)
 	movl TI_flags(%ebp), %ecx
 	testw $_TIF_ALLWORK_MASK, %cx
 	jne syscall_exit_work
@@ -233,7 +270,7 @@ sysenter_past_esp:
 	movl EIP(%esp), %edx
 	movl OLDESP(%esp), %ecx
 	xorl %ebp,%ebp
-	sti
+	STI(ecx)
 	sysexit
 
 
@@ -251,7 +288,7 @@ syscall_call:
 	call *sys_call_table(,%eax,4)
 	movl %eax,EAX(%esp)		# store the return value
 syscall_exit:
-	cli				# make sure we don't miss an interrupt
+	CLI(ecx)			# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
 	movl TI_flags(%ebp), %ecx
@@ -267,7 +304,7 @@ work_pending:
 	jz work_notifysig
 work_resched:
 	call schedule
-	cli				# make sure we don't miss an interrupt
+	CLI(ecx)			# make sure we don't miss an interrupt
 					# setting need_resched or sigpending
 					# between sampling and the iret
 	movl TI_flags(%ebp), %ecx
@@ -314,7 +351,7 @@ syscall_trace_entry:
 syscall_exit_work:
 	testb $(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SINGLESTEP), %cl
 	jz work_pending
-	sti				# could let do_syscall_trace() call
+	STI(eax)			# could let do_syscall_trace() call
 					# schedule() instead
 	movl %esp, %eax
 	movl $1, %edx
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/hcall.S linux--vhype--2.6.11/arch/i386/kernel/hcall.S
--- linux--2.6.11/arch/i386/kernel/hcall.S	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/hcall.S	2005-03-01 21:12:16.000000000 +0000
@@ -0,0 +1,197 @@
+/*
+ * hcall.S
+ *
+ * Move the arguments from the stack into registers and then do an int 0xF0
+ */
+
+#include <linux/linkage.h>
+#include <asm/hvcall.h>
+
+/*
+ *	The stack looks like this:
+ *	Stack  |  Accessed as	  | 	Loaded in reg
+ *	arg 6		28(%ebp)	edi
+ *	arg 5		24(%ebp)	esi
+ *	arg 4		20(%ebp)	edx
+ *	arg 3		16(%ebp)	edx
+ *	arg 2		12(%ebp)	ecx 
+ *	retvals		 8(%ebp)	 -
+ *	ret
+ *	old_ebp	<- ebp
+ *	ebx	(call saved)
+ *	esi
+ *	edi
+ */
+
+/*
+ * The first 5 arguments are transfered in registers,
+ * any remaining arguments (up to 16) stay on the stack.
+ */
+
+	.macro LOAD_INPUTS n_inputs
+	.if \n_inputs > 4
+	movl	28(%ebp), %edi
+	.endif
+	.if \n_inputs > 3
+	movl	24(%ebp), %esi
+	.endif
+	.if \n_inputs > 2
+	movl	20(%ebp), %ebx
+	.endif
+	.if \n_inputs > 1
+	movl	16(%ebp), %edx
+	.endif
+	.if \n_inputs > 0
+	movl	12(%ebp), %ecx
+	.endif
+	.endm
+
+/*
+ * Currently we save all non-volatile registers onto the stack; this is
+ * clearly subobtimal.
+ */
+#define SAVE_CLOBBER_LIST	\
+	pushl	%ebx;		\
+	pushl	%esi;		\
+	pushl	%edi;
+
+#define RESTORE_CLOBBER_LIST	\
+	popl %edi;		\
+	popl %esi;		\
+	popl %ebx;
+
+/*
+ * The output values after a hcall are in the registers.
+ * eax contains the return code, and should be left as is.
+ * Other outputs are in sequence: ecx, edx, ebx, esi, edi; these must be
+ * moved into the retvals array.
+ */
+	/* %eax contains the pointer to retvals array */
+	.macro STORE_OUTPUTS n_args
+	.if \n_args > 0
+	/* need to get &retvals */
+	pushl	%eax			
+	movl	8(%ebp), %eax		
+	movl %ecx, 0x0(%eax)
+	.endif
+	.if \n_args > 4
+	movl %edi, 0x10(%eax)
+	.endif
+	.if \n_args > 3
+	movl %esi, 0xc(%eax)
+	.endif
+	.if \n_args > 2
+	movl %ebx, 0x8(%eax)
+	.endif
+	.if \n_args > 1		
+	movl %edx, 0x4(%eax)
+	.endif
+	.if \n_args > 5
+	movl	$\n_args-5, %ecx
+	movl	%eax, %edi
+	addl	$0x14, %edi 
+	movl	%esp, %esi
+	addl	$4, %esi
+	cld
+	rep movsl
+	.endif
+	.if \n_args > 0
+	popl	%eax
+	.endif
+	.if \n_args > 5
+	addl	$(\n_args-5)*4, %esp
+	.endif
+	.endm /* STORE_OUTPUS */
+
+
+	.macro RESERVE_OUTPUTS_SPACE n_args
+	.if	\n_args > 5
+	subl	$(\n_args-5)*4, %esp
+	.endif
+	.endm /* RESERVE_OUTPUTS_SPACE */
+	
+	
+/* call as hcall_func_name(u32 retvals[], arg1, ..., argN) */
+#define HCALL(n_inputs, n_outputs, func_name, opcode)	\
+	ENTRY(func_name)				\
+	pushl 	%ebp;					\
+	movl	%esp, %ebp;				\
+	movl	$opcode, %eax;				\
+	SAVE_CLOBBER_LIST;				\
+	LOAD_INPUTS	n_inputs;			\
+	RESERVE_OUTPUTS_SPACE	n_outputs; 		\
+	int	$0xF0;					\
+	STORE_OUTPUTS	n_outputs;			\
+	RESTORE_CLOBBER_LIST;				\
+	pop	%ebp;					\
+	ret
+
+/*
+ * Note: The # of inputs does _not_ include both the opcode, and 
+ * the retvals argument.
+ */
+HCALL(2,0, hcall_page_dir, H_PAGE_DIR)
+HCALL(2,1, hcall_get_pte, H_GET_PTE)
+HCALL(1,0, hcall_yield, H_YIELD)
+HCALL(2,0, hcall_flush_tlb, H_FLUSH_TLB)
+HCALL(5,0, hcall_put_term_char, H_PUT_TERM_CHAR)
+HCALL(1,5, hcall_get_term_char, H_GET_TERM_CHAR)
+HCALL(4,0, hcall_dt_entry, H_DT_ENTRY)
+HCALL(1,0, hcall_eoi, H_EOI)
+HCALL(2,0, hcall_interrupt, H_INTERRUPT)
+HCALL(0,1, hcall_xirr, H_XIRR)
+HCALL(2,0, hcall_sys_stack, H_SYS_STACK)
+HCALL(0,1, hcall_get_pfault_addr, H_GET_PFAULT_ADDR)
+HCALL(1,0, hcall_set_mbox, H_SET_MBOX)
+HCALL(5,5, hcall_lpar_info, H_LPAR_INFO)
+HCALL(9,8, hcall_dr, H_DR)
+	
+HCALL(2,0, hcall_get_tce, H_GET_TCE)
+HCALL(4,0, hcall_put_tce, H_PUT_TCE)
+HCALL(7,0, hcall_register_logical_lan, H_REGISTER_LOGICAL_LAN)
+HCALL(1,0, hcall_free_logical_lan, H_FREE_LOGICAL_LAN)
+HCALL(3,0, hcall_add_logical_lan_buffer, H_ADD_LOGICAL_LAN_BUFFER)
+HCALL(15,0, hcall_send_logical_lan, H_SEND_LOGICAL_LAN)
+HCALL(5,0, hcall_multicast_ctrl, H_MULTICAST_CTRL)
+HCALL(3,0, hcall_change_logical_lan_mac, H_CHANGE_LOGICAL_LAN_MAC)
+HCALL(2,0, hcall_vio_signal, H_VIO_SIGNAL)
+
+HCALL(3,0, hcall_reg_crq, H_REG_CRQ)
+HCALL(5,0, hcall_send_crq, H_SEND_CRQ)
+HCALL(1,0, hcall_free_crq, H_FREE_CRQ)
+HCALL(5,0, hcall_copy_rdma, H_COPY_RDMA)
+
+/* int oh_generic_hcall(oh_hcall_args* args) */
+ENTRY(oh_generic_hcall)
+	pushl 	%ebp;
+	movl	8(%esp), %ebp
+	subl	$64, %esp
+	SAVE_CLOBBER_LIST;				
+	movl	36(%ebp), %ecx
+	movl	32(%ebp), %edx
+	movl	28(%ebp), %ebx
+	movl	%ecx, 28(%esp)
+	movl	%edx, 24(%esp)
+	movl	%ebx, 20(%esp)
+	movl	24(%ebp), %edi
+	movl	20(%ebp), %esi
+	movl	16(%ebp), %ebx
+	movl	12(%ebp), %edx
+	movl	8(%ebp),  %ecx
+	movl	4(%ebp),  %eax
+	subl	$4, %ebp
+
+	int	$0xF0;					
+
+	/* need to get &retvals */			
+	addl	$4, %ebp
+	movl	%eax, (%ebp);					
+	movl	%ecx, 8(%ebp)
+	movl	%edx, 12(%ebp)
+	movl	%ebx, 16(%ebp)
+	movl	%esi, 20(%ebp)
+	movl	%edi, 24(%ebp)
+	RESTORE_CLOBBER_LIST;				
+	addl	$64, %esp
+	pop	%ebp;					
+	ret
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/head.S linux--vhype--2.6.11/arch/i386/kernel/head.S
--- linux--2.6.11/arch/i386/kernel/head.S	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/head.S	2005-03-01 21:12:16.000000000 +0000
@@ -19,6 +19,7 @@
 #include <asm/thread_info.h>
 #include <asm/asm_offsets.h>
 #include <asm/setup.h>
+#include <asm/hvcall.h>
 
 /*
  * References to members of the new_cpu_data structure.
@@ -60,9 +61,13 @@ ENTRY(startup_32)
  * Set segments to known values.
  */
 	cld
+#ifndef CONFIG_X86_HYPERVISOR
 	lgdt boot_gdt_descr - __PAGE_OFFSET
 	movl $(__BOOT_DS),%eax
 	movl %eax,%ds
+#else
+	movl %ds,%eax
+#endif
 	movl %eax,%es
 	movl %eax,%fs
 	movl %eax,%gs
@@ -92,7 +97,11 @@ page_pde_offset = (__PAGE_OFFSET >> 20);
 
 	movl $(pg0 - __PAGE_OFFSET), %edi
 	movl $(swapper_pg_dir - __PAGE_OFFSET), %edx
+#ifdef CONFIG_X86_HYPERVISOR
+	movl $0x067, %eax			/* 0x007 = PRESENT+RW+USER+A+D */
+#else
 	movl $0x007, %eax			/* 0x007 = PRESENT+RW+USER */
+#endif
 10:
 	leal 0x007(%edi),%ecx			/* Create PDE entry */
 	movl %ecx,(%edx)			/* Store identity PDE entry */
@@ -122,12 +131,17 @@ page_pde_offset = (__PAGE_OFFSET >> 20);
  */
 ENTRY(startup_32_smp)
 	cld
+#ifndef CONFIG_X86_HYPERVISOR
 	movl $(__BOOT_DS),%eax
 	movl %eax,%ds
+#else
+	movl %ds,%eax
+#endif
 	movl %eax,%es
 	movl %eax,%fs
 	movl %eax,%gs
 
+#ifndef CONFIG_X86_HYPERVISOR			/* FIXME! Figure this out */
 /*
  *	New page tables may be in 4Mbyte page mode and may
  *	be using the global pages. 
@@ -149,6 +163,7 @@ ENTRY(startup_32_smp)
 	movl %cr4,%eax		# Turn on paging options (PSE,PAE,..)
 	orl %edx,%eax
 	movl %eax,%cr4
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	btl $5, %eax		# check if PAE is enabled
 	jnc 6f
@@ -183,16 +198,34 @@ ENTRY(startup_32_smp)
 /*
  * Enable paging
  */
+#ifdef CONFIG_X86_HYPERVISOR
+	movl $H_PAGE_DIR, %eax
+	movl $H_PGD_ACTIVATE|H_PGD_PREFETCH,%ecx
+	movl $swapper_pg_dir-__PAGE_OFFSET,%edx
+	int $0xF0
+	cmpl $H_Success, %eax
+	jnz .			/* not H_Success, spin forever */
+	jmp	1f		/* flush the prefetch-queue */
+1:
+	movl $1f,%eax
+	jmp *%eax		/* make sure eip is relocated */
+#else
 	movl $swapper_pg_dir-__PAGE_OFFSET,%eax
 	movl %eax,%cr3		/* set the page table pointer.. */
 	movl %cr0,%eax
 	orl $0x80000000,%eax
 	movl %eax,%cr0		/* ..and set paging (PG) bit */
 	ljmp $__BOOT_CS,$1f	/* Clear prefetch and normalize %eip */
+#endif /* CONFIG_X86_HYPERVISOR */
 1:
 	/* Set up the stack pointer */
+#ifdef CONFIG_X86_HYPERVISOR
+	movl $init_thread_union+THREAD_SIZE, %esp
+#else
 	lss stack_start,%esp
+#endif
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * Initialize eflags.  Some BIOS's leave bits like NT set.  This would
  * confuse the debugger if this code is traced.
@@ -200,6 +233,7 @@ ENTRY(startup_32_smp)
  */
 	pushl $0
 	popfl
+#endif /* CONFIG_X86_HYPERVISOR */
 
 #ifdef CONFIG_SMP
 	andl %ebx,%ebx
@@ -208,11 +242,13 @@ ENTRY(startup_32_smp)
 1:
 #endif /* CONFIG_SMP */
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * start system 32-bit setup. We need to re-do some of the things done
  * in 16-bit mode for the "real" operations.
  */
 	call setup_idt
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  * Copy bootup parameters out of the way.
@@ -236,6 +272,19 @@ ENTRY(startup_32_smp)
 	rep
 	movsl
 1:
+
+
+#ifdef CONFIG_X86_HYPERVISOR
+	movl boot_params+NEW_VD_POINTER,%esi
+	andl %esi,%esi
+	jz 3f                   # No vdev data given
+	movl $vdev_descriptions,%edi
+	movl $(VDEV_DESCRIPTION_SIZE/4),%ecx
+	rep
+	movsl
+3:
+#endif
+
 checkCPUtype:
 
 	movl $-1,X86_CPUID		#  -1 for no CPUID initially
@@ -287,17 +336,26 @@ checkCPUtype:
 	movb %al,X86_MODEL
 	andb $0x0f,%cl		# mask mask revision
 	movb %cl,X86_MASK
+#ifdef CONFIG_X86_HYPERVISOR
+	andl $~(1<<3), %edx	# disable PSE until HV supports it
+	andl $~(1<<11), %edx	# disable SYSENTER/SYSEXIT
+#endif /* CONFIG_X86_HYPERVISOR */
 	movl %edx,X86_CAPABILITY
 
 is486:	movl $0x50022,%ecx	# set AM, WP, NE and MP
 	jmp 2f
 
 is386:	movl $2,%ecx		# set MP
-2:	movl %cr0,%eax
+2:
+#ifndef CONFIG_X86_HYPERVISOR
+	movl %cr0,%eax
 	andl $0x80000011,%eax	# Save PG,PE,ET
 	orl %ecx,%eax
 	movl %eax,%cr0
+#endif /* CONFIG_X86_HYPERVISOR */
 
+/* FIXME! temporarily commented out, find out whats going on here */
+#ifndef CONFIG_X86_HYPERVISOR
 	call check_x87
 	incb ready
 	lgdt cpu_gdt_descr
@@ -324,6 +382,8 @@ is386:	movl $2,%ecx		# set MP
 	jmp L6
 1:
 #endif /* CONFIG_SMP */
+#endif /* CONFIG_X86_HYPERVISOR */
+
 	call start_kernel
 L6:
 	jmp L6			# main should never return here, but
@@ -422,9 +482,11 @@ ENTRY(empty_zero_page)
  */
 .data
 
+#ifndef CONFIG_X86_HYPERVISOR
 ENTRY(stack_start)
 	.long init_thread_union+THREAD_SIZE
 	.long __BOOT_DS
+#endif
 
 ready:	.byte 0
 
@@ -443,11 +505,13 @@ int_msg:
 .globl cpu_gdt_descr
 
 	ALIGN
+#ifndef CONFIG_X86_HYPERVISOR
 # early boot GDT descriptor (must use 1:1 address mapping)
 	.word 0				# 32 bit align gdt_desc.address
 boot_gdt_descr:
 	.word __BOOT_DS+7
 	.long boot_gdt_table - __PAGE_OFFSET
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	.word 0				# 32-bit align idt_desc.address
 idt_descr:
@@ -462,6 +526,7 @@ cpu_gdt_descr:
 
 	.fill NR_CPUS-1,8,0		# space for the other GDT descriptors
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * The boot_gdt_table must mirror the equivalent in setup.S and is
  * used only for booting.
@@ -471,6 +536,7 @@ ENTRY(boot_gdt_table)
 	.fill GDT_ENTRY_BOOT_CS,8,0
 	.quad 0x00cf9a000000ffff	/* kernel 4GB code at 0x00000000 */
 	.quad 0x00cf92000000ffff	/* kernel 4GB data at 0x00000000 */
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  * The Global Descriptor Table contains 28 quadwords, per-CPU.
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/hvc_calls.c linux--vhype--2.6.11/arch/i386/kernel/hvc_calls.c
--- linux--2.6.11/arch/i386/kernel/hvc_calls.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/hvc_calls.c	2005-03-01 21:12:16.000000000 +0000
@@ -0,0 +1,85 @@
+/*
+ * hvc_calls.c
+ *
+ * Copyright (C) 2004 IBM Corporation
+ *
+ * xSeries hypervisor support for virtual terminal.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/mmu_context.h>
+#include <asm/debugreg.h>
+#include <asm/tlbflush.h>
+#include <asm/hvcall.h>
+#ifdef CONFIG_X86_HYPERVISOR
+#include <asm/hvconsole.h>
+#endif
+
+
+int
+hvc_get_chars(uint32_t index, char *buf, int count)
+{
+	u32 retvals[5];
+
+	if (hcall_get_term_char(retvals, index, count) == H_Success) {
+		memcpy(buf, retvals+1, retvals[0]);
+		return retvals[0];
+	}
+	return 0;
+}
+
+int
+hvc_put_chars(uint32_t index, const char *buf, int count)
+{
+	u32 *lbuf = (u32 *)buf;
+	u32 dummy = 0;
+	int ret;
+
+	ret = hcall_put_term_char(NULL, index, count, lbuf[0], lbuf[1],
+			(u32) &dummy, (u32) &dummy);
+	if (ret == H_Success)
+		return count;
+	if (ret == H_Busy)
+		return 0;
+	return -1;
+}
+
+int hvc_find_vtys(void)
+{
+	hvc_instantiate(0, 0);
+	return 1; /* XXX find our termno, possibly from a mailbox */
+}
+
+#define HVC_DEBUG
+#ifdef HVC_DEBUG
+/* Useful for debugging when the console has not been initialized yet */
+void
+MYPUTS(const char *s)
+{
+	for (; *s != '\0'; s++)
+		hvc_put_chars(0, s, 1);
+}
+
+void
+MYPRINTK(const char *fmt, ...)
+{
+        static char buf[1024];
+        va_list args;
+        int len;
+	char *p;
+
+        va_start(args, fmt);
+        len = vscnprintf(buf, sizeof(buf), fmt, args);
+        va_end(args);
+
+	for (p = buf; p < &buf[len]; p++)
+		hvc_put_chars(0, p, 1);
+}
+#endif /* HVC_DEBUG */
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/i8259.c linux--vhype--2.6.11/arch/i386/kernel/i8259.c
--- linux--2.6.11/arch/i386/kernel/i8259.c	2005-03-01 16:22:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/i8259.c	2005-03-01 21:17:00.000000000 +0000
@@ -40,23 +40,70 @@
 
 DEFINE_SPINLOCK(i8259A_lock);
 
-static void end_8259A_irq (unsigned int irq)
+#ifdef CONFIG_X86_HYPERVISOR
+static void end_8259V_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)) &&
+							irq_desc[irq].action)
+		enable_8259V_irq(irq);
+
+	if (hcall_eoi(NULL, irq) != H_Success)
+		BUG();
+}
+
+void mask_and_ack_8259V(unsigned int);
+#else
+static void end_8259A_irq(unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)) &&
 							irq_desc[irq].action)
 		enable_8259A_irq(irq);
 }
 
+void mask_and_ack_8259A(unsigned int);
+#endif /* CONFIG_X86_HYPERVISOR */
+
 #define shutdown_8259A_irq	disable_8259A_irq
 
-void mask_and_ack_8259A(unsigned int);
+#ifdef CONFIG_X86_HYPERVISOR
+unsigned int startup_8259V_irq(unsigned int irq)
+{
+	unsigned int mask = ~(1 << irq);
+	unsigned long flags;
 
+	spin_lock_irqsave(&i8259A_lock, flags);
+
+	cached_irq_mask &= mask;
+	oh_mbox.irq_masked = cached_irq_mask;
+
+	/* acknowledge any pending interrupts */
+	if (hcall_eoi(NULL, irq) != H_Success)
+		BUG();
+
+	spin_unlock_irqrestore(&i8259A_lock, flags);
+
+	return 0;
+}
+#else
 unsigned int startup_8259A_irq(unsigned int irq)
 { 
 	enable_8259A_irq(irq);
 	return 0; /* never anything pending */
 }
+#endif /* CONFIG_X86_HYPERVISOR */
 
+#ifdef CONFIG_X86_HYPERVISOR
+static struct hw_interrupt_type i8259A_irq_type = {
+	"XT-vPIC",
+	startup_8259V_irq,
+	disable_8259V_irq,
+	enable_8259V_irq,
+	disable_8259V_irq,
+	mask_and_ack_8259V,
+	end_8259V_irq,
+	NULL
+};
+#else
 static struct hw_interrupt_type i8259A_irq_type = {
 	"XT-PIC",
 	startup_8259A_irq,
@@ -67,6 +114,7 @@ static struct hw_interrupt_type i8259A_i
 	end_8259A_irq,
 	NULL
 };
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  * 8259A PIC functions to handle ISA devices:
@@ -102,6 +150,30 @@ void disable_8259A_irq(unsigned int irq)
 	spin_unlock_irqrestore(&i8259A_lock, flags);
 }
 
+#ifdef CONFIG_X86_HYPERVISOR
+void disable_8259V_irq(unsigned int irq)
+{
+	unsigned int mask = 1 << irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&i8259A_lock, flags);
+	cached_irq_mask |= mask;
+	oh_mbox.irq_masked = cached_irq_mask;
+	spin_unlock_irqrestore(&i8259A_lock, flags);
+}
+
+void enable_8259V_irq(unsigned int irq)
+{
+	unsigned int mask = ~(1 << irq);
+	unsigned long flags;
+
+	spin_lock_irqsave(&i8259A_lock, flags);
+	cached_irq_mask &= mask;
+	oh_mbox.irq_masked = cached_irq_mask;
+	spin_unlock_irqrestore(&i8259A_lock, flags);
+}
+#endif /* CONFIG_X86_HYPERVISOR */
+
 void enable_8259A_irq(unsigned int irq)
 {
 	unsigned int mask = ~(1 << irq);
@@ -140,6 +212,7 @@ void make_8259A_irq(unsigned int irq)
 	enable_irq(irq);
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * This function assumes to be called rarely. Switching between
  * 8259A registers is slow.
@@ -162,7 +235,20 @@ static inline int i8259A_irq_real(unsign
 	outb(0x0A,PIC_SLAVE_CMD);	/* back to the IRR register */
 	return value;
 }
+#endif /* !CONFIG_X86_HYPERVISOR */
+
+#ifdef CONFIG_X86_HYPERVISOR
+void mask_and_ack_8259V(unsigned int irq)
+{
+	unsigned int irqmask = 1 << irq;
+	unsigned long flags;
 
+	spin_lock_irqsave(&i8259A_lock, flags);
+	cached_irq_mask |= irqmask;
+	oh_mbox.irq_masked = cached_irq_mask;
+	spin_unlock_irqrestore(&i8259A_lock, flags);
+}
+#else
 /*
  * Careful! The 8259A is a fragile beast, it pretty
  * much _has_ to be done exactly like this (mask it
@@ -255,17 +341,22 @@ static void save_ELCR(char *trigger)
 	trigger[0] = inb(0x4d0) & 0xF8;
 	trigger[1] = inb(0x4d1) & 0xDE;
 }
+#endif
 
 static int i8259A_resume(struct sys_device *dev)
 {
+#ifndef CONFIG_X86_HYPERVISOR
 	init_8259A(0);
 	restore_ELCR(irq_trigger);
+#endif
 	return 0;
 }
 
 static int i8259A_suspend(struct sys_device *dev, u32 state)
 {
+#ifndef CONFIG_X86_HYPERVISOR
 	save_ELCR(irq_trigger);
+#endif
 	return 0;
 }
 
@@ -290,6 +381,7 @@ static int __init i8259A_init_sysfs(void
 
 device_initcall(i8259A_init_sysfs);
 
+#ifndef CONFIG_X86_HYPERVISOR
 void init_8259A(int auto_eoi)
 {
 	unsigned long flags;
@@ -330,6 +422,7 @@ void init_8259A(int auto_eoi)
 
 	spin_unlock_irqrestore(&i8259A_lock, flags);
 }
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  * Note that on a 486, we don't want to do a SIGFPE on an irq13
@@ -367,7 +460,9 @@ void __init init_ISA_irqs (void)
 #ifdef CONFIG_X86_LOCAL_APIC
 	init_bsp_APIC();
 #endif
+#ifndef CONFIG_X86_HYPERVISOR
 	init_8259A(0);
+#endif
 
 	for (i = 0; i < NR_IRQS; i++) {
 		irq_desc[i].status = IRQ_DISABLED;
@@ -379,11 +474,6 @@ void __init init_ISA_irqs (void)
 			 * 16 old-style INTA-cycle interrupts:
 			 */
 			irq_desc[i].handler = &i8259A_irq_type;
-		} else {
-			/*
-			 * 'high' PCI IRQs filled in on demand
-			 */
-			irq_desc[i].handler = &no_irq_type;
 		}
 	}
 }
@@ -413,11 +503,13 @@ void __init init_IRQ(void)
 	 */
 	intr_init_hook();
 
+#ifndef CONFIG_X86_HYPERVISOR
 	/*
 	 * Set the clock to HZ Hz, we already have a valid
 	 * vector now:
 	 */
 	setup_pit_timer();
+#endif
 
 	/*
 	 * External FPU? Set up irq13 if so, for
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/iommu.c linux--vhype--2.6.11/arch/i386/kernel/iommu.c
--- linux--2.6.11/arch/i386/kernel/iommu.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/iommu.c	2005-03-01 21:12:16.000000000 +0000
@@ -0,0 +1,2 @@
+#include <linux/config.h>
+#include "../../ppc64/kernel/iommu.c"
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/irq.c linux--vhype--2.6.11/arch/i386/kernel/irq.c
--- linux--2.6.11/arch/i386/kernel/irq.c	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/irq.c	2005-03-01 21:12:16.000000000 +0000
@@ -40,6 +40,10 @@ static union irq_ctx *hardirq_ctx[NR_CPU
 static union irq_ctx *softirq_ctx[NR_CPUS];
 #endif
 
+#ifdef CONFIG_X86_HYPERVISOR
+extern int get_openhype_irq(void);
+#endif
+
 /*
  * do_IRQ handles all normal device IRQ's (the special
  * SMP cross-CPU interrupts have their own specific
@@ -53,8 +57,25 @@ fastcall unsigned int do_IRQ(struct pt_r
 	union irq_ctx *curctx, *irqctx;
 	u32 *isp;
 #endif
+#ifdef CONFIG_X86_HYPERVISOR
+	int again = 0;
+#endif
 
 	irq_enter();
+
+#ifdef CONFIG_X86_HYPERVISOR
+	/* This is temporary. Just use irq 31 to "gate" interrupts we
+	 * get through H_XIRR. */
+restart:
+	if (irq == 31 || again) {
+		again = 1;
+		irq = get_openhype_irq();
+	}
+	if (irq == -1) {
+		goto finished;
+	}
+#endif
+	
 #ifdef CONFIG_DEBUG_STACKOVERFLOW
 	/* Debugging check for stack overflow: is there less than 1KB free? */
 	{
@@ -101,6 +122,13 @@ fastcall unsigned int do_IRQ(struct pt_r
 #endif
 		__do_IRQ(irq, regs);
 
+#ifdef CONFIG_X86_HYPERVISOR
+	if (again) {
+		goto restart;
+	}
+finished:
+#endif
+
 	irq_exit();
 
 	return 1;
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/oh_iommu.c linux--vhype--2.6.11/arch/i386/kernel/oh_iommu.c
--- linux--2.6.11/arch/i386/kernel/oh_iommu.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/oh_iommu.c	2005-03-01 21:12:16.000000000 +0000
@@ -0,0 +1,125 @@
+/*
+ * arch/i386/kernel/oh_iommu.c
+ *
+ * Use this iommu-specific implementation if your processor has no
+ * native support for TCEs (translation control entries). This module
+ * places hypervisor calls to setup the TCEs in the hypervisor.
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <asm/io.h>
+#include <asm/iommu.h>
+#include <asm/machdep.h>
+
+static int print_tce_mappings = 0;
+
+static void
+tce_build_oh(struct iommu_table *tbl, long tcenum,
+	     long npages, unsigned long uaddr,
+	     enum dma_data_direction direction)
+{
+	union tce_entry tce;
+	int rc;
+
+	tce.te_word = 0;
+	tce.te_rpn = __pa(uaddr) >> PAGE_SHIFT;	/* logical address */
+	tce.te_rdwr = 1;
+	if (direction != PCI_DMA_TODEVICE)
+		tce.te_pciwr = 1;
+
+	if (unlikely(print_tce_mappings)) {
+		u32 paddr,
+		    pte;
+
+		if (hcall_get_pte((u32 *) & pte,
+				  H_GET_ENTRY_PTE | H_GET_ENTRY_PHYSICAL,
+				  uaddr) != H_Success)
+			BUG();
+		if ((pte & _PAGE_PSE) == 0)
+			paddr = (pte & PAGE_MASK) + (uaddr & ~PAGE_MASK);
+		else
+			paddr = (pte & LARGE_PAGE_MASK) +
+				(uaddr & ~LARGE_PAGE_MASK);
+		printk("TCE: va 0x%lx, la 0x%lx, pa 0x%x, dma 0x%lx, npages %ld\n", 
+		       uaddr, __pa(uaddr), paddr, tcenum << PAGE_SHIFT, npages);
+	}
+
+	while (npages-- > 0) {
+		rc = hcall_put_tce(NULL, tbl->it_index, tcenum << PAGE_SHIFT,
+				   tce.te_word);
+		if (rc != H_Success && printk_ratelimit()) {
+			printk("tce_build: hcall_put_tce failed. rc=%d\n", rc);
+			printk("\tindex   = 0x%lx\n", tbl->it_index);
+			printk("\ttcenum  = 0x%lx\n", tcenum);
+			printk("\ttce val = 0x%llx\n", tce.te_word);
+			show_stack(NULL, NULL);
+		}
+		tcenum++;
+		tce.te_rpn++;
+	}
+}
+
+static void
+tce_free_oh(struct iommu_table *tbl, long tcenum, long npages)
+{
+	union tce_entry tce;
+	int rc;
+
+	tce.te_word = 0;
+	while (npages--) {
+		rc = hcall_put_tce(NULL, tbl->it_index, tcenum << PAGE_SHIFT,
+				   tce.te_word);
+		if (rc != H_Success && printk_ratelimit()) {
+			printk("tce_free: hcall_put_tce failed. rc=%d\n", rc);
+			printk("\tindex   = 0x%lx\n", tbl->it_index);
+			printk("\ttcenum  = 0x%lx\n", tcenum);
+			printk("\ttce val = 0x%llx\n", tce.te_word);
+			show_stack(NULL, NULL);
+		}
+		tcenum++;
+	}
+}
+
+struct iommu_table *
+iommu_build_tce_table(struct vio_dev *vdev)
+{
+	struct iommu_table *tbl;
+
+	tbl = (struct iommu_table *)kmalloc(sizeof (struct iommu_table),
+					    GFP_KERNEL);
+	if (tbl == NULL)
+		return NULL;
+	memset(tbl, 0, sizeof (struct iommu_table));
+
+	tbl->it_size = (vdev->liobs / PAGE_SIZE);
+
+	/* offset for VIO should always be 0 */
+	tbl->it_offset = 0;
+	tbl->it_index = vdev->liobn;
+
+	return iommu_init_table(tbl);
+}
+
+struct machdep_calls ppc_md = {
+	.tce_build = tce_build_oh,
+	.tce_free = tce_free_oh,
+	.tce_flush = NULL,
+};
+
+/* These are called very early - if at all */
+void
+tce_init_oh(void)
+{
+	ppc_md.tce_build = tce_build_oh;
+	ppc_md.tce_free = tce_free_oh;
+	ppc_md.tce_flush = NULL;
+}
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/openhype.c linux--vhype--2.6.11/arch/i386/kernel/openhype.c
--- linux--2.6.11/arch/i386/kernel/openhype.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/openhype.c	2005-03-03 20:28:10.000000000 +0000
@@ -0,0 +1,183 @@
+/* OpenHype support code
+ *
+ * Copyright (C) 2004, Michal Ostrowski IBM Corporation.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/openhype.h>
+#include <asm/hvcall.h>
+#include <asm/desc.h>
+#include <linux/interrupt.h>
+extern int map_openhype_irq(unsigned int xirr);
+
+struct irq_map_s {
+	unsigned int xirr;
+	unsigned int vector;
+};
+
+#define IRQ_MAP_SIZE 64
+static struct irq_map_s irq_map[IRQ_MAP_SIZE] = { {0, 0} };
+static spinlock_t oh_irq_lock = SPIN_LOCK_UNLOCKED;
+
+
+
+static unsigned int irq_to_xirr(unsigned int irq)
+{
+	int ret = 0;
+	int x;
+	for(x = 0; x < 64; ++x) {
+		if(irq_map[x].vector == irq) {
+			ret = irq_map[x].xirr;
+		}
+	}
+	return ret;
+}
+
+static void enable_ohic(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned int xirr;
+	spin_lock_irqsave(&oh_irq_lock, flags);
+
+	xirr = irq_to_xirr(irq);
+	
+	hcall_interrupt(NULL, xirr, 1);
+
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+}
+
+static void disable_ohic(unsigned int irq)
+{
+	unsigned long flags;
+	unsigned int xirr;
+	spin_lock_irqsave(&oh_irq_lock, flags);
+
+	xirr = irq_to_xirr(irq);
+
+	hcall_interrupt(NULL, xirr, 0);
+
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+}
+
+static void ack_ohic(unsigned int irq)
+{
+}
+
+static void end_ohic(unsigned int irq)
+{
+	int x;
+	unsigned long flags;
+	spin_lock_irqsave(&oh_irq_lock, flags);
+	for(x = 0; x < IRQ_MAP_SIZE; ++x) {
+		if(irq_map[x].vector == irq) {
+			hcall_eoi(NULL, irq_map[x].xirr);
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+}
+
+static unsigned int startup_ohic(unsigned int irq)
+{
+	enable_ohic(irq);
+	return 0;
+}
+
+static void shutdown_ohic(unsigned int irq)
+{
+	disable_ohic(irq);
+}
+
+
+
+static struct hw_interrupt_type ohic_type = {
+	"OHIC",
+	startup_ohic,
+	shutdown_ohic,
+	enable_ohic,
+	disable_ohic,
+	ack_ohic,
+	end_ohic
+};
+
+int map_openhype_xirr(unsigned int xirr)
+{
+	int irq;
+	int x = 0;
+	unsigned long flags;
+	spin_lock_irqsave(&oh_irq_lock, flags);
+
+	for(irq = NR_IRQS-1; irq > 0; --irq) {
+		if(irq_desc[irq].handler == &no_irq_type) {
+			irq_desc[irq].handler = &ohic_type;
+			break;
+		}
+	}
+
+	if(irq == 0) {
+		irq = -1;
+		goto finish;
+	}
+
+	for(x = 0; x < IRQ_MAP_SIZE; ++x) {
+		if(irq_map[x].xirr == 0) {
+			break;
+		}
+	}
+
+	if(x == IRQ_MAP_SIZE) {
+		irq = -1;
+		goto finish;
+	}
+
+	irq_map[x].xirr = xirr;
+	irq_map[x].vector = irq;
+finish:
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+	return irq;
+}
+
+
+int unmap_openhype_xirr(unsigned int xirr)
+{
+	unsigned long flags;
+	int x;
+	spin_lock_irqsave(&oh_irq_lock, flags);
+	for(x = 0; x < IRQ_MAP_SIZE; ++x) {
+		if(irq_map[x].xirr == xirr) {
+			irq_map[x].xirr = 0;
+			irq_map[x].vector = 0;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+	return 0;
+}
+
+extern int get_openhype_irq(void);
+int get_openhype_irq() 
+{
+	int xirr = 0;
+	unsigned long flags;
+	int ret,x;
+	ret = hcall_xirr(&xirr);
+
+	if(ret<0){
+		printk(KERN_ERR "h_xirr error: %d %x\n", ret, xirr);
+		return 0;
+	}
+
+	if(xirr == 0)
+		return -1;
+
+	spin_lock_irqsave(&oh_irq_lock, flags);
+	for(x = 0; x < 64; ++x) {
+		if(irq_map[x].xirr == xirr) {
+			xirr = irq_map[x].vector;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+	return xirr;
+}
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/pci-dma.c linux--vhype--2.6.11/arch/i386/kernel/pci-dma.c
--- linux--2.6.11/arch/i386/kernel/pci-dma.c	2005-03-01 17:18:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/pci-dma.c	2005-03-02 15:47:45.000000000 +0000
@@ -12,6 +12,10 @@
 #include <linux/string.h>
 #include <linux/pci.h>
 #include <asm/io.h>
+#ifdef CONFIG_X86_HYPERVISOR
+#include <asm/hvcall.h>
+#include <asm/vio.h>
+#endif
 
 struct dma_coherent_mem {
 	void		*virt_base;
@@ -50,7 +54,27 @@ void *dma_alloc_coherent(struct device *
 
 	if (ret != NULL) {
 		memset(ret, 0, size);
+#ifdef CONFIG_X86_HYPERVISOR
+		if (dev->bus == &vio_bus_type) {
+			struct vio_dev * temp = to_vio_dev(dev);
+			*dma_handle = vio_map_single(temp,ret,size,DMA_BIDIRECTIONAL);
+			return ret;
+		}
+		{
+		u32 pte;
+		if (hcall_get_pte(&pte, H_GET_ENTRY_PTE | H_GET_ENTRY_PHYSICAL,
+							(u32) ret) != H_Success)
+			BUG();
+                if ((pte & _PAGE_PSE) == 0)
+			*dma_handle = (pte & PAGE_MASK)
+				+ ((u32) ret & ~PAGE_MASK);
+                else
+			*dma_handle = (pte & LARGE_PAGE_MASK)
+				+ ((u32) ret & ~LARGE_PAGE_MASK);
+		}
+#else
 		*dma_handle = virt_to_phys(ret);
+#endif
 	}
 	return ret;
 }
@@ -60,6 +84,13 @@ void dma_free_coherent(struct device *de
 {
 	struct dma_coherent_mem *mem = dev ? dev->dma_mem : NULL;
 	int order = get_order(size);
+
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		struct vio_dev * temp = to_vio_dev(dev);
+		vio_unmap_single(temp,dma_handle,size,DMA_BIDIRECTIONAL);
+	}
+#endif
 	
 	if (mem && vaddr >= mem->virt_base && vaddr < (mem->virt_base + (mem->size << PAGE_SHIFT))) {
 		int page = (vaddr - mem->virt_base) >> PAGE_SHIFT;
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/process.c linux--vhype--2.6.11/arch/i386/kernel/process.c
--- linux--2.6.11/arch/i386/kernel/process.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/process.c	2005-03-01 21:23:52.000000000 +0000
@@ -46,6 +46,7 @@
 #include <asm/i387.h>
 #include <asm/irq.h>
 #include <asm/desc.h>
+#include <asm/hvcall.h>
 #ifdef CONFIG_MATH_EMULATION
 #include <asm/math_emu.h>
 #endif
@@ -94,6 +95,11 @@ EXPORT_SYMBOL(enable_hlt);
  */
 void default_idle(void)
 {
+#if defined(CONFIG_X86_HYPERVISOR) && defined(H_YIELD_WORKS)
+	/* Currently using this causes the clock to slow down. */
+	if (hcall_yield(NULL, H_SELF_SYSID) != H_Success)
+		BUG();
+#else
 	if (!hlt_counter && boot_cpu_data.hlt_works_ok) {
 		local_irq_disable();
 		if (!need_resched())
@@ -103,6 +109,7 @@ void default_idle(void)
 	} else {
 		cpu_relax();
 	}
+#endif	/* CONFIG_X86_HYPERVISOR */
 }
 
 /*
@@ -243,14 +250,16 @@ __setup("idle=", idle_setup);
 
 void show_regs(struct pt_regs * regs)
 {
+#ifndef CONFIG_X86_HYPERVISOR
 	unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L;
+#endif
 
 	printk("\n");
 	printk("Pid: %d, comm: %20s\n", current->pid, current->comm);
 	printk("EIP: %04x:[<%08lx>] CPU: %d\n",0xffff & regs->xcs,regs->eip, smp_processor_id());
 	print_symbol("EIP is at %s\n", regs->eip);
 
-	if (regs->xcs & 3)
+	if ((regs->xcs & 3) == 3)
 		printk(" ESP: %04x:%08lx",0xffff & regs->xss,regs->esp);
 	printk(" EFLAGS: %08lx    %s  (%s)\n",
 	       regs->eflags, print_tainted(), system_utsname.release);
@@ -261,6 +270,7 @@ void show_regs(struct pt_regs * regs)
 	printk(" DS: %04x ES: %04x\n",
 		0xffff & regs->xds,0xffff & regs->xes);
 
+#ifndef CONFIG_X86_HYPERVISOR
 	__asm__("movl %%cr0, %0": "=r" (cr0));
 	__asm__("movl %%cr2, %0": "=r" (cr2));
 	__asm__("movl %%cr3, %0": "=r" (cr3));
@@ -272,6 +282,7 @@ void show_regs(struct pt_regs * regs)
 		".previous			\n"
 		: "=r" (cr4): "0" (0));
 	printk("CR0: %08lx CR2: %08lx CR3: %08lx CR4: %08lx\n", cr0, cr2, cr3, cr4);
+#endif
 	show_trace(NULL, &regs->esp);
 }
 
@@ -539,10 +550,12 @@ handle_io_bitmap(struct thread_struct *n
 /*
  * This special macro can be used to load a debugging register
  */
+#ifndef CONFIG_X86_HYPERVISOR
 #define loaddebug(thread,register) \
 		__asm__("movl %0,%%db" #register  \
 			: /* no output */ \
 			:"r" (thread->debugreg[register]))
+#endif
 
 /*
  *	switch_to(x,yn) should switch tasks from x to y.
@@ -588,17 +601,26 @@ struct task_struct fastcall * __switch_t
 	load_esp0(tss, next);
 
 	/*
-	 * Load the per-thread Thread-Local Storage descriptor.
-	 */
-	load_TLS(next, cpu);
-
-	/*
 	 * Save away %fs and %gs. No need to save %es and %ds, as
 	 * those are always kernel segments while inside the kernel.
 	 */
 	asm volatile("movl %%fs,%0":"=m" (*(int *)&prev->fs));
 	asm volatile("movl %%gs,%0":"=m" (*(int *)&prev->gs));
 
+#ifdef	CONFIG_X86_HYPERVISOR
+	/*
+	 * load_TLS() will result in hcalls that may make the current %fs
+	 * and %gs segments invalid.  Clear these SRs so that the hypervisor
+	 * won't have a problem restoring them.
+	 */
+	asm volatile("movl %0,%%fs; movl %0,%%gs" : : "r" (0));
+#endif
+
+	/*
+	 * Load the per-thread Thread-Local Storage descriptor.
+	 */
+	load_TLS(next, cpu);
+
 	/*
 	 * Restore %fs and %gs if needed.
 	 */
@@ -611,6 +633,10 @@ struct task_struct fastcall * __switch_t
 	 * Now maybe reload the debug registers
 	 */
 	if (unlikely(next->debugreg[7])) {
+#ifdef CONFIG_X86_HYPERVISOR
+		if (hcall_set_drs(next->debugreg) != H_Success)
+			BUG();
+#else /* CONFIG_X86_HYPERVISOR */
 		loaddebug(next, 0);
 		loaddebug(next, 1);
 		loaddebug(next, 2);
@@ -618,6 +644,7 @@ struct task_struct fastcall * __switch_t
 		/* no 4 and 5 */
 		loaddebug(next, 6);
 		loaddebug(next, 7);
+#endif /* CONFIG_X86_HYPERVISOR */
 	}
 
 	if (unlikely(prev->io_bitmap_ptr || next->io_bitmap_ptr))
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/reboot.c linux--vhype--2.6.11/arch/i386/kernel/reboot.c
--- linux--2.6.11/arch/i386/kernel/reboot.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/reboot.c	2005-03-01 21:23:52.000000000 +0000
@@ -11,6 +11,7 @@
 #include <linux/efi.h>
 #include <linux/dmi.h>
 #include <asm/uaccess.h>
+#include <asm/mmu_context.h>
 #include <asm/apic.h>
 #include "mach_reboot.h"
 
@@ -243,7 +244,11 @@ void machine_real_restart(unsigned char 
 	/*
 	 * Use `swapper_pg_dir' as our page directory.
 	 */
+#ifndef CONFIG_X86_HYPERVISOR
 	load_cr3(swapper_pg_dir);
+#else
+	load_page_dir(H_PGD_ACTIVATE|H_PGD_PREFETCH, swapper_pg_dir);
+#endif
 
 	/* Write 0x1234 to absolute memory location 0x472.  The BIOS reads
 	   this on booting to tell it to "Bypass memory test (also warm
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/setup.c linux--vhype--2.6.11/arch/i386/kernel/setup.c
--- linux--2.6.11/arch/i386/kernel/setup.c	2005-03-01 17:45:19.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/setup.c	2005-03-03 20:28:10.000000000 +0000
@@ -59,6 +59,35 @@ unsigned long init_pg_tables_end __initd
 
 int disable_pse __initdata = 0;
 
+#ifdef CONFIG_X86_HYPERVISOR
+#include <linux/openhype.h>
+
+volatile oh_mailbox_t oh_mbox = {
+	.IF = 0,
+	.irq_masked = 0,
+	.irq_pending = 0,
+	.ticks = 0
+};
+EXPORT_SYMBOL(oh_mbox);
+
+/*
+ * Ask the hypervisor for the partition info. This includes
+ * information such as lpar ID and memory sizes.
+ */
+oh_partition_info_t *
+oh_get_partition_info(void)
+{
+	static oh_partition_info_t partinfo;
+
+	memset(&partinfo, 0, sizeof(partinfo));
+	if (hcall_lpar_info(NULL, H_GET_PINFO, __pa(&partinfo), 0, 0, 0)
+				!= H_Success)
+		BUG();
+
+	return &partinfo;
+}
+#endif /* CONFIG_X86_HYPERVISOR */
+
 /*
  * Machine setup..
  */
@@ -416,6 +445,7 @@ static void __init print_memory_map(char
 	}
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * Sanitize the BIOS e820 map.
  *
@@ -635,6 +665,7 @@ static int __init copy_e820_map(struct e
 	} while (biosmap++,--nr_map);
 	return 0;
 }
+#endif /* CONFIG_X86_HYPERVISOR */
 
 #if defined(CONFIG_EDD) || defined(CONFIG_EDD_MODULE)
 struct edd edd;
@@ -1126,6 +1157,7 @@ static unsigned long __init setup_memory
 extern unsigned long setup_memory(void);
 #endif /* !CONFIG_DISCONTIGMEM */
 
+
 /*
  * Request address space for all standard RAM and ROM resources
  * and also for regions reported as reserved by the e820.
@@ -1356,6 +1388,41 @@ void __init setup_arch(char **cmdline_p)
 	unsigned long max_low_pfn;
 
 	memcpy(&boot_cpu_data, &new_cpu_data, sizeof(new_cpu_data));
+
+#ifdef CONFIG_X86_HYPERVISOR
+	/*
+	 * Force the features the hypervisor implements
+	 */
+	set_bit(X86_FEATURE_PSE, boot_cpu_data.x86_capability); 
+
+	/*
+	 * Initially we start off with a feature-less kernel and
+	 * enable capabilities as soon as we figured out how to
+	 * implement them in the hypervisor.
+	 */
+	clear_bit(X86_FEATURE_TSC, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MSR, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_PAE, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MCE, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MCA, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MTRR, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_PGE, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_PAT, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_PSE36, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_PN, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_CLFLSH, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_DTES, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_ACPI, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_HT, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_ACC, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_IA64, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MP, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_MMXEXT, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_LM, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_3DNOWEXT, boot_cpu_data.x86_capability);
+	clear_bit(X86_FEATURE_3DNOW, boot_cpu_data.x86_capability);
+#endif
+
 	pre_setup_arch_hook();
 	early_cpu_init();
 
@@ -1449,20 +1516,28 @@ void __init setup_arch(char **cmdline_p)
 	}
 #endif
 
+#ifdef CONFIG_X86_HYPERVISOR
+	if (oh_iopriv())
+		setup_isamap();
+#endif
 
+#ifndef CONFIG_X86_HYPERVISOR
 	dmi_scan_machine();
+#endif
 
 #ifdef CONFIG_X86_GENERICARCH
 	generic_apic_probe(*cmdline_p);
 #endif	
 	if (efi_enabled)
 		efi_map_memmap();
-
+	
+#ifndef CONFIG_X86_HYPERVISOR
 	/*
 	 * Parse the ACPI tables for possible boot-time SMP configuration.
 	 */
 	acpi_boot_table_init();
 	acpi_boot_init();
+#endif
 
 #ifdef CONFIG_X86_LOCAL_APIC
 	if (smp_found_config)
@@ -1473,8 +1548,14 @@ void __init setup_arch(char **cmdline_p)
 
 #ifdef CONFIG_VT
 #if defined(CONFIG_VGA_CONSOLE)
-	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY))
-		conswitchp = &vga_con;
+	if (!efi_enabled || (efi_mem_type(0xa0000) != EFI_CONVENTIONAL_MEMORY)){
+#ifdef CONFIG_X86_HYPERVISOR
+		if (!oh_iopriv())
+			conswitchp = &dummy_con;
+		else
+#endif
+			conswitchp = &vga_con;
+	}
 #elif defined(CONFIG_DUMMY_CONSOLE)
 	conswitchp = &dummy_con;
 #endif
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/signal.c linux--vhype--2.6.11/arch/i386/kernel/signal.c
--- linux--2.6.11/arch/i386/kernel/signal.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/signal.c	2005-03-01 21:23:52.000000000 +0000
@@ -608,7 +608,11 @@ int fastcall do_signal(struct pt_regs *r
 		 * inside the kernel.
 		 */
 		if (unlikely(current->thread.debugreg[7])) {
+#ifdef CONFIG_X86_HYPERVISOR
+			hcall_set_dr(7, current->thread.debugreg[7]);
+#else
 			__asm__("movl %0,%%db7"	: : "r" (current->thread.debugreg[7]));
+#endif
 		}
 
 		/* Whee!  Actually deliver the signal.  */
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/time.c linux--vhype--2.6.11/arch/i386/kernel/time.c
--- linux--2.6.11/arch/i386/kernel/time.c	2005-03-01 16:22:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/time.c	2005-03-01 21:17:00.000000000 +0000
@@ -103,7 +103,12 @@ void do_gettimeofday(struct timeval *tv)
 
 		seq = read_seqbegin(&xtime_lock);
 
+#ifdef CONFIG_X86_HYPERVISOR
+		/* In HV, gettimeofday only has second resolution. */
+		usec = 0;
+#else
 		usec = cur_timer->get_offset();
+#endif
 		lost = jiffies - wall_jiffies;
 
 		/*
@@ -151,7 +156,9 @@ int do_settimeofday(struct timespec *tv)
 	 * wall time.  Discover what correction gettimeofday() would have
 	 * made, and then undo it!
 	 */
+#ifndef CONFIG_X86_HYPERVISOR
 	nsec -= cur_timer->get_offset() * NSEC_PER_USEC;
+#endif
 	nsec -= (jiffies - wall_jiffies) * TICK_NSEC;
 
 	wtm_sec  = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
@@ -171,6 +178,7 @@ int do_settimeofday(struct timespec *tv)
 
 EXPORT_SYMBOL(do_settimeofday);
 
+#ifndef CONFIG_X86_HYPERVISOR
 static int set_rtc_mmss(unsigned long nowtime)
 {
 	int retval;
@@ -188,6 +196,7 @@ static int set_rtc_mmss(unsigned long no
 
 /* last time the cmos clock got updated */
 static long last_rtc_update;
+#endif /* CONFIG_X86_HYPERVISOR */
 
 int timer_ack;
 
@@ -239,6 +248,7 @@ static inline void do_timer_interrupt(in
 
 	do_timer_interrupt_hook(regs);
 
+#ifndef CONFIG_X86_HYPERVISOR
 	/*
 	 * If we have an externally synchronized Linux clock, then update
 	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
@@ -275,6 +285,7 @@ static inline void do_timer_interrupt(in
 		irq = inb_p( 0x61 );	/* read the current state */
 		outb_p( irq|0x80, 0x61 );	/* reset the IRQ */
 	}
+#endif /* CONFIG_X86_HYPERVISOR */
 }
 
 /*
@@ -293,7 +304,9 @@ irqreturn_t timer_interrupt(int irq, voi
 	 */
 	write_seqlock(&xtime_lock);
 
+#ifndef CONFIG_X86_HYPERVISOR
 	cur_timer->mark_offset();
+#endif
  
 	do_timer_interrupt(irq, NULL, regs);
 
@@ -408,13 +421,31 @@ void __init time_init(void)
 		return;
 	}
 #endif
+#ifdef CONFIG_X86_HYPERVISOR
+	/*
+	 * Until we decide to provide start time via some other means
+	 * from HV, we should start with 0. Technically guest
+	 * partitions should not be able to succeed in doing
+	 * get_cmos_time since it uses privileged IO instrs.
+	 */
+	xtime.tv_sec = 0;
+#else
 	xtime.tv_sec = get_cmos_time();
+#endif
+
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
-	set_normalized_timespec(&wall_to_monotonic,
+ 	set_normalized_timespec(&wall_to_monotonic,
 		-xtime.tv_sec, -xtime.tv_nsec);
 
+
 	cur_timer = select_timer();
 	printk(KERN_INFO "Using %s for high-res timesource\n",cur_timer->name);
 
 	time_init_hook();
+
+#ifdef CONFIG_X86_HYPERVISOR
+	/* Initialize jiffies and wall_jiffies, our clock start here. */
+	jiffies_64 = oh_mbox.ticks;
+	wall_jiffies = jiffies;
+#endif
 }
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/timers/timer.c linux--vhype--2.6.11/arch/i386/kernel/timers/timer.c
--- linux--2.6.11/arch/i386/kernel/timers/timer.c	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/timers/timer.c	2005-03-01 21:12:17.000000000 +0000
@@ -22,7 +22,9 @@ static struct init_timer_opts* __initdat
 #ifdef CONFIG_X86_PM_TIMER
 	&timer_pmtmr_init,
 #endif
+#ifndef CONFIG_X86_HYPERVISOR
 	&timer_tsc_init,
+#endif
 	&timer_pit_init,
 	NULL,
 };
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/timers/timer_pit.c linux--vhype--2.6.11/arch/i386/kernel/timers/timer_pit.c
--- linux--2.6.11/arch/i386/kernel/timers/timer_pit.c	2005-03-01 16:16:15.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/timers/timer_pit.c	2005-03-01 21:12:17.000000000 +0000
@@ -166,6 +166,7 @@ struct init_timer_opts __initdata timer_
 
 void setup_pit_timer(void)
 {
+#ifndef CONFIG_X86_HYPERVISOR
 	extern spinlock_t i8253_lock;
 	unsigned long flags;
 
@@ -176,6 +177,7 @@ void setup_pit_timer(void)
 	udelay(10);
 	outb(LATCH >> 8 , PIT_CH0);	/* MSB */
 	spin_unlock_irqrestore(&i8253_lock, flags);
+#endif /* CONFIG_X86_HYPERVISOR */
 }
 
 static int timer_resume(struct sys_device *dev)
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/traps.c linux--vhype--2.6.11/arch/i386/kernel/traps.c
--- linux--2.6.11/arch/i386/kernel/traps.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/traps.c	2005-03-01 21:23:52.000000000 +0000
@@ -209,7 +209,7 @@ void show_registers(struct pt_regs *regs
 
 	esp = (unsigned long) (&regs->esp);
 	ss = __KERNEL_DS;
-	if (regs->xcs & 3) {
+	if ((regs->xcs & 3) == 3) {
 		in_kernel = 0;
 		esp = regs->esp;
 		ss = regs->xss & 0xffff;
@@ -265,7 +265,7 @@ static void handle_BUG(struct pt_regs *r
 	char c;
 	unsigned long eip;
 
-	if (regs->xcs & 3)
+	if ((regs->xcs & 3) == 3)
 		goto no_bug;		/* Not in kernel */
 
 	eip = regs->eip;
@@ -354,7 +354,7 @@ void die(const char * str, struct pt_reg
 
 static inline void die_if_kernel(const char * str, struct pt_regs * regs, long err)
 {
-	if (!(regs->eflags & VM_MASK) && !(3 & regs->xcs))
+	if (!(regs->eflags & VM_MASK) && !((3 & regs->xcs) == 3))
 		die(str, regs, err);
 }
 
@@ -367,7 +367,7 @@ static void do_trap(int trapnr, int sign
 		goto trap_signal;
 	}
 
-	if (!(regs->xcs & 3))
+	if (!((regs->xcs & 3) == 3))
 		goto kernel_trap;
 
 	trap_signal: {
@@ -488,7 +488,7 @@ fastcall void do_general_protection(stru
 	if (regs->eflags & VM_MASK)
 		goto gp_in_vm86;
 
-	if (!(regs->xcs & 3))
+	if ((regs->xcs & 3) != 3)
 		goto gp_in_kernel;
 
 	current->thread.error_code = error_code;
@@ -683,7 +683,12 @@ fastcall void do_debug(struct pt_regs * 
 	unsigned int condition;
 	struct task_struct *tsk = current;
 
+#ifdef CONFIG_X86_HYPERVISOR
+	if (hcall_get_dr(6, (unsigned long *)&condition) != H_Success)
+		BUG();
+#else
 	__asm__ __volatile__("movl %%db6,%0" : "=r" (condition));
+#endif
 
 	if (notify_die(DIE_DEBUG, "debug", regs, condition, error_code,
 					SIGTRAP) == NOTIFY_STOP)
@@ -716,7 +721,7 @@ fastcall void do_debug(struct pt_regs * 
 		 * check for kernel mode by just checking the CPL
 		 * of CS.
 		 */
-		if ((regs->xcs & 3) == 0)
+		if ((regs->xcs & 3) != 3)
 			goto clear_TF_reenable;
 
 		if (likely(tsk->ptrace & PT_DTRACE)) {
@@ -732,9 +737,13 @@ fastcall void do_debug(struct pt_regs * 
 	 * the signal is delivered.
 	 */
 clear_dr7:
+#ifdef CONFIG_X86_HYPERVISOR
+	hcall_set_dr(7, 0);
+#else
 	__asm__("movl %0,%%db7"
 		: /* no output */
 		: "r" (0));
+#endif
 	return;
 
 debug_vm86:
@@ -930,6 +939,7 @@ asmlinkage void math_emulate(long arg)
 #endif /* CONFIG_MATH_EMULATION */
 
 #ifdef CONFIG_X86_F00F_BUG
+#ifndef CONFIG_X86_HYPERVISOR
 void __init trap_init_f00f_bug(void)
 {
 	__set_fixmap(FIX_F00F_IDT, __pa(&idt_table), PAGE_KERNEL_RO);
@@ -942,6 +952,7 @@ void __init trap_init_f00f_bug(void)
 	__asm__ __volatile__("lidt %0" : : "m" (idt_descr));
 }
 #endif
+#endif
 
 #define _set_gate(gate_addr,type,dpl,addr,seg) \
 do { \
@@ -956,6 +967,15 @@ do { \
 	 "3" ((char *) (addr)),"2" ((seg) << 16)); \
 } while (0)
 
+static void _register_idt_entry(struct desc_struct *table, unsigned int n)
+{
+#ifdef CONFIG_X86_HYPERVISOR
+	if (hcall_dt_entry(NULL, H_DT_IDT, n, table[n].a, table[n].b) !=
+								H_Success)
+		BUG();
+#endif
+}
+
 
 /*
  * This needs to use 'idt_table' rather than 'idt', and
@@ -965,7 +985,8 @@ do { \
  */
 void set_intr_gate(unsigned int n, void *addr)
 {
-	_set_gate(idt_table+n,14,0,addr,__KERNEL_CS);
+	_set_gate(idt_table+n,14,__KERNEL_RPL,addr,__KERNEL_CS);
+	_register_idt_entry(idt_table,n);
 }
 
 /*
@@ -978,17 +999,20 @@ static inline void set_system_intr_gate(
 
 static void __init set_trap_gate(unsigned int n, void *addr)
 {
-	_set_gate(idt_table+n,15,0,addr,__KERNEL_CS);
+	_set_gate(idt_table+n,15,__KERNEL_RPL,addr,__KERNEL_CS);
+	_register_idt_entry(idt_table,n);
 }
 
 static void __init set_system_gate(unsigned int n, void *addr)
 {
 	_set_gate(idt_table+n,15,3,addr,__KERNEL_CS);
+	_register_idt_entry(idt_table,n);
 }
 
 static void __init set_task_gate(unsigned int n, unsigned int gdt_entry)
 {
-	_set_gate(idt_table+n,5,0,0,(gdt_entry<<3));
+	_set_gate(idt_table+n,5,__KERNEL_RPL,0,(gdt_entry<<3));
+	_register_idt_entry(idt_table,n);
 }
 
 
diff -urNpX diff.exclude linux--2.6.11/arch/i386/kernel/vio_arch.c linux--vhype--2.6.11/arch/i386/kernel/vio_arch.c
--- linux--2.6.11/arch/i386/kernel/vio_arch.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/kernel/vio_arch.c	2005-03-03 20:28:10.000000000 +0000
@@ -0,0 +1,334 @@
+#include <linux/config.h>
+#include <asm/vio.h>
+
+#define device_is_compatible(a, b) 	1
+static void probe_bus_x86(struct vio_dev *);
+
+#include "../../ppc64/kernel/vio.c"
+
+struct iommu_table *iommu_build_tce_table(struct vio_dev *vdev);
+
+/* all virtual device description go in here: */
+char vdev_descriptions[VDEV_DESCRIPTION_SIZE];
+
+/* cannot currently make this function inline due to gcc bug */
+struct vio_dev *
+to_vio_dev(struct device *dev)
+{
+	return container_of(dev, struct vio_dev, dev);
+}
+
+static unsigned char
+str2hexnum(unsigned char c)
+{
+	if (c >= '0' && c <= '9')
+		return c - '0';
+	if (c >= 'a' && c <= 'f')
+		return c - 'a' + 10;
+	if (c >= 'A' && c <= 'F')
+		return c - 'A' + 10;
+	return 0;
+}
+
+static char *
+str2eaddr(unsigned char *ea, char *s)
+{
+	int i;
+
+	for (i = 0; i < 6; i++) {
+		unsigned char num;
+
+		if ((*s == '.') || (*s == ':'))
+			s++;
+		num = str2hexnum(*s++) << 4;
+		num |= str2hexnum(*s++);
+		ea[i] = num;
+	}
+	return s;
+}
+
+struct vio_dev_parms {
+	char *name;
+	char *type;
+	unsigned int devtype;
+	unsigned int parm_mask;
+};
+
+#define VIO_PARM_UADDR    0x00000001UL
+#define VIO_PARM_LIOBN    0x00000002UL
+#define VIO_PARM_LIOBS    0x00000004UL
+#define VIO_PARM_XIRR     0x00000008UL
+#define VIO_PARM_MAC      0x00000010UL
+#define VIO_PARM_FILTER   0x00000020UL
+
+#define VIO_PARM_VETH (VIO_PARM_UADDR|VIO_PARM_LIOBN|VIO_PARM_LIOBS| \
+        VIO_PARM_XIRR | VIO_PARM_MAC | VIO_PARM_FILTER)
+#define VIO_PARM_CRQ  (VIO_PARM_UADDR|VIO_PARM_LIOBN|VIO_PARM_LIOBS| \
+	VIO_PARM_XIRR)
+#define VIO_PARM_VTY  (VIO_PARM_UADDR|VIO_PARM_LIOBN|VIO_PARM_LIOBS| \
+	VIO_PARM_XIRR)
+
+static const struct vio_dev_parms vdev_parms[] =
+{
+	{"ibmveth", "network", VIO_DEV_ETH, VIO_PARM_VETH},
+	{"ibmvty", "serial", VIO_DEV_VTY, VIO_PARM_VTY},
+	{"ibmvscsi", "vscsi", VIO_DEV_SCSI, VIO_PARM_CRQ},
+	{"ibmvscsis", "v-scsi-host", VIO_DEV_SCSIS, VIO_PARM_CRQ},
+	{"ibmvtpm", "vtpm", VIO_DEV_TPM, VIO_PARM_CRQ},
+	{"ibmvtpms", "v-tpm-host", VIO_DEV_TPMS, VIO_PARM_CRQ},
+	{NULL, NULL, -1, 0}
+};
+
+/*
+ * Just parse the string and create a vio_dev structure with the 
+ * information and collect it in the global array. Do not register
+ * them here since maybe this function could be called before
+ * the vio bus is initialized.
+ */
+/*
+ * On x86 we do not have a device tree in which we can pass on
+ * device specific attributes. For now we pass them along in the
+ * command line argument.
+ *
+ * The options currently defined are:
+ *
+ *	ibmveth=<uaddr>,<liobn>,<liobs>,<xirr>,<mac>,<filter size>
+ *      ibmvscsi=<uaddr>,<liobn>,<liobs>,<xirr>
+ *      ibmvscsis=<uaddr>,<liobn>,<liobs>,<xirr>
+ *      ibmvtpm=<uaddr>,<liobn>,<liobs>,<xirr>
+ *      ibmvtpms=<uaddr>,<liobn>,<liobs>,<xirr>
+ *      ibmvty=<uaddr>,<liobn>,<liobs>,<xirr>
+ *
+ * Multiple of these options may be present, each represents an adapter.
+ */
+static struct vio_dev *vio_devices_parse(char *s)
+{
+	struct vio_dev temp_vdev;
+	int i;
+
+	memset(&temp_vdev, 0x0, sizeof (temp_vdev));
+
+	for (i = 0; vdev_parms[i].name != NULL; i++) {
+		int len = strlen(vdev_parms[i].name);
+
+		if (strncmp(s, vdev_parms[i].name, len) == 0) {
+			struct vio_dev *vdev;
+			unsigned int mask = 0x1U;
+			unsigned int mask2 = 0xffffffffU;
+			char *p = s + len;
+
+			if (*p++ != '=') {
+				continue;
+			}
+#ifdef DEBUG
+			printk(KERN_INFO "Found a '%s'!\n",
+			       vdev_parms[i].name);
+#endif
+
+			temp_vdev.devtype = vdev_parms[i].devtype;
+			temp_vdev.type = vdev_parms[i].type;
+			temp_vdev.name = vdev_parms[i].type;
+
+			while (mask != 0) {
+				unsigned int parm =
+					mask & vdev_parms[i].parm_mask;
+				switch (parm) {
+				case VIO_PARM_UADDR:
+					temp_vdev.unit_address =
+						simple_strtol(p, &p, 0);
+					break;
+
+				case VIO_PARM_LIOBN:
+					temp_vdev.liobn =
+						simple_strtol(p, &p, 0);
+					break;
+
+				case VIO_PARM_LIOBS:
+					temp_vdev.liobs =
+						simple_strtol(p, &p, 0);
+					break;
+
+				case VIO_PARM_XIRR:
+					temp_vdev.xirr =
+						simple_strtol(p, &p, 0);
+
+					if (temp_vdev.xirr > 0 &&
+					    temp_vdev.xirr != 0xffffffffUL) {
+						temp_vdev.irq =
+							map_openhype_xirr
+							(temp_vdev.xirr);
+						if (temp_vdev.irq < 0)
+							return 0;
+					} else {
+						temp_vdev.irq = -1;
+					}
+					break;
+
+				case VIO_PARM_MAC:
+					p = str2eaddr(temp_vdev.mac, p);
+					break;
+
+				case VIO_PARM_FILTER:
+					temp_vdev.filters =
+						simple_strtol(p, &p, 0);
+					break;
+
+				default:
+					/* bit not set */
+					break;
+				}
+
+				mask <<= 1;
+				mask2 <<= 1;
+				/* anything left ? */
+				if ((mask2 & vdev_parms[i].parm_mask) == 0) {
+					break;
+				}
+				if (parm != 0) {
+					if (!p || *p++ != ',')
+						return 0;
+				}
+
+			}
+			vdev = (struct vio_dev *)
+				kmalloc(sizeof (struct vio_dev), GFP_KERNEL);
+			if (NULL != vdev) {
+				memcpy(vdev, &temp_vdev, sizeof (*vdev));
+				return vdev;
+			}
+			return NULL;
+		}
+	}
+
+	return NULL;
+}
+
+/*
+ * Pass a string of virtual device descriptions to this function
+ * and it will parse it and register the devices.
+ * This function can also be called a long time after startup to
+ * register additional devices. (how that affects drivers is unknown)
+ */
+static void vio_do_registration(char *descriptions)
+{
+	struct vio_dev *vdev;
+	int i = 0;
+
+	while (descriptions[i] != '\0') {
+		vdev = vio_devices_parse(&descriptions[i]);
+		if (vdev != NULL) {
+			struct iommu_table *iommu_table = NULL;
+
+			if (vdev->liobs != 0) {
+				iommu_table = iommu_build_tce_table(vdev);
+			}
+			/* Important to give it a unique bus ID!! */
+			snprintf(vdev->dev.bus_id, BUS_ID_SIZE, "%x",
+				 vdev->unit_address);
+			vio_register_device_common(vdev, vdev->name,
+						   vdev->type,
+						   vdev->unit_address,
+						   iommu_table);
+		}
+
+		while (descriptions[i] != ' ' && descriptions[i] != '\0') {
+			i++;
+		}
+		if (descriptions[i] == ' ') {
+			i++;
+		}
+	}
+}
+
+static ssize_t add_device(struct device *dev, const char *buf, size_t count)
+{
+	char *c = (char *)kmalloc(count + 1, GFP_KERNEL);
+
+	if (c) {
+		memcpy(c, buf, count);
+		c[count] = 0;
+		vio_do_registration(c);
+		kfree(c);
+	}
+	return count;
+}
+
+static DEVICE_ATTR(add_device, S_IWUGO, NULL, add_device);
+
+static void probe_bus_x86(struct vio_dev *vio_dev)
+{
+	/*
+	 * Not really probing anything. Just registering 
+	 * whatever was passed to me during startup before.
+	 * Allow command line arguments to override virtual
+	 * device environment that was created by controller.
+	 */
+	vio_do_registration(saved_command_line);
+	vio_do_registration(vdev_descriptions);
+
+	device_create_file(&vio_dev->dev, &dev_attr_add_device);
+}
+
+/**
+ * vio_get_attribute: - get attribute for virtual device
+ * @vdev:	The vio device to get property.
+ * @which:	The property/attribute to be extracted.
+ * @length:	Pointer to length of returned data size (unused if NULL).
+ *
+ * Calls prom.c's get_property() to return the value of the
+ * attribute specified by the preprocessor constant @which
+*/
+const void *vio_get_attribute(struct vio_dev *vdev, void *which, int *length)
+{
+	void *res = NULL;
+
+	if (0 == strcmp("ibm,my-dma-window", which)) {
+		*length = sizeof (vdev->dma_window);
+		vdev->dma_window[0] = vdev->liobn;
+		if (*length == 24) {
+			vdev->dma_window[3] = 0xffffffff;
+		} else if (*length == 40) {
+			vdev->dma_window[5] = 0xffffffff;
+		} else {
+			panic("Invalid size of vdev->dma_window!\n");
+		}
+		res = (void *)vdev->dma_window;
+	}
+
+	return res;
+}
+
+EXPORT_SYMBOL(vio_get_attribute);
+
+int vio_enable_interrupts(struct vio_dev *dev)
+{
+	int rc = h_vio_signal(dev->unit_address, VIO_IRQ_ENABLE);
+
+	if (rc != H_Success) {
+		printk(KERN_ERR "vio: Error 0x%x enabling interrupts\n", rc);
+	}
+	return rc;
+}
+
+EXPORT_SYMBOL(vio_enable_interrupts);
+
+int vio_disable_interrupts(struct vio_dev *dev)
+{
+	int rc = h_vio_signal(dev->unit_address, VIO_IRQ_DISABLE);
+
+	if (rc != H_Success) {
+		printk(KERN_ERR "vio: Error 0x%x disabling interrupts\n", rc);
+	}
+	return rc;
+}
+
+EXPORT_SYMBOL(vio_disable_interrupts);
+
+EXPORT_SYMBOL(to_vio_dev);
+EXPORT_SYMBOL(hcall_get_pte);
+EXPORT_SYMBOL(hcall_reg_crq);
+EXPORT_SYMBOL(hcall_free_crq);
+EXPORT_SYMBOL(hcall_send_crq);
+EXPORT_SYMBOL(hcall_copy_rdma);
+EXPORT_SYMBOL(hcall_yield);
+EXPORT_SYMBOL(hcall_vio_signal);
diff -urNpX diff.exclude linux--2.6.11/arch/i386/mm/fault.c linux--vhype--2.6.11/arch/i386/mm/fault.c
--- linux--2.6.11/arch/i386/mm/fault.c	2005-03-01 16:22:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/mm/fault.c	2005-03-01 21:17:00.000000000 +0000
@@ -77,7 +77,7 @@ static inline unsigned long get_segment_
 	u32 seg_ar, seg_limit, base, *desc;
 
 	/* The standard kernel/user address space limit. */
-	*eip_limit = (seg & 3) ? USER_DS.seg : KERNEL_DS.seg;
+	*eip_limit = ((seg & 3) == 3) ? USER_DS.seg : KERNEL_DS.seg;
 
 	/* Unlikely, but must come before segment checks. */
 	if (unlikely((regs->eflags & VM_MASK) != 0))
@@ -217,12 +217,19 @@ fastcall void do_page_fault(struct pt_re
 	struct mm_struct *mm;
 	struct vm_area_struct * vma;
 	unsigned long address;
+#ifndef CONFIG_X86_HYPERVISOR
 	unsigned long page;
+#endif
 	int write;
 	siginfo_t info;
 
+#ifdef CONFIG_X86_HYPERVISOR
+	if (hcall_get_pfault_addr((u32 *)&address) != H_Success)
+		BUG();
+#else
 	/* get the address */
 	__asm__("movl %%cr2,%0":"=r" (address));
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	if (notify_die(DIE_PAGE_FAULT, "page fault", regs, error_code, 14,
 					SIGSEGV) == NOTIFY_STOP)
@@ -446,6 +453,7 @@ no_context:
 	printk(" at virtual address %08lx\n",address);
 	printk(KERN_ALERT " printing eip:\n");
 	printk("%08lx\n", regs->eip);
+#ifndef CONFIG_X86_HYPERVISOR
 	asm("movl %%cr3,%0":"=r" (page));
 	page = ((unsigned long *) __va(page))[address >> 22];
 	printk(KERN_ALERT "*pde = %08lx\n", page);
@@ -463,6 +471,7 @@ no_context:
 		printk(KERN_ALERT "*pte = %08lx\n", page);
 	}
 #endif
+#endif /* CONFIG_X86_HYPERVISOR */
 	die("Oops", regs, error_code);
 	bust_spinlocks(0);
 	do_exit(SIGKILL);
@@ -520,7 +529,13 @@ vmalloc_fault:
 		pmd_t *pmd, *pmd_k;
 		pte_t *pte_k;
 
+#ifndef CONFIG_X86_HYPERVISOR
 		asm("movl %%cr3,%0":"=r" (pgd_paddr));
+#else
+		if (hcall_get_pte((u32*)&pgd_paddr,
+				  H_GET_ENTRY_ROOT, 0) != H_Success)
+			BUG();
+#endif
 		pgd = index + (pgd_t *)__va(pgd_paddr);
 		pgd_k = init_mm.pgd + index;
 
diff -urNpX diff.exclude linux--2.6.11/arch/i386/mm/init.c linux--vhype--2.6.11/arch/i386/mm/init.c
--- linux--2.6.11/arch/i386/mm/init.c	2005-03-01 16:16:16.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/mm/init.c	2005-03-01 21:12:18.000000000 +0000
@@ -39,13 +39,16 @@
 #include <asm/tlb.h>
 #include <asm/tlbflush.h>
 #include <asm/sections.h>
+#include <asm/mmu_context.h>
 
 unsigned int __VMALLOC_RESERVE = 128 << 20;
 
 DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
 unsigned long highstart_pfn, highend_pfn;
 
+#ifndef CONFIG_X86_HYPERVISOR
 static int noinline do_test_wp_bit(void);
+#endif
 
 /*
  * Creates a middle page table and puts a pointer to it in the
@@ -506,7 +509,11 @@ void __init paging_init(void)
 
 	pagetable_init();
 
+#ifndef CONFIG_X86_HYPERVISOR
 	load_cr3(swapper_pg_dir);
+#else
+	load_page_dir(H_PGD_ACTIVATE|H_PGD_PREFETCH, swapper_pg_dir);
+#endif
 
 #ifdef CONFIG_X86_PAE
 	/*
@@ -516,12 +523,15 @@ void __init paging_init(void)
 	if (cpu_has_pae)
 		set_in_cr4(X86_CR4_PAE);
 #endif
+#ifndef CONFIG_X86_HYPERVISOR
 	__flush_tlb_all();
+#endif
 
 	kmap_init();
 	zone_sizes_init();
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * Test if the WP bit works in supervisor mode. It isn't supported on 386's
  * and also on some strange 486's (NexGen etc.). All 586+'s are OK. This
@@ -547,6 +557,7 @@ void __init test_wp_bit(void)
 		printk("Ok.\n");
 	}
 }
+#endif
 
 #ifndef CONFIG_DISCONTIGMEM
 static void __init set_max_mapnr_init(void)
@@ -588,7 +599,7 @@ void __init mem_init(void)
 		BUG();
 	}
 #endif
- 
+
 	set_max_mapnr_init();
 
 #ifdef CONFIG_HIGHMEM
@@ -632,8 +643,11 @@ void __init mem_init(void)
 	if (!cpu_has_pae)
 		panic("cannot execute a PAE-enabled kernel on a PAE-less CPU!");
 #endif
+
+#ifndef CONFIG_X86_HYPERVISOR
 	if (boot_cpu_data.wp_works_ok < 0)
 		test_wp_bit();
+#endif /* CONFIG_X86_HYPERVISOR */
 
 	/*
 	 * Subtle. SMP is doing it's boot stuff late (because it has to
@@ -671,6 +685,7 @@ void __init pgtable_cache_init(void)
 		panic("pgtable_cache_init(): Cannot create pgd cache");
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 /*
  * This function cannot be __init, since exceptions don't work in that
  * section.  Put this after the callers, so that it cannot be inlined.
@@ -697,6 +712,7 @@ static int noinline do_test_wp_bit(void)
 	
 	return flag;
 }
+#endif
 
 void free_initmem(void)
 {
diff -urNpX diff.exclude linux--2.6.11/arch/i386/mm/ioremap.c linux--vhype--2.6.11/arch/i386/mm/ioremap.c
--- linux--2.6.11/arch/i386/mm/ioremap.c	2005-03-01 16:37:23.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/mm/ioremap.c	2005-03-01 21:23:52.000000000 +0000
@@ -16,6 +16,9 @@
 #include <asm/cacheflush.h>
 #include <asm/tlbflush.h>
 #include <asm/pgtable.h>
+#ifdef CONFIG_X86_HYPERVISOR
+#include <asm/openhype.h>
+#endif
 
 static inline void remap_area_pte(pte_t * pte, unsigned long address, unsigned long size,
 	unsigned long phys_addr, unsigned long flags)
@@ -102,6 +105,32 @@ static int remap_area_pages(unsigned lon
 	return error;
 }
 
+#ifdef CONFIG_X86_HYPERVISOR
+/*
+ * Hypervisor ISA remapping functions.
+ * Ordinarily the kernel uses large pages, but in order to access
+ * the ISA memory mapped I/O space we have to setup 4KB page mappings
+ * with explicit physical addresses.
+ */
+void __init setup_isamap(void)
+{
+	enum fixed_addresses idx = FIX_ISAMAP_BEGIN;
+	unsigned long phys_addr = 0xA0000;
+	int nrpages = NR_FIX_ISAMAP;
+
+	while (nrpages-- > 0) {
+		set_fixmap(idx, phys_addr);
+		phys_addr += PAGE_SIZE;
+		idx--;
+	}
+}
+
+static void *isa_phys_to_virt(unsigned long paddr)
+{
+	return (void *)(fix_to_virt(FIX_ISAMAP_BEGIN) + (paddr - 0xA0000));
+}
+#endif /* CONFIG_X86_HYPERVISOR */
+
 /*
  * Generic mapping function (not visible outside):
  */
@@ -129,8 +158,13 @@ void __iomem * __ioremap(unsigned long p
 	/*
 	 * Don't remap the low PCI/ISA area, it's always mapped..
 	 */
+#ifdef CONFIG_X86_HYPERVISOR
+	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
+		return (void __iomem *) isa_phys_to_virt(phys_addr);
+#else
 	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
 		return (void __iomem *) phys_to_virt(phys_addr);
+#endif
 
 	/*
 	 * Don't allow anybody to remap normal RAM that we're using..
@@ -261,8 +295,13 @@ void __init *bt_ioremap(unsigned long ph
 	/*
 	 * Don't remap the low PCI/ISA area, it's always mapped..
 	 */
+#ifdef CONFIG_X86_HYPERVISOR
+	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
+		return isa_phys_to_virt(phys_addr);
+#else
 	if (phys_addr >= 0xA0000 && last_addr < 0x100000)
 		return phys_to_virt(phys_addr);
+#endif
 
 	/*
 	 * Mappings have to be page-aligned
@@ -311,3 +350,4 @@ void __init bt_iounmap(void *addr, unsig
 		--nrpages;
 	}
 }
+
diff -urNpX diff.exclude linux--2.6.11/arch/i386/mm/pgtable.c linux--vhype--2.6.11/arch/i386/mm/pgtable.c
--- linux--2.6.11/arch/i386/mm/pgtable.c	2005-03-01 16:22:08.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/mm/pgtable.c	2005-03-01 21:17:00.000000000 +0000
@@ -229,6 +229,10 @@ pgd_t *pgd_alloc(struct mm_struct *mm)
 	int i;
 	pgd_t *pgd = kmem_cache_alloc(pgd_cache, GFP_KERNEL);
 
+#ifdef CONFIG_X86_HYPERVISOR
+	mm->context.prefetch = 1;
+#endif
+
 	if (PTRS_PER_PMD == 1 || !pgd)
 		return pgd;
 
diff -urNpX diff.exclude linux--2.6.11/arch/i386/power/cpu.c linux--vhype--2.6.11/arch/i386/power/cpu.c
--- linux--2.6.11/arch/i386/power/cpu.c	2005-03-01 16:16:16.000000000 +0000
+++ linux--vhype--2.6.11/arch/i386/power/cpu.c	2005-03-01 21:12:18.000000000 +0000
@@ -95,6 +95,10 @@ static void fix_processor_context(void)
 	 * Now maybe reload the debug registers
 	 */
 	if (current->thread.debugreg[7]){
+#ifdef CONFIG_X86_HYPERVISOR
+		if (hcall_set_drs(&current->thread.debugreg) != H_Success)
+			BUG();
+#else /* CONFIG_X86_HYPERVISOR */
                 loaddebug(&current->thread, 0);
                 loaddebug(&current->thread, 1);
                 loaddebug(&current->thread, 2);
@@ -102,6 +106,7 @@ static void fix_processor_context(void)
                 /* no 4 and 5 */
                 loaddebug(&current->thread, 6);
                 loaddebug(&current->thread, 7);
+#endif  /* CONFIG_X86_HYPERVISOR */
 	}
 
 }
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/Kconfig linux--vhype--2.6.11/arch/ppc64/Kconfig
--- linux--2.6.11/arch/ppc64/Kconfig	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/Kconfig	2005-03-01 21:23:59.000000000 +0000
@@ -107,6 +107,29 @@ config PPC_OF
 	bool
 	default y
 
+config OPENHYPE
+	depends on PPC_PSERIES
+	depends on EXPERIMENTAL
+	bool "Support OpenHype control interfaces"
+	default y
+	help
+	  Enabling this option enables the /dev/hcall device that can be used
+	  to access OpenHype management interfaces.
+
+# Mambo configuration
+config MAMBO
+	bool "Mambo simulator support"
+	---help---
+	  Adds device drivers to enable booting Linux under Mambo, a PowerPC simulator.
+
+if MAMBO
+config MAMBO_DISK
+	tristate "Mambo disk"
+config MAMBO_NET
+	tristate "Mambo network"
+endif
+
+
 # VMX is pSeries only for now until somebody writes the iSeries
 # exception vectors for it
 config ALTIVEC
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/boot/Makefile linux--vhype--2.6.11/arch/ppc64/boot/Makefile
--- linux--2.6.11/arch/ppc64/boot/Makefile	2005-03-01 16:16:26.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/boot/Makefile	2005-03-01 21:12:27.000000000 +0000
@@ -29,7 +29,7 @@ BOOTCFLAGS	:= $(HOSTCFLAGS) $(LINUXINCLU
 BOOTAS		:= $(CROSS32_COMPILE)as
 BOOTAFLAGS	:= -D__ASSEMBLY__ $(BOOTCFLAGS) -traditional
 BOOTLD		:= $(CROSS32_COMPILE)ld
-BOOTLFLAGS	:= -Ttext 0x00400000 -e _start -T $(srctree)/$(src)/zImage.lds
+BOOTLFLAGS	:= -Ttext 0x00400000 -e _start -T $(if $(KBUILD_SRC), $(srctree)/)$(src)/zImage.lds
 BOOTOBJCOPY	:= $(CROSS32_COMPILE)objcopy
 OBJCOPYFLAGS    := contents,alloc,load,readonly,data
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/Makefile linux--vhype--2.6.11/arch/ppc64/kernel/Makefile
--- linux--2.6.11/arch/ppc64/kernel/Makefile	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/Makefile	2005-03-01 21:23:59.000000000 +0000
@@ -20,6 +20,8 @@ pci-obj-$(CONFIG_PPC_MULTIPLATFORM)	+= p
 
 obj-$(CONFIG_PCI)	+= pci.o pci_iommu.o iomap.o $(pci-obj-y)
 
+obj-$(CONFIG_OPENHYPE) += openhype.o openhype_ic.o
+
 obj-$(CONFIG_PPC_ISERIES) += iSeries_irq.o \
 			     iSeries_VpdInfo.o XmPciLpEvent.o \
 			     HvCall.o HvLpConfig.o LparData.o \
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/cpu_setup_power4.S linux--vhype--2.6.11/arch/ppc64/kernel/cpu_setup_power4.S
--- linux--2.6.11/arch/ppc64/kernel/cpu_setup_power4.S	2005-03-01 16:16:26.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/cpu_setup_power4.S	2005-03-01 21:12:28.000000000 +0000
@@ -25,7 +25,7 @@ _GLOBAL(__970_cpu_preinit)
 	mfmsr	r0
 	rldicl.	r0,r0,4,63
 	beqlr
-
+	
 	/*
 	 * Deal only with PPC970 and PPC970FX.
 	 */
@@ -75,6 +75,13 @@ _GLOBAL(__setup_cpu_power4)
 	blr
 	
 _GLOBAL(__setup_cpu_ppc970)
+	/*
+	 * Do nothing if not running in HV mode
+	 */
+	mfmsr	r0
+	rldicl.	r0,r0,4,63
+	beqlr
+
 	mfspr	r0,SPRN_HID0
 	li	r11,5			/* clear DOZE and SLEEP */
 	rldimi	r0,r11,52,8		/* set NAP and DPM */
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/head.S linux--vhype--2.6.11/arch/ppc64/kernel/head.S
--- linux--2.6.11/arch/ppc64/kernel/head.S	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/head.S	2005-03-01 21:23:59.000000000 +0000
@@ -1774,8 +1774,10 @@ _GLOBAL(__secondary_start)
 	/* set the ASR */
 	li	r3,SYSTEMCFG_PHYS_ADDR	/* r3 = ptr to systemcfg	 */
 	lwz	r3,PLATFORM(r3)		/* r3 = platform flags		 */
-	cmpldi 	r3,PLATFORM_PSERIES_LPAR
+	/* Test if bit 0 is set (LPAR bit) */
+	andi.	r3,r3,PLATFORM_LPAR
 	bne	98f
+96:	
 	mfspr	r3,PVR
 	srwi	r3,r3,16
 	cmpwi	r3,0x37			/* SStar  */
@@ -1943,8 +1945,10 @@ _STATIC(start_here_multiplatform)
 	ori	r4,r3,1			/* turn on valid bit		 */
 	li	r3,SYSTEMCFG_PHYS_ADDR	/* r3 = ptr to systemcfg */
 	lwz	r3,PLATFORM(r3)		/* r3 = platform flags */
-	cmpldi 	r3,PLATFORM_PSERIES_LPAR
+	/* Test if bit 0 is set (LPAR bit) */
+	andi. 	r3,r3,PLATFORM_LPAR   /* check for lpar */
 	bne	98f
+96:	
 	mfspr	r3,PVR
 	srwi	r3,r3,16
 	cmpwi	r3,0x37			/* SStar */
@@ -1963,7 +1967,7 @@ _STATIC(start_here_multiplatform)
 	li	r3,SYSTEMCFG_PHYS_ADDR	/* r3 = ptr to systemcfg */
 	lwz	r3,PLATFORM(r3)		/* r3 = platform flags */
 	/* Test if bit 0 is set (LPAR bit) */
-	andi.	r3,r3,0x1
+	andi.	r3,r3,PLATFORM_LPAR
 	bne	98f
 	LOADADDR(r6,_SDR1)		/* Only if NOT LPAR */
 	sub	r6,r6,r26
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/hvconsole.c linux--vhype--2.6.11/arch/ppc64/kernel/hvconsole.c
--- linux--2.6.11/arch/ppc64/kernel/hvconsole.c	2005-03-01 16:16:26.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/hvconsole.c	2005-03-01 21:12:28.000000000 +0000
@@ -43,6 +43,7 @@ int hvc_get_chars(uint32_t vtermno, char
 
 	if (plpar_hcall(H_GET_TERM_CHAR, vtermno, 0, 0, 0, &got,
 		(unsigned long *)buf, (unsigned long *)buf+1) == H_Success) {
+#if 0
 		/*
 		 * Work around a HV bug where it gives us a null
 		 * after every \r.  -- paulus
@@ -58,6 +59,7 @@ int hvc_get_chars(uint32_t vtermno, char
 				}
 			}
 		}
+#endif
 		return got;
 	}
 	return 0;
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/iSeries_setup.c linux--vhype--2.6.11/arch/ppc64/kernel/iSeries_setup.c
--- linux--2.6.11/arch/ppc64/kernel/iSeries_setup.c	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/iSeries_setup.c	2005-03-01 21:12:28.000000000 +0000
@@ -828,7 +828,8 @@ static void __init iSeries_fixup_klimit(
 int __init iSeries_src_init(void)
 {
         /* clear the progress line */
-        ppc_md.progress(" ", 0xffff);
+        if (ppc_md.progress)
+		ppc_md.progress(" ", 0xffff);
         return 0;
 }
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/iommu.c linux--vhype--2.6.11/arch/ppc64/kernel/iommu.c
--- linux--2.6.11/arch/ppc64/kernel/iommu.c	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/iommu.c	2005-03-01 21:12:28.000000000 +0000
@@ -35,9 +35,13 @@
 #include <linux/init.h>
 #include <linux/bitops.h>
 #include <asm/io.h>
+#ifndef CONFIG_X86_HYPERVISOR
 #include <asm/prom.h>
+#endif
 #include <asm/iommu.h>
+#ifndef CONFIG_X86_HYPERVISOR
 #include <asm/pci-bridge.h>
+#endif
 #include <asm/machdep.h>
 
 #define DBG(...)
@@ -68,10 +72,11 @@ static unsigned long iommu_range_alloc(s
 	unsigned long limit;
 	int largealloc = npages > 15;
 	int pass = 0;
+#ifndef CONFIG_X86_HYPERVISOR
 	unsigned long align_mask;
 
 	align_mask = 0xffffffffffffffffl >> (64 - align_order);
-
+#endif
 	/* This allocator was derived from x86_64's bit string search */
 
 	/* Sanity check */
@@ -102,10 +107,10 @@ static unsigned long iommu_range_alloc(s
  again:
 
 	n = find_next_zero_bit(tbl->it_map, limit, start);
-
+#ifndef CONFIG_X86_HYPERVISOR
 	/* Align allocation */
 	n = (n + align_mask) & ~align_mask;
-
+#endif
 	end = n + npages;
 
 	if (unlikely(end >= limit)) {
@@ -239,6 +244,9 @@ int iommu_map_sg(struct device *dev, str
 		struct scatterlist *sglist, int nelems,
 		enum dma_data_direction direction)
 {
+#ifdef CONFIG_X86_HYPERVISOR
+	panic("iommu_map_sg not implemented due to missing dma_length in scatterlist\n");
+#else
 	dma_addr_t dma_next = 0, dma_addr;
 	unsigned long flags;
 	struct scatterlist *s, *outs, *segstart;
@@ -361,12 +369,16 @@ int iommu_map_sg(struct device *dev, str
 	}
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
 	return 0;
+#endif
 }
 
 
 void iommu_unmap_sg(struct iommu_table *tbl, struct scatterlist *sglist,
 		int nelems, enum dma_data_direction direction)
 {
+#ifdef CONFIG_X86_HYPERVISOR
+	panic("iommu_unmap_sg not implemented due to missing dma_length in scatterlist\n");
+#else
 	unsigned long flags;
 
 	BUG_ON(direction == DMA_NONE);
@@ -396,6 +408,7 @@ void iommu_unmap_sg(struct iommu_table *
 		ppc_md.tce_flush(tbl);
 
 	spin_unlock_irqrestore(&(tbl->it_lock), flags);
+#endif
 }
 
 /*
@@ -432,6 +445,7 @@ struct iommu_table *iommu_init_table(str
 	return tbl;
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 void iommu_free_table(struct device_node *dn)
 {
 	struct iommu_table *tbl = dn->iommu_table;
@@ -464,6 +478,7 @@ void iommu_free_table(struct device_node
 	/* free table */
 	kfree(tbl);
 }
+#endif
 
 /* Creates TCEs for a user provided buffer.  The user buffer must be
  * contiguous real kernel storage (not vmalloc).  The address of the buffer
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/irq.c linux--vhype--2.6.11/arch/ppc64/kernel/irq.c
--- linux--2.6.11/arch/ppc64/kernel/irq.c	2005-03-01 16:22:10.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/irq.c	2005-03-01 21:17:16.000000000 +0000
@@ -56,10 +56,13 @@
 #include <asm/machdep.h>
 #include <asm/paca.h>
 
+#include "mpic.h"
+
 #ifdef CONFIG_SMP
 extern void iSeries_smp_message_recv( struct pt_regs * );
 #endif
 
+extern void oh_use_virq(unsigned long virq);
 extern irq_desc_t irq_desc[NR_IRQS];
 
 int distribute_irqs = 1;
@@ -331,7 +334,6 @@ void __init init_IRQ(void)
  * Virtual IRQ mapping code, used on systems with XICS interrupt controllers.
  */
 
-#define UNDEFINED_IRQ 0xffffffff
 unsigned int virt_irq_to_real_map[NR_IRQS];
 
 /*
@@ -351,7 +353,7 @@ virt_irq_init(void)
 {
 	int i;
 	for (i = 0; i < NR_IRQS; i++)
-		virt_irq_to_real_map[i] = UNDEFINED_IRQ;
+		virt_irq_to_real_map[i] = NO_IRQ;
 }
 
 /* Create a mapping for a real_irq if it doesn't already exist.
@@ -362,7 +364,8 @@ int virt_irq_create_mapping(unsigned int
 	unsigned int virq, first_virq;
 	static int warned;
 
-	if (ppc64_interrupt_controller == IC_OPEN_PIC)
+	if (ppc64_interrupt_controller == IC_OPEN_PIC &&
+	    !(systemcfg->platform & PLATFORM_LPAR))
 		return real_irq;	/* no mapping for openpic (for now) */
 
 	/* don't map interrupts < MIN_VIRT_IRQ */
@@ -378,7 +381,7 @@ int virt_irq_create_mapping(unsigned int
 
 	/* search for this number or a free slot */
 	first_virq = virq;
-	while (virt_irq_to_real_map[virq] != UNDEFINED_IRQ) {
+	while (virt_irq_to_real_map[virq] != NO_IRQ) {
 		if (virt_irq_to_real_map[virq] == real_irq)
 			return virq;
 		if (++virq > MAX_VIRT_IRQ)
@@ -388,6 +391,16 @@ int virt_irq_create_mapping(unsigned int
 	}
 
 	virt_irq_to_real_map[virq] = real_irq;
+
+#ifdef CONFIG_OPENHYPE
+	if (ppc64_interrupt_controller == IC_OPEN_PIC &&
+	    (systemcfg->platform & PLATFORM_LPAR)) {
+		if(real_irq > MPIC_MAX_IRQ_SOURCES) {
+			oh_use_virq(virq);
+		}
+	}
+#endif
+
 	return virq;
 
  nospace:
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/maple_setup.c linux--vhype--2.6.11/arch/ppc64/kernel/maple_setup.c
--- linux--2.6.11/arch/ppc64/kernel/maple_setup.c	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/maple_setup.c	2005-03-01 21:12:28.000000000 +0000
@@ -43,6 +43,7 @@
 #include <linux/root_dev.h>
 #include <linux/serial.h>
 #include <linux/smp.h>
+#include <linux/openhype.h>
 
 #include <asm/processor.h>
 #include <asm/sections.h>
@@ -59,6 +60,7 @@
 #include <asm/time.h>
 #include <asm/of_device.h>
 #include <asm/lmb.h>
+#include <asm/hvcall.h>
 
 #include "mpic.h"
 
@@ -132,30 +134,36 @@ static void __init maple_init_early(void
 	/* Initialize hash table, from now on, we can take hash faults
 	 * and call ioremap
 	 */
-	hpte_init_native();
+	if(systemcfg->platform & PLATFORM_LPAR){
+		hpte_init_lpar();	
+		iommu_init_early_pSeries();
+	} else {
+		hpte_init_native();
+		
+		/* Find the serial port */
+		generic_find_legacy_serial_ports(&physport, &default_speed);
+		
+		DBG("phys port addr: %lx\n", (long)physport);
+		
+		if (physport) {
+			void *comport;
+			/* Map the uart for udbg. */
+			comport = (void *)__ioremap(physport, 16,
+						    _PAGE_NO_CACHE);
+			udbg_init_uart(comport, default_speed);
+			
+			ppc_md.udbg_putc = udbg_putc;
+			ppc_md.udbg_getc = udbg_getc;
+			ppc_md.udbg_getc_poll = udbg_getc_poll;
+			DBG("Hello World !\n");
+		}
 
-	/* Find the serial port */
-	generic_find_legacy_serial_ports(&physport, &default_speed);
-
-	DBG("phys port addr: %lx\n", (long)physport);
-
-	if (physport) {
-		void *comport;
-		/* Map the uart for udbg. */
-		comport = (void *)__ioremap(physport, 16, _PAGE_NO_CACHE);
-		udbg_init_uart(comport, default_speed);
-
-		ppc_md.udbg_putc = udbg_putc;
-		ppc_md.udbg_getc = udbg_getc;
-		ppc_md.udbg_getc_poll = udbg_getc_poll;
-		DBG("Hello World !\n");
+		iommu_init_early_u3();
 	}
 
 	/* Setup interrupt mapping options */
 	ppc64_interrupt_controller = IC_OPEN_PIC;
 
-	iommu_init_early_u3();
-
 	DBG(" <- maple_init_early\n");
 }
 
@@ -203,12 +211,14 @@ static void __init maple_progress(char *
 }
 
 
+extern struct machdep_calls __initdata maple_md;
+
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */
 static int __init maple_probe(int platform)
 {
-	if (platform != PLATFORM_MAPLE)
+	if (platform != PLATFORM_MAPLE && platform != PLATFORM_MAPLE_LPAR)
 		return 0;
 	/*
 	 * On U3, the DART (iommu) must be allocated now since it
@@ -217,7 +227,10 @@ static int __init maple_probe(int platfo
 	 * part of the cacheable linar mapping
 	 */
 	alloc_u3_dart_table();
-
+	
+	if(platform & PLATFORM_LPAR) {
+		maple_md.get_irq = ohic_get_irq;
+	}
 	return 1;
 }
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/mpic.c linux--vhype--2.6.11/arch/ppc64/kernel/mpic.c
--- linux--2.6.11/arch/ppc64/kernel/mpic.c	2005-03-01 16:22:10.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/mpic.c	2005-03-01 21:17:16.000000000 +0000
@@ -507,7 +507,7 @@ struct mpic * __init mpic_alloc(unsigned
 
 	/* Map the global registers */
 	mpic->gregs = ioremap(phys_addr + MPIC_GREG_BASE, 0x1000);
-	mpic->tmregs = mpic->gregs + (MPIC_TIMER_BASE >> 2);
+	mpic->tmregs = mpic->gregs + ((MPIC_TIMER_BASE - MPIC_GREG_BASE) >> 2);
 	BUG_ON(mpic->gregs == NULL);
 
 	/* Reset */
@@ -644,6 +644,7 @@ void __init mpic_init(struct mpic *mpic)
 			continue;
 		irq_desc[mpic->ipi_offset+i].status |= IRQ_PER_CPU;
 		irq_desc[mpic->ipi_offset+i].handler = &mpic->hc_ipi;
+		virt_irq_to_real_map[mpic->ipi_offset+i] = mpic->ipi_offset+i;
 		
 #endif /* CONFIG_SMP */
 	}
@@ -706,6 +707,8 @@ void __init mpic_init(struct mpic *mpic)
 		if (i < mpic->irq_count) {
 			irq_desc[mpic->irq_offset+i].status = level ? IRQ_LEVEL : 0;
 			irq_desc[mpic->irq_offset+i].handler = &mpic->hc_irq;
+			virt_irq_to_real_map[mpic->irq_offset + i] = 
+				mpic->irq_offset + i;
 		}
 	}
 	
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/openhype.c linux--vhype--2.6.11/arch/ppc64/kernel/openhype.c
--- linux--2.6.11/arch/ppc64/kernel/openhype.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/openhype.c	2005-03-01 21:12:28.000000000 +0000
@@ -0,0 +1,22 @@
+/* OpenHype support code
+ *
+ * Copyright (C) 2004, Michal Ostrowski IBM Corporation.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/openhype.h>
+#include <asm/hvcall.h>
+
+oh_partition_info_t oh_partition_info[2] = {{
+	.sfw_tlb = 1,
+	.large_page_size1 = 64 << 10, /* 64KB */
+	.large_page_size2 = 16 << 20, /* 16MB */
+},};
+
+int oh_generic_hcall(oh_hcall_args *args)
+{
+	args->retval = plpar_hcall_generic(args->opcode, 
+					   args->args, args->args);
+	return 0;
+}
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/openhype_ic.c linux--vhype--2.6.11/arch/ppc64/kernel/openhype_ic.c
--- linux--2.6.11/arch/ppc64/kernel/openhype_ic.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/openhype_ic.c	2005-03-01 21:12:28.000000000 +0000
@@ -0,0 +1,207 @@
+/* 
+ * arch/ppc64/kernel/xics.c
+ *
+ * Copyright 2000 IBM Corporation.
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ */
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/threads.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
+#include <linux/smp.h>
+#include <linux/interrupt.h>
+#include <linux/signal.h>
+#include <linux/init.h>
+#include <linux/gfp.h>
+#include <linux/radix-tree.h>
+#include <asm/prom.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/smp.h>
+#include <asm/naca.h>
+#include <asm/rtas.h>
+#include <asm/xics.h>
+#include <asm/ppcdebug.h>
+#include <asm/hvcall.h>
+#include <asm/machdep.h>
+#include <asm/plpar_wrappers.h>
+
+static void ohic_enable_irq(unsigned int irq);
+static void ohic_disable_irq(unsigned int irq);
+static void ohic_shutdown_irq(unsigned int irq);
+static void ohic_end_irq(unsigned int irq);
+
+struct hw_interrupt_type ohic = {
+	.typename = "OpenHype",
+	.enable = ohic_enable_irq,
+	.disable = ohic_disable_irq,
+	.shutdown = ohic_shutdown_irq,
+	.end = ohic_end_irq,
+};
+
+static int call_xirr(void)
+{
+	unsigned long lpar_rc;
+	unsigned long return_value; 
+
+	lpar_rc = plpar_xirr(&return_value);
+	if (lpar_rc != H_Success)
+		panic(" bad return code xirr - rc = %lx \n", lpar_rc); 
+	return (int)return_value;
+}
+
+static void call_eoi(int value)
+{
+	unsigned long lpar_rc;
+	unsigned long val64 = value & 0xffffffff;
+
+	lpar_rc = plpar_eoi(val64);
+	if (lpar_rc != H_Success)
+		panic("bad return code EOI - rc = %ld, value=%lx\n", lpar_rc,
+		      val64); 
+}
+
+static void call_vio_signal(unsigned long irq, int value)
+{
+	unsigned long lpar_rc;
+	unsigned long val64 = value & 0xffffffff;
+
+	lpar_rc = plpar_hcall_norets(H_VIO_SIGNAL, irq, val64);
+	if (lpar_rc != H_Success)
+		panic("bad return code VIO_SIGNAL - rc = %ld, value=%lx\n", 
+		      lpar_rc, val64); 
+}
+
+#if 0
+static void call_cppr(u8 value)
+{
+	unsigned long lpar_rc;
+
+	lpar_rc = plpar_cppr(value);
+	if (lpar_rc != H_Success)
+		panic("bad return code cppr - rc = %lx\n", lpar_rc); 
+}
+
+static void call_ipi(int n_cpu , u8 value)
+{
+	unsigned long lpar_rc;
+
+	lpar_rc = plpar_ipi(get_hard_smp_processor_id(n_cpu), value);
+	if (lpar_rc != H_Success)
+		panic("bad return code qirr - rc = %lx\n", lpar_rc); 
+}
+#endif
+
+/* This is used to map real irq numbers to virtual */
+static struct radix_tree_root irq_map = RADIX_TREE_INIT(GFP_KERNEL);
+
+static unsigned int real_irq_to_virt(unsigned int real_irq)
+{
+	unsigned int *ptr;
+
+	ptr = radix_tree_lookup(&irq_map, real_irq);
+	if (ptr == NULL)
+		return NO_IRQ;
+	return ptr - virt_irq_to_real_map;
+}
+
+static void ohic_enable_irq(unsigned int virq)
+{
+	call_vio_signal(virt_irq_to_real(virq), 1);
+}
+
+static void ohic_disable_irq(unsigned int virq)
+{
+	call_vio_signal(virt_irq_to_real(virq), 0);
+}
+
+static void ohic_end_irq(unsigned int	irq)
+{
+	call_eoi(virt_irq_to_real(irq));
+}
+
+static spinlock_t oh_irq_lock = SPIN_LOCK_UNLOCKED;
+
+
+extern unsigned int real_irq_to_virt_slowpath(unsigned int real_irq);
+
+int ohic_get_irq(struct pt_regs *regs)
+{
+	unsigned int vec;
+	int irq;
+
+	vec = call_xirr();
+	/*  (vec >> 24) == old priority */
+	vec &= 0x00ffffff;
+	if(vec == 0) {
+		return -1;
+	}
+
+	if((vec & 0x00f00000) == 0){
+		return vec;
+	}
+
+	irq = real_irq_to_virt(vec);
+	if (irq == NO_IRQ)
+		irq = real_irq_to_virt_slowpath(vec);
+	if (irq == NO_IRQ) {
+		printk(KERN_ERR "Interrupt 0x%x (real) is invalid\n", vec);
+	}
+	return irq;
+}
+
+void oh_use_virq(unsigned long irq) 
+{
+	irq_desc[irq].handler = &ohic;
+}
+
+int map_openhype_xirr(unsigned int xirr)
+{
+	unsigned long flags;
+	int x;
+	
+	/* Only virt irq sources should be coming through here */
+	if ((xirr & (0xf<<20)) == 0) {
+		return NO_IRQ;
+	}
+	spin_lock_irqsave(&oh_irq_lock, flags);
+	
+	x = virt_irq_create_mapping(xirr); /* Will call oh_use_virq... */
+	BUG_ON(irq_desc[x].handler != &ohic); /* but be paranoid and check */
+
+	if (radix_tree_insert(&irq_map, virt_irq_to_real(x),
+			      &virt_irq_to_real_map[x]) == -ENOMEM)
+		printk(KERN_CRIT "Out of memory creating real -> virtual"
+		       " IRQ mapping for irq %u (real 0x%x)\n",
+		       xirr, virt_irq_to_real(xirr));
+
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+	return x;
+}
+
+
+int unmap_openhype_xirr(unsigned int irq)
+{
+	unsigned long flags;
+	int ret = -1;
+
+	spin_lock_irqsave(&oh_irq_lock, flags);
+	if(irq != NO_IRQ) {
+		virt_irq_to_real_map[irq] = NO_IRQ;
+		radix_tree_delete(&irq_map, irq);
+		ret = 0;
+	}
+	spin_unlock_irqrestore(&oh_irq_lock, flags);
+	return ret;
+}
+
+static void ohic_shutdown_irq(unsigned int virq)
+{
+	call_vio_signal(virt_irq_to_real(virq), 0);
+	unmap_openhype_xirr(virq);
+}
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/pSeries_hvCall.S linux--vhype--2.6.11/arch/ppc64/kernel/pSeries_hvCall.S
--- linux--2.6.11/arch/ppc64/kernel/pSeries_hvCall.S	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/pSeries_hvCall.S	2005-03-01 21:12:28.000000000 +0000
@@ -141,3 +141,46 @@ _GLOBAL(plpar_hcall_4out)
 	ld	r0,-8(r1)
 	mtcrf	0xff,r0
 	blr                     /* return r3 = status */
+
+
+/* long plpar_hcall_generic(unsigned long opcode,	R3
+			    unsigned long in_args[8],	R4
+			    unsigned long out_args[8])	R5
+*/
+_GLOBAL(plpar_hcall_generic)
+	mfcr	r0
+	std	r0,-8(r1)
+	stdu	r1,-48(r1)
+
+	std	r4,16(r1)
+	std	r5,8(r1)
+
+	mr	r12, r4
+	ld	r4, 0(r12)
+	ld	r5, 8(r12)
+	ld	r6, 16(r12)
+	ld	r7, 24(r12)
+	ld	r8, 32(r12)
+	ld	r9, 40(r12)
+	ld	r10, 48(r12)
+	ld	r11, 56(r12)
+
+	HVSC
+
+	ld	r12, 8(r1)
+	cmpi	0, r12, 0
+	beq	1f
+
+	std	r4, 0(r12)
+	std	r5, 8(r12)
+	std	r6, 16(r12)
+	std	r7, 24(r12)
+	std	r8, 32(r12)
+	std	r9, 40(r12)
+	std	r10, 48(r12)
+	std	r11, 56(r12)
+1:
+	ld	r1,0(r1) 
+	ld	r0,-8(r1)
+	mtcrf	0xff,r0
+	blr                     /* return r3 = status */
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/pSeries_setup.c linux--vhype--2.6.11/arch/ppc64/kernel/pSeries_setup.c
--- linux--2.6.11/arch/ppc64/kernel/pSeries_setup.c	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/pSeries_setup.c	2005-03-01 21:23:59.000000000 +0000
@@ -17,6 +17,7 @@
  */
 
 #undef DEBUG
+#define DEBUG
 
 #include <linux/config.h>
 #include <linux/errno.h>
@@ -240,8 +241,10 @@ static void __init pSeries_setup_arch(vo
 static int __init pSeries_init_panel(void)
 {
 	/* Manually leave the kernel version on the panel. */
-	ppc_md.progress("Linux ppc64\n", 0);
-	ppc_md.progress(UTS_RELEASE, 0);
+	if (ppc_md.progress) {
+		ppc_md.progress("Linux ppc64\n", 0);
+		ppc_md.progress(UTS_RELEASE, 0);
+	}
 
 	return 0;
 }
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/prom.c linux--vhype--2.6.11/arch/ppc64/kernel/prom.c
--- linux--2.6.11/arch/ppc64/kernel/prom.c	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/prom.c	2005-03-01 21:23:59.000000000 +0000
@@ -844,7 +844,7 @@ static int __init early_init_dt_scan_cpu
 
 	/* On LPAR, look for the first ibm,pft-size property for the  hash table size
 	 */
-	if (systemcfg->platform == PLATFORM_PSERIES_LPAR && ppc64_pft_size == 0) {
+	if (systemcfg->platform & PLATFORM_LPAR && ppc64_pft_size == 0) {
 		u32 *pft_size;
 		pft_size = (u32 *)get_flat_dt_prop(node, "ibm,pft-size", NULL);
 		if (pft_size != NULL) {
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/prom_init.c linux--vhype--2.6.11/arch/ppc64/kernel/prom_init.c
--- linux--2.6.11/arch/ppc64/kernel/prom_init.c	2005-03-01 17:18:09.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/prom_init.c	2005-03-02 15:47:46.000000000 +0000
@@ -668,7 +668,7 @@ static void __init prom_init_mem(void)
 	/* Setup our top/bottom alloc points, that is top of RMO or top of
 	 * segment 0 when running non-LPAR
 	 */
-	if ( RELOC(of_platform) == PLATFORM_PSERIES_LPAR )
+	if ( RELOC(of_platform) & PLATFORM_LPAR )
 		RELOC(alloc_top) = RELOC(rmo_top);
 	else
 		RELOC(alloc_top) = RELOC(rmo_top) = min(0x40000000ul, RELOC(ram_top));
@@ -1124,9 +1124,22 @@ static int __init prom_find_machine_type
 	char compat[256];
 	int len, i = 0;
 	phandle rtas;
+	int lpar = 0;
+
+	/* We need to know if we are running LPAR */
+	rtas = call_prom("finddevice", 1, 1, ADDR("/rtas"));
+	if (rtas != (phandle) -1) {
+		unsigned long x;
+		x = prom_getproplen(rtas, "ibm,hypertas-functions");
+		if (x != PROM_ERROR) {
+			prom_printf("Hypertas detected, assuming LPAR !\n");
+			lpar = 1;
+		}
+	}
 
 	len = prom_getprop(_prom->root, "compatible",
 			   compat, sizeof(compat)-1);
+
 	if (len > 0) {
 		compat[len] = 0;
 		while (i < len) {
@@ -1135,23 +1148,20 @@ static int __init prom_find_machine_type
 			if (sl == 0)
 				break;
 			if (strstr(p, RELOC("Power Macintosh")) ||
-			    strstr(p, RELOC("MacRISC4")))
+			    strstr(p, RELOC("MacRISC4"))) {
 				return PLATFORM_POWERMAC;
-			if (strstr(p, RELOC("Momentum,Maple")))
+			}
+			if (strstr(p, RELOC("Momentum,Maple"))) {
+				if(lpar) return PLATFORM_MAPLE_LPAR;
 				return PLATFORM_MAPLE;
+			}
 			i += sl + 1;
 		}
 	}
-	/* Default to pSeries. We need to know if we are running LPAR */
-	rtas = call_prom("finddevice", 1, 1, ADDR("/rtas"));
-	if (rtas != (phandle) -1) {
-		unsigned long x;
-		x = prom_getproplen(rtas, "ibm,hypertas-functions");
-		if (x != PROM_ERROR) {
-			prom_printf("Hypertas detected, assuming LPAR !\n");
-			return PLATFORM_PSERIES_LPAR;
-		}
-	}
+
+	/* Default to pSeries. */ 
+	if(lpar) return PLATFORM_PSERIES_LPAR;
+
 	return PLATFORM_PSERIES;
 }
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/rtas.c linux--vhype--2.6.11/arch/ppc64/kernel/rtas.c
--- linux--2.6.11/arch/ppc64/kernel/rtas.c	2005-03-01 16:22:10.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/rtas.c	2005-03-01 21:17:16.000000000 +0000
@@ -594,7 +594,7 @@ void __init rtas_initialize(void)
 	 */
 	if (rtas.dev) {
 		unsigned long rtas_region = RTAS_INSTANTIATE_MAX;
-		if (systemcfg->platform == PLATFORM_PSERIES_LPAR)
+		if (systemcfg->platform & PLATFORM_PSERIES_LPAR)
 			rtas_region = min(lmb.rmo_size, RTAS_INSTANTIATE_MAX);
 
 		rtas_rmo_buf = lmb_alloc_base(RTAS_RMOBUF_MAX, PAGE_SIZE,
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/sysfs.c linux--vhype--2.6.11/arch/ppc64/kernel/sysfs.c
--- linux--2.6.11/arch/ppc64/kernel/sysfs.c	2005-03-01 17:18:09.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/sysfs.c	2005-03-02 15:47:46.000000000 +0000
@@ -414,7 +414,7 @@ static int __init topology_init(void)
 		 * for hotplugging.
 		 */
 #ifdef CONFIG_HOTPLUG_CPU
-		if (systemcfg->platform != PLATFORM_PSERIES_LPAR)
+		if (!(systemcfg->platform & PLATFORM_PSERIES_LPAR))
 #endif
 			c->no_control = 1;
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/traps.c linux--vhype--2.6.11/arch/ppc64/kernel/traps.c
--- linux--2.6.11/arch/ppc64/kernel/traps.c	2005-03-01 16:37:28.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/traps.c	2005-03-01 21:23:59.000000000 +0000
@@ -125,6 +125,14 @@ int die(const char *str, struct pt_regs 
 			printk("POWERMAC ");
 			nl = 1;
 			break;
+		case PLATFORM_MAPLE_LPAR:
+			printk("MAPLE LPAR ");
+			nl = 1;
+			break;
+		case PLATFORM_MAPLE:
+			printk("MAPLE ");
+			nl = 1;
+			break;
 	}
 	if (nl)
 		printk("\n");
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/vio.c linux--vhype--2.6.11/arch/ppc64/kernel/vio.c
--- linux--2.6.11/arch/ppc64/kernel/vio.c	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/vio.c	2005-03-01 21:12:29.000000000 +0000
@@ -19,16 +19,22 @@
 #include <linux/kobject.h>
 #include <linux/mm.h>
 #include <linux/dma-mapping.h>
+#ifndef CONFIG_X86_HYPERVISOR
 #include <asm/rtas.h>
+#endif
 #include <asm/iommu.h>
 #include <asm/dma.h>
+#ifndef CONFIG_X86_HYPERVISOR
 #include <asm/ppcdebug.h>
+#endif
 #include <asm/vio.h>
 #include <asm/hvcall.h>
+#ifndef CONFIG_X86_HYPERVISOR
 #include <asm/iSeries/vio.h>
 #include <asm/iSeries/HvTypes.h>
 #include <asm/iSeries/HvCallXm.h>
 #include <asm/iSeries/HvLpConfig.h>
+#endif
 
 #define DBGENTER() pr_debug("%s entered\n", __FUNCTION__)
 
@@ -281,6 +287,9 @@ static int __init vio_bus_init(void)
 #ifdef CONFIG_PPC_ISERIES
 	probe_bus_iseries();
 #endif
+#ifdef CONFIG_X86_HYPERVISOR
+	probe_bus_x86(vio_bus_device);
+#endif
 
 	return 0;
 }
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/kernel/xics.c linux--vhype--2.6.11/arch/ppc64/kernel/xics.c
--- linux--2.6.11/arch/ppc64/kernel/xics.c	2005-03-01 16:22:10.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/kernel/xics.c	2005-03-01 21:17:16.000000000 +0000
@@ -28,6 +28,7 @@
 #include <asm/xics.h>
 #include <asm/hvcall.h>
 #include <asm/machdep.h>
+#include <asm/plpar_wrappers.h>
 
 #include "i8259.h"
 
@@ -145,28 +146,6 @@ static xics_ops *ops = &pSeries_ops;
 
 
 /* LPAR */
-
-static inline long plpar_eoi(unsigned long xirr)
-{
-	return plpar_hcall_norets(H_EOI, xirr);
-}
-
-static inline long plpar_cppr(unsigned long cppr)
-{
-	return plpar_hcall_norets(H_CPPR, cppr);
-}
-
-static inline long plpar_ipi(unsigned long servernum, unsigned long mfrr)
-{
-	return plpar_hcall_norets(H_IPI, servernum, mfrr);
-}
-
-static inline long plpar_xirr(unsigned long *xirr_ret)
-{
-	unsigned long dummy;
-	return plpar_hcall(H_XIRR, 0, 0, 0, 0, xirr_ret, &dummy, &dummy);
-}
-
 static int pSeriesLP_xirr_info_get(int n_cpu)
 {
 	unsigned long lpar_rc;
@@ -552,7 +531,7 @@ nextnode:
 #else
 		xics_per_cpu[0] = ioremap(intr_base, intr_size);
 #endif /* CONFIG_SMP */
-	} else if (systemcfg->platform == PLATFORM_PSERIES_LPAR) {
+	} else if (systemcfg->platform & PLATFORM_LPAR) {
 		ops = &pSeriesLP_ops;
 	}
 
diff -urNpX diff.exclude linux--2.6.11/arch/ppc64/oprofile/op_model_power4.c linux--vhype--2.6.11/arch/ppc64/oprofile/op_model_power4.c
--- linux--2.6.11/arch/ppc64/oprofile/op_model_power4.c	2005-03-01 16:16:27.000000000 +0000
+++ linux--vhype--2.6.11/arch/ppc64/oprofile/op_model_power4.c	2005-03-01 21:12:29.000000000 +0000
@@ -215,7 +215,7 @@ static unsigned long get_pc(struct pt_re
 	mmcra = mfspr(SPRN_MMCRA);
 
 	/* Were we in the hypervisor? */
-	if ((systemcfg->platform == PLATFORM_PSERIES_LPAR) &&
+	if ((systemcfg->platform & PLATFORM_LPAR) &&
 	    (mmcra & MMCRA_SIHV))
 		/* function descriptor madness */
 		return *((unsigned long *)hypervisor_bucket);
diff -urNpX diff.exclude linux--2.6.11/configs/READ_ME linux--vhype--2.6.11/configs/READ_ME
--- linux--2.6.11/configs/READ_ME	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/configs/READ_ME	2005-03-01 21:12:35.000000000 +0000
@@ -0,0 +1,8 @@
+config.eserver325	This is what I'm using on my eServer 325 running
+			RedHat Enterprise Linux (rhel-3-U2-i386) with updates
+			to run 2.6.
+
+config.bochs		This is what I'm using for a kernel to run on the
+			Bochs simulator.
+		
+
diff -urNpX diff.exclude linux--2.6.11/configs/config.bochs linux--vhype--2.6.11/configs/config.bochs
--- linux--2.6.11/configs/config.bochs	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/configs/config.bochs	2005-03-01 21:12:35.000000000 +0000
@@ -0,0 +1,952 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1-vhype
+# Mon Feb  7 19:40:30 2005
+#
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor type and features
+#
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_HYPERVISOR=y
+CONFIG_OPENHYPE=y
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_ES7000 is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+CONFIG_M586=y
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_XADD=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_F00F_BUG=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_ALIGNMENT_16=y
+# CONFIG_HPET_TIMER is not set
+# CONFIG_SMP is not set
+CONFIG_PREEMPT=y
+CONFIG_PREEMPT_BKL=y
+# CONFIG_X86_UP_APIC is not set
+# CONFIG_X86_MCE is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_MTRR is not set
+CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_REGPARM is not set
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+# CONFIG_ACPI is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_LEGACY_PROC=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_ATA_OVER_ETH=m
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+# CONFIG_CHR_DEV_SG is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+CONFIG_SCSI_IBMVSCSI=y
+CONFIG_SCSI_IBMVSCSIS=y
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_NSP32 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_FWMARK is not set
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_TFTP=y
+# CONFIG_IP_NF_AMANDA is not set
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_OWNER=y
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_REALM is not set
+# CONFIG_IP_NF_MATCH_SCTP is not set
+# CONFIG_IP_NF_MATCH_COMMENT is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_LOG is not set
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_NAT_TFTP=y
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+CONFIG_ETHERTAP=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_IBMVETH=y
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+CONFIG_NE2K_PCI=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+# CONFIG_SOUND_GAMEPORT is not set
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_HVC_CONSOLE=y
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_VIDEO_SELECT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_4KSTACKS is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_PC=y
diff -urNpX diff.exclude linux--2.6.11/configs/config.eserver325 linux--vhype--2.6.11/configs/config.eserver325
--- linux--2.6.11/configs/config.eserver325	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/configs/config.eserver325	2005-03-01 21:12:35.000000000 +0000
@@ -0,0 +1,779 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor type and features
+#
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_HYPERVISOR=y
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_ES7000 is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+CONFIG_MK8=y
+# CONFIG_MCRUSOE is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_XADD=y
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+# CONFIG_HPET_TIMER is not set
+# CONFIG_HPET_EMULATE_RTC is not set
+# CONFIG_SMP is not set
+CONFIG_PREEMPT=y
+# CONFIG_X86_UP_APIC is not set
+CONFIG_X86_TSC=y
+# CONFIG_X86_MCE is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_MTRR is not set
+CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_REGPARM is not set
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+# CONFIG_ACPI is not set
+CONFIG_ACPI_BOOT=y
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_LEGACY_PROC=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_CARMEL is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_LBD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+# CONFIG_IDEDISK_STROKE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+# CONFIG_IP_ROUTE_FWMARK is not set
+CONFIG_IP_ROUTE_NAT=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_TOS=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+# CONFIG_DECNET is not set
+# CONFIG_BRIDGE is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_TFTP=y
+# CONFIG_IP_NF_AMANDA is not set
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_OWNER=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+# CONFIG_IP_NF_NAT_LOCAL is not set
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_NAT_TFTP=y
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_TARGET_LOG is not set
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+# CONFIG_IP_NF_ARPTABLES is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+CONFIG_NETDEVICES=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+CONFIG_ETHERTAP=y
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+# CONFIG_E100 is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SK98LIN is not set
+CONFIG_TIGON3=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+CONFIG_IBMVETH=y
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+# CONFIG_RCPCI is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+
+#
+# Amateur Radio support
+#
+# CONFIG_HAMRADIO is not set
+
+#
+# IrDA (infrared) support
+#
+# CONFIG_IRDA is not set
+
+#
+# Bluetooth support
+#
+# CONFIG_BT is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+# CONFIG_INPUT is not set
+
+#
+# Userland interfaces
+#
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+# CONFIG_SOUND_GAMEPORT is not set
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
+
+#
+# Input Device Drivers
+#
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_HVC_CONSOLE=y
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
+# CONFIG_ROOT_NFS is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_INTERMEZZO_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+CONFIG_FRAME_POINTER=y
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_PC=y
diff -urNpX diff.exclude linux--2.6.11/configs/config.ppc64.minimal linux--vhype--2.6.11/configs/config.ppc64.minimal
--- linux--2.6.11/configs/config.ppc64.minimal	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/configs/config.ppc64.minimal	2005-03-01 21:12:36.000000000 +0000
@@ -0,0 +1,1110 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1-vhype
+# Wed Feb  2 07:15:59 2005
+#
+CONFIG_64BIT=y
+CONFIG_MMU=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_EARLY_PRINTK=y
+CONFIG_COMPAT=y
+CONFIG_FRAME_POINTER=y
+CONFIG_FORCE_MAX_ZONEORDER=13
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION="Y"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_SYSVIPC_COMPAT=y
+
+#
+# Platform support
+#
+# CONFIG_PPC_ISERIES is not set
+CONFIG_PPC_MULTIPLATFORM=y
+CONFIG_PPC_PSERIES=y
+# CONFIG_PPC_PMAC is not set
+CONFIG_PPC_MAPLE=y
+CONFIG_PPC=y
+CONFIG_PPC64=y
+CONFIG_PPC_OF=y
+CONFIG_OPENHYPE=y
+# CONFIG_MAMBO is not set
+CONFIG_ALTIVEC=y
+# CONFIG_PPC_SPLPAR is not set
+CONFIG_IBMVIO=y
+CONFIG_U3_DART=y
+CONFIG_MPIC_BROKEN_U3=y
+# CONFIG_BOOTX_TEXT is not set
+# CONFIG_POWER4_ONLY is not set
+# CONFIG_IOMMU_VMERGE is not set
+CONFIG_SMP=y
+CONFIG_IRQ_ALL_CPUS=y
+CONFIG_NR_CPUS=32
+# CONFIG_HMT is not set
+CONFIG_DISCONTIGMEM=y
+# CONFIG_NUMA is not set
+# CONFIG_SCHED_SMT is not set
+# CONFIG_PREEMPT is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_PPC_RTAS=y
+CONFIG_RTAS_FLASH=y
+CONFIG_SCANLOG=y
+CONFIG_LPARCFG=y
+
+#
+# General setup
+#
+CONFIG_PCI=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
+# CONFIG_HOTPLUG_CPU is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+CONFIG_HOTPLUG_PCI_RPA=y
+CONFIG_HOTPLUG_PCI_RPA_DLPAR=y
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=10240
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+CONFIG_BLK_DEV_IDEPCI=y
+CONFIG_IDEPCI_SHARE_IRQ=y
+# CONFIG_BLK_DEV_OFFBOARD is not set
+CONFIG_BLK_DEV_GENERIC=y
+# CONFIG_BLK_DEV_OPTI621 is not set
+CONFIG_BLK_DEV_SL82C105=y
+CONFIG_BLK_DEV_IDEDMA_PCI=y
+# CONFIG_BLK_DEV_IDEDMA_FORCED is not set
+CONFIG_IDEDMA_PCI_AUTO=y
+# CONFIG_IDEDMA_ONLYDISK is not set
+# CONFIG_BLK_DEV_AEC62XX is not set
+# CONFIG_BLK_DEV_ALI15X3 is not set
+CONFIG_BLK_DEV_AMD74XX=y
+# CONFIG_BLK_DEV_CMD64X is not set
+# CONFIG_BLK_DEV_TRIFLEX is not set
+# CONFIG_BLK_DEV_CY82C693 is not set
+# CONFIG_BLK_DEV_CS5520 is not set
+# CONFIG_BLK_DEV_CS5530 is not set
+# CONFIG_BLK_DEV_HPT34X is not set
+# CONFIG_BLK_DEV_HPT366 is not set
+# CONFIG_BLK_DEV_SC1200 is not set
+# CONFIG_BLK_DEV_PIIX is not set
+# CONFIG_BLK_DEV_NS87415 is not set
+# CONFIG_BLK_DEV_PDC202XX_OLD is not set
+# CONFIG_BLK_DEV_PDC202XX_NEW is not set
+# CONFIG_BLK_DEV_SVWKS is not set
+# CONFIG_BLK_DEV_SIIMAGE is not set
+# CONFIG_BLK_DEV_SLC90E66 is not set
+# CONFIG_BLK_DEV_TRM290 is not set
+# CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_IVB is not set
+CONFIG_IDEDMA_AUTO=y
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_FC_ATTRS=y
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_BUSLOGIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_EATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GDTH is not set
+# CONFIG_SCSI_IPS is not set
+CONFIG_SCSI_IBMVSCSI=y
+CONFIG_SCSI_IBMVSCSIS=y
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=0
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+# CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_ISP is not set
+# CONFIG_SCSI_QLOGIC_FC is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+CONFIG_SCSI_QLA2XXX=y
+# CONFIG_SCSI_QLA21XX is not set
+# CONFIG_SCSI_QLA22XX is not set
+# CONFIG_SCSI_QLA2300 is not set
+# CONFIG_SCSI_QLA2322 is not set
+# CONFIG_SCSI_QLA6312 is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Macintosh device drivers
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_NET_IPIP=y
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+# CONFIG_IP_TCPDIAG is not set
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+CONFIG_BRIDGE_NETFILTER=y
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_IP_NF_CONNTRACK is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_QUEUE is not set
+# CONFIG_IP_NF_IPTABLES is not set
+# CONFIG_IP_NF_ARPTABLES is not set
+
+#
+# Bridge: Netfilter Configuration
+#
+CONFIG_BRIDGE_NF_EBTABLES=y
+CONFIG_BRIDGE_EBT_BROUTE=y
+CONFIG_BRIDGE_EBT_T_FILTER=y
+CONFIG_BRIDGE_EBT_T_NAT=y
+CONFIG_BRIDGE_EBT_802_3=y
+CONFIG_BRIDGE_EBT_AMONG=y
+CONFIG_BRIDGE_EBT_ARP=y
+CONFIG_BRIDGE_EBT_IP=y
+CONFIG_BRIDGE_EBT_LIMIT=y
+CONFIG_BRIDGE_EBT_MARK=y
+CONFIG_BRIDGE_EBT_PKTTYPE=y
+CONFIG_BRIDGE_EBT_STP=y
+CONFIG_BRIDGE_EBT_VLAN=y
+CONFIG_BRIDGE_EBT_ARPREPLY=y
+CONFIG_BRIDGE_EBT_DNAT=y
+CONFIG_BRIDGE_EBT_MARK_T=y
+CONFIG_BRIDGE_EBT_REDIRECT=y
+CONFIG_BRIDGE_EBT_SNAT=y
+CONFIG_BRIDGE_EBT_LOG=y
+CONFIG_BRIDGE_EBT_ULOG=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+CONFIG_BRIDGE=y
+CONFIG_VLAN_8021Q=y
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_IBMVETH=y
+CONFIG_NET_PCI=y
+CONFIG_PCNET32=y
+CONFIG_AMD8111_ETH=y
+# CONFIG_AMD8111E_NAPI is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+# CONFIG_EEPRO100 is not set
+CONFIG_E100=y
+# CONFIG_E100_NAPI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+# CONFIG_E1000_NAPI is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+# CONFIG_SOUND_GAMEPORT is not set
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_PMACZILOG is not set
+# CONFIG_SERIAL_ICOM is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_HVC_CONSOLE=y
+# CONFIG_HVSI is not set
+CONFIG_HVCS=y
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+CONFIG_I2C_ALGOBIT=y
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+# CONFIG_I2C_I801 is not set
+# CONFIG_I2C_I810 is not set
+# CONFIG_I2C_ISA is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_PROSAVAGE is not set
+# CONFIG_I2C_SAVAGE4 is not set
+# CONFIG_SCx200_ACB is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+# CONFIG_I2C_VOODOO3 is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Hardware Sensors Chip support
+#
+# CONFIG_I2C_SENSOR is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_FSCHER is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83627HF is not set
+
+#
+# Other I2C Chip support
+#
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_RTC8564 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_EHCI_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_UHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_BLUETOOTH_TTY is not set
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_RW_DETECT is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_HP8200e is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_USB_HIDINPUT=y
+# CONFIG_HID_FF is not set
+CONFIG_USB_HIDDEV=y
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_MTOUCH is not set
+# CONFIG_USB_EGALAX is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Multimedia devices
+#
+# CONFIG_USB_DABUSB is not set
+
+#
+# Video4Linux support is needed for USB Multimedia device support
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB ATM/DSL drivers
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+# CONFIG_EXT2_FS_SECURITY is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=y
+CONFIG_UDF_NLS=y
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS_XATTR=y
+# CONFIG_DEVPTS_FS_SECURITY is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+CONFIG_NFSD_V4=y
+CONFIG_NFSD_TCP=y
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_DEBUG_STACKOVERFLOW=y
+CONFIG_KPROBES=y
+CONFIG_DEBUG_STACK_USAGE=y
+CONFIG_DEBUGGER=y
+CONFIG_XMON=y
+CONFIG_XMON_DEFAULT=y
+CONFIG_PPCDBG=y
+CONFIG_IRQSTACKS=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
diff -urNpX diff.exclude linux--2.6.11/configs/config.sRp linux--vhype--2.6.11/configs/config.sRp
--- linux--2.6.11/configs/config.sRp	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/configs/config.sRp	2005-03-01 21:12:36.000000000 +0000
@@ -0,0 +1,924 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.11-rc1-vhype
+# Thu Jan 13 19:36:03 2005
+#
+CONFIG_X86=y
+CONFIG_MMU=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_KOBJECT_UEVENT=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+# CONFIG_EMBEDDED is not set
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_ALL=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SHMEM=y
+CONFIG_CC_ALIGN_FUNCTIONS=0
+CONFIG_CC_ALIGN_LABELS=0
+CONFIG_CC_ALIGN_LOOPS=0
+CONFIG_CC_ALIGN_JUMPS=0
+# CONFIG_TINY_SHMEM is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+# CONFIG_KMOD is not set
+
+#
+# Processor type and features
+#
+# CONFIG_X86_PC is not set
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_NUMAQ is not set
+# CONFIG_X86_SUMMIT is not set
+# CONFIG_X86_BIGSMP is not set
+# CONFIG_X86_VISWS is not set
+CONFIG_X86_HYPERVISOR=y
+CONFIG_OPENHYPE=y
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_ES7000 is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+CONFIG_M586=y
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP2 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_X86_GENERIC is not set
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_XADD=y
+CONFIG_X86_L1_CACHE_SHIFT=5
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_X86_PPRO_FENCE=y
+CONFIG_X86_F00F_BUG=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_ALIGNMENT_16=y
+# CONFIG_HPET_TIMER is not set
+# CONFIG_SMP is not set
+CONFIG_PREEMPT=y
+# CONFIG_PREEMPT_BKL is not set
+# CONFIG_X86_UP_APIC is not set
+# CONFIG_X86_MCE is not set
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+# CONFIG_MATH_EMULATION is not set
+# CONFIG_MTRR is not set
+CONFIG_HAVE_DEC_LOCK=y
+# CONFIG_REGPARM is not set
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# ACPI (Advanced Configuration and Power Interface) Support
+#
+# CONFIG_ACPI is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_LEGACY_PROC=y
+# CONFIG_PCI_NAMES is not set
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# PC-card bridges
+#
+
+#
+# PCI Hotplug Support
+#
+# CONFIG_HOTPLUG_PCI is not set
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+# CONFIG_LBD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+# CONFIG_BLK_DEV_HD_IDE is not set
+CONFIG_BLK_DEV_IDEDISK=y
+CONFIG_IDEDISK_MULTI_MODE=y
+CONFIG_BLK_DEV_IDECD=y
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_CMD640 is not set
+# CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_FWMARK=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+# CONFIG_IP_PNP_DHCP is not set
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+# CONFIG_IP_PIMSM_V2 is not set
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_IP_TCPDIAG=y
+# CONFIG_IP_TCPDIAG_IPV6 is not set
+
+#
+# IP: Virtual Server Configuration
+#
+# CONFIG_IP_VS is not set
+# CONFIG_IPV6 is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_IP_NF_CONNTRACK=y
+# CONFIG_IP_NF_CT_ACCT is not set
+# CONFIG_IP_NF_CONNTRACK_MARK is not set
+# CONFIG_IP_NF_CT_PROTO_SCTP is not set
+CONFIG_IP_NF_FTP=y
+CONFIG_IP_NF_IRC=y
+CONFIG_IP_NF_TFTP=y
+# CONFIG_IP_NF_AMANDA is not set
+CONFIG_IP_NF_QUEUE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_LIMIT=y
+CONFIG_IP_NF_MATCH_IPRANGE=y
+CONFIG_IP_NF_MATCH_MAC=y
+CONFIG_IP_NF_MATCH_PKTTYPE=y
+CONFIG_IP_NF_MATCH_MARK=y
+CONFIG_IP_NF_MATCH_MULTIPORT=y
+CONFIG_IP_NF_MATCH_TOS=y
+CONFIG_IP_NF_MATCH_RECENT=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_DSCP=y
+# CONFIG_IP_NF_MATCH_AH_ESP is not set
+CONFIG_IP_NF_MATCH_LENGTH=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_MATCH_TCPMSS=y
+CONFIG_IP_NF_MATCH_HELPER=y
+CONFIG_IP_NF_MATCH_STATE=y
+CONFIG_IP_NF_MATCH_CONNTRACK=y
+CONFIG_IP_NF_MATCH_OWNER=y
+# CONFIG_IP_NF_MATCH_ADDRTYPE is not set
+# CONFIG_IP_NF_MATCH_REALM is not set
+# CONFIG_IP_NF_MATCH_SCTP is not set
+# CONFIG_IP_NF_MATCH_COMMENT is not set
+# CONFIG_IP_NF_MATCH_HASHLIMIT is not set
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+# CONFIG_IP_NF_TARGET_LOG is not set
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_TARGET_TCPMSS=y
+CONFIG_IP_NF_NAT=y
+CONFIG_IP_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_IP_NF_TARGET_REDIRECT=y
+CONFIG_IP_NF_TARGET_NETMAP=y
+CONFIG_IP_NF_TARGET_SAME=y
+CONFIG_IP_NF_NAT_SNMP_BASIC=y
+CONFIG_IP_NF_NAT_IRC=y
+CONFIG_IP_NF_NAT_FTP=y
+CONFIG_IP_NF_NAT_TFTP=y
+# CONFIG_IP_NF_MANGLE is not set
+# CONFIG_IP_NF_RAW is not set
+CONFIG_IP_NF_ARPTABLES=y
+CONFIG_IP_NF_ARPFILTER=y
+CONFIG_IP_NF_ARP_MANGLE=y
+CONFIG_XFRM=y
+CONFIG_XFRM_USER=y
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+# CONFIG_NET_CLS_ROUTE is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+CONFIG_DUMMY=y
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+CONFIG_ETHERTAP=y
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+CONFIG_IBMVETH=y
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+# CONFIG_FORCEDETH is not set
+# CONFIG_DGRS is not set
+CONFIG_EEPRO100=y
+CONFIG_E100=y
+# CONFIG_E100_NAPI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+# CONFIG_NE2K_PCI is not set
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+# CONFIG_E1000_NAPI is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_TIGON3=y
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+# CONFIG_SOUND_GAMEPORT is not set
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_HVC_CONSOLE=y
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_NVRAM is not set
+# CONFIG_RTC is not set
+CONFIG_GEN_RTC=y
+# CONFIG_GEN_RTC_X is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HANGCHECK_TIMER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Dallas's 1-wire bus
+#
+# CONFIG_W1 is not set
+
+#
+# Misc devices
+#
+# CONFIG_IBM_ASM is not set
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+# CONFIG_VIDEO_SELECT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+# CONFIG_SND is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support' may also be needed; see USB_STORAGE Help for more information
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# MMC/SD Card support
+#
+# CONFIG_MMC is not set
+
+#
+# InfiniBand support
+#
+# CONFIG_INFINIBAND is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=y
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_MSDOS_FS is not set
+# CONFIG_VFAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_XATTR is not set
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V4 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_DEBUG_PREEMPT=y
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_KPROBES is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_4KSTACKS=y
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+CONFIG_CRYPTO=y
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_WP512 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_AES_586 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Hardware crypto devices
+#
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_PC=y
diff -urNpX diff.exclude linux--2.6.11/drivers/Makefile linux--vhype--2.6.11/drivers/Makefile
--- linux--2.6.11/drivers/Makefile	2005-03-01 16:16:34.000000000 +0000
+++ linux--vhype--2.6.11/drivers/Makefile	2005-03-01 21:12:36.000000000 +0000
@@ -63,3 +63,4 @@ obj-$(CONFIG_MMC)		+= mmc/
 obj-$(CONFIG_INFINIBAND)	+= infiniband/
 obj-y				+= firmware/
 obj-$(CONFIG_CRYPTO)		+= crypto/
+obj-$(CONFIG_OPENHYPE)		+= openhype/
diff -urNpX diff.exclude linux--2.6.11/drivers/char/Kconfig linux--vhype--2.6.11/drivers/char/Kconfig
--- linux--2.6.11/drivers/char/Kconfig	2005-03-01 16:37:32.000000000 +0000
+++ linux--vhype--2.6.11/drivers/char/Kconfig	2005-03-01 21:24:03.000000000 +0000
@@ -557,11 +557,23 @@ config TIPAR
 
 config HVC_CONSOLE
 	bool "pSeries Hypervisor Virtual Console support"
-	depends on PPC_PSERIES
+	depends on PPC_PSERIES || X86_HYPERVISOR
+	help
+	  pSeries or xSeries machines when partitioned support a hypervisor
+	  virtual console. This driver allows each pSeries/xSeries partition
+	  to have a console which is accessed via the HMC.
+
+config HVSI
+	bool "pSeries Hypervisor Virtual Console support"
+	depends on PPC_PSERIES && HVC_CONSOLE
 	help
-	  pSeries machines when partitioned support a hypervisor virtual
-	  console. This driver allows each pSeries partition to have a console
-	  which is accessed via the HMC.
+	  Host Virtual Serial Interface (HVSI) is a protocol between
+	  the hosted OS and the service processor on IBM pSeries
+	  servers. On these servers, there are no serial ports under
+	  the OS's control, and sometimes there is no other console
+	  available either. However, the service processor has two
+	  standard serial ports, so this over-complicated protocol
+	  allows the OS to control those ports by proxy.
 
 config HVCS
 	tristate "IBM Hypervisor Virtual Console Server support"
diff -urNpX diff.exclude linux--2.6.11/drivers/char/Makefile linux--vhype--2.6.11/drivers/char/Makefile
--- linux--2.6.11/drivers/char/Makefile	2005-03-01 16:37:32.000000000 +0000
+++ linux--vhype--2.6.11/drivers/char/Makefile	2005-03-01 21:24:03.000000000 +0000
@@ -41,7 +41,8 @@ obj-$(CONFIG_N_HDLC)		+= n_hdlc.o
 obj-$(CONFIG_AMIGA_BUILTIN_SERIAL) += amiserial.o
 obj-$(CONFIG_SX)		+= sx.o generic_serial.o
 obj-$(CONFIG_RIO)		+= rio/ generic_serial.o
-obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o hvsi.o
+obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o
+obj-$(CONFIG_HVSI)		+= hvsi.o
 obj-$(CONFIG_RAW_DRIVER)	+= raw.o
 obj-$(CONFIG_SGI_SNSC)		+= snsc.o
 obj-$(CONFIG_MMTIMER)		+= mmtimer.o
diff -urNpX diff.exclude linux--2.6.11/drivers/char/hvc_console.c linux--vhype--2.6.11/drivers/char/hvc_console.c
--- linux--2.6.11/drivers/char/hvc_console.c	2005-03-01 16:16:40.000000000 +0000
+++ linux--vhype--2.6.11/drivers/char/hvc_console.c	2005-03-01 21:12:44.000000000 +0000
@@ -66,8 +66,13 @@ static struct tty_driver *hvc_driver;
 static int sysrq_pressed;
 #endif
 
+#ifdef CONFIG_X86_HYPERVISOR
+#define N_OUTBUF	8
+#define N_INBUF		16
+#else
 #define N_OUTBUF	16
 #define N_INBUF		16
+#endif
 
 #define __ALIGNED__	__attribute__((__aligned__(8)))
 
@@ -758,7 +763,7 @@ int hvc_instantiate(uint32_t vtermno, in
 
 void hvc_console_print(struct console *co, const char *b, unsigned count)
 {
-	char c[16] __ALIGNED__;
+	char c[N_OUTBUF] __ALIGNED__;
 	unsigned i = 0, n = 0;
 	int r, donecr = 0;
 
diff -urNpX diff.exclude linux--2.6.11/drivers/ide/ide.c linux--vhype--2.6.11/drivers/ide/ide.c
--- linux--2.6.11/drivers/ide/ide.c	2005-03-01 17:45:20.000000000 +0000
+++ linux--vhype--2.6.11/drivers/ide/ide.c	2005-03-02 15:53:15.000000000 +0000
@@ -181,6 +181,7 @@ DECLARE_MUTEX(ide_cfg_sem);
 static int ide_scan_direction; /* THIS was formerly 2.2.x pci=reverse */
 #endif
 
+
 #ifdef CONFIG_IDEDMA_AUTO
 int noautodma = 0;
 #else
@@ -1708,6 +1709,13 @@ static int __init ide_setup(char *s)
 	}
 #endif /* CONFIG_BLK_DEV_IDEDOUBLER */
 
+	if (!strcmp(s, "ide=off")) {
+		printk(" : IDE disabled\n");
+		for (hwif = ide_hwifs; hwif < &ide_hwifs[MAX_HWIFS]; hwif++)
+			hwif->noprobe = 1;
+		return 1;
+	}
+
 	if (!strcmp(s, "ide=nodma")) {
 		printk(" : Prevented DMA\n");
 		noautodma = 1;
diff -urNpX diff.exclude linux--2.6.11/drivers/input/gameport/Kconfig linux--vhype--2.6.11/drivers/input/gameport/Kconfig
--- linux--2.6.11/drivers/input/gameport/Kconfig	2005-03-01 16:16:44.000000000 +0000
+++ linux--vhype--2.6.11/drivers/input/gameport/Kconfig	2005-03-01 21:12:48.000000000 +0000
@@ -37,7 +37,8 @@ config GAMEPORT
 # GAMEPORT is 'y' or 'n', it can be anything".
 config SOUND_GAMEPORT
 	tristate
-	default y if GAMEPORT!=m
+	default n if GAMEPORT=n
+	default y if GAMEPORT=y
 	default m if GAMEPORT=m
 
 config GAMEPORT_NS558
diff -urNpX diff.exclude linux--2.6.11/drivers/input/serio/i8042-io.h linux--vhype--2.6.11/drivers/input/serio/i8042-io.h
--- linux--2.6.11/drivers/input/serio/i8042-io.h	2005-03-01 16:16:45.000000000 +0000
+++ linux--vhype--2.6.11/drivers/input/serio/i8042-io.h	2005-03-01 21:12:48.000000000 +0000
@@ -64,6 +64,14 @@ static inline void i8042_write_command(i
 static inline int i8042_platform_init(void)
 {
 /*
+ * Do not touch hardware registers when we lack I/O privileges
+ */
+#ifdef CONFIG_X86_HYPERVISOR
+	if (!oh_iopriv())
+		return -1;
+#endif
+
+/*
  * On some platforms touching the i8042 data register region can do really
  * bad things. Because of this the region is always reserved on such boxes.
  */
diff -urNpX diff.exclude linux--2.6.11/drivers/net/Kconfig linux--vhype--2.6.11/drivers/net/Kconfig
--- linux--2.6.11/drivers/net/Kconfig	2005-03-01 16:22:16.000000000 +0000
+++ linux--vhype--2.6.11/drivers/net/Kconfig	2005-03-01 21:17:28.000000000 +0000
@@ -1171,7 +1171,7 @@ config IBMLANA
 
 config IBMVETH
 	tristate "IBM LAN Virtual Ethernet support"
-	depends on NETDEVICES && NET_ETHERNET && PPC_PSERIES
+	depends on NETDEVICES && NET_ETHERNET && (PPC_PSERIES || X86_HYPERVISOR)
 	---help---
 	  This driver supports virtual ethernet adapters on newer IBM iSeries
 	  and pSeries systems.
diff -urNpX diff.exclude linux--2.6.11/drivers/net/ibmveth.c linux--vhype--2.6.11/drivers/net/ibmveth.c
--- linux--2.6.11/drivers/net/ibmveth.c	2005-03-01 17:18:13.000000000 +0000
+++ linux--vhype--2.6.11/drivers/net/ibmveth.c	2005-03-03 20:24:06.000000000 +0000
@@ -266,8 +266,8 @@ static inline int ibmveth_is_replenishin
 /* kick the replenish tasklet if we need replenishing and it isn't already running */
 static inline void ibmveth_schedule_replenishing(struct ibmveth_adapter *adapter)
 {
-	if(ibmveth_is_replenishing_needed(adapter) &&
-	   (atomic_dec_if_positive(&adapter->not_replenishing) == 0)) {
+	if(ibmveth_is_replenishing_needed(adapter) && 
+	   (atomic_dec_if_positive(&adapter->not_replenishing) == 0)) {	
 		schedule_work(&adapter->replenish_task);
 	}
 }
@@ -450,7 +450,7 @@ static void ibmveth_cleanup(struct ibmve
 
 static int ibmveth_open(struct net_device *netdev)
 {
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	u64 mac_address = 0;
 	int rxq_entries;
 	unsigned long lpar_rc;
@@ -512,7 +512,9 @@ static int ibmveth_open(struct net_devic
 	}
 
 	memcpy(&mac_address, netdev->dev_addr, netdev->addr_len);
+#ifndef CONFIG_X86_HYPERVISOR
 	mac_address = mac_address >> 16;
+#endif
 
 	rxq_desc.desc = 0;
 	rxq_desc.fields.valid = 1;
@@ -532,11 +534,11 @@ static int ibmveth_open(struct net_devic
 
 	if(lpar_rc != H_Success) {
 		ibmveth_error_printk("h_register_logical_lan failed with %ld\n", lpar_rc);
-		ibmveth_error_printk("buffer TCE:0x%x filter TCE:0x%x rxq desc:0x%lx MAC:0x%lx\n",
+		ibmveth_error_printk("buffer TCE:0x%x filter TCE:0x%x rxq desc:0x%llx MAC:0x%llx\n",
 				     adapter->buffer_list_dma,
 				     adapter->filter_list_dma,
-				     rxq_desc.desc,
-				     mac_address);
+				     (long long)rxq_desc.desc,
+				     (long long)mac_address);
 		ibmveth_cleanup(adapter);
 		return -ENONET; 
 	}
@@ -564,7 +566,7 @@ static int ibmveth_open(struct net_devic
 
 static int ibmveth_close(struct net_device *netdev)
 {
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	long lpar_rc;
     
 	ibmveth_debug_printk("close starting\n");
@@ -635,7 +637,7 @@ static int ibmveth_ioctl(struct net_devi
 
 static int ibmveth_start_xmit(struct sk_buff *skb, struct net_device *netdev)
 {
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	union ibmveth_buf_desc desc[IbmVethMaxSendFrags];
 	unsigned long lpar_rc;
 	int nfrags = 0, curfrag;
@@ -739,7 +741,7 @@ static int ibmveth_start_xmit(struct sk_
 
 static int ibmveth_poll(struct net_device *netdev, int *budget)
 {
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	int max_frames_to_process = netdev->quota;
 	int frames_processed = 0;
 	int more_work = 1;
@@ -816,7 +818,7 @@ static int ibmveth_poll(struct net_devic
 static irqreturn_t ibmveth_interrupt(int irq, void *dev_instance, struct pt_regs *regs)
 {   
 	struct net_device *netdev = dev_instance;
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	unsigned long lpar_rc;
 
 	if(netif_rx_schedule_prep(netdev)) {
@@ -835,7 +837,7 @@ static struct net_device_stats *ibmveth_
 
 static void ibmveth_set_multicast_list(struct net_device *netdev)
 {
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 	unsigned long lpar_rc;
 
 	if((netdev->flags & IFF_PROMISC) || (netdev->mc_count > adapter->mcastFilterSize)) {
@@ -861,7 +863,7 @@ static void ibmveth_set_multicast_list(s
 		/* add the addresses to the filter table */
 		for(i = 0; i < netdev->mc_count; ++i, mclist = mclist->next) {
 			// add the multicast address to the filter table
-			unsigned long mcast_addr = 0;
+			u64 mcast_addr = 0;
 			memcpy(((char *)&mcast_addr)+2, mclist->dmi_addr, 6);
 			lpar_rc = h_multicast_ctrl(adapter->vdev->unit_address,
 						   IbmVethMcastAddFilter,
@@ -889,19 +891,37 @@ static int ibmveth_change_mtu(struct net
 	return 0;	
 }
 
+#ifdef CONFIG_X86_HYPERVISOR
+/*
+ * The MAC address is in little endian format. Convert it
+ * into something LLAN understands.
+ */
+static void ibmveth_ethaddr_convert(u64 *mac, u8 *ea)
+{
+	int i;
+
+	*mac = 0ULL;
+	for (i = 0; i < 6; i++)
+		((u8 *)mac)[6-i-1] = ea[i];
+}
+#endif /* CONFIG_X86_HYPERVISOR */
+
 static int __devinit ibmveth_probe(struct vio_dev *dev, const struct vio_device_id *id)
 {
 	int rc;
 	struct net_device *netdev;
 	struct ibmveth_adapter *adapter;
 
+#ifndef CONFIG_X86_HYPERVISOR
 	unsigned char *mac_addr_p;
+#endif
 	unsigned int *mcastFilterSize_p;
 
 
 	ibmveth_debug_printk_no_adapter("entering ibmveth_probe for UA 0x%x\n", 
 					dev->unit_address);
 
+#ifndef CONFIG_X86_HYPERVISOR
 	mac_addr_p = (unsigned char *) vio_get_attribute(dev, VETH_MAC_ADDR, 0);
 	if(!mac_addr_p) {
 		printk(KERN_ERR "(%s:%3.3d) ERROR: Can't find VETH_MAC_ADDR "
@@ -916,6 +936,9 @@ static int __devinit ibmveth_probe(struc
 				__FILE__, __LINE__);
 		return 0;
 	}
+#else
+	mcastFilterSize_p = &dev->filters;
+#endif
 	
 	netdev = alloc_etherdev(sizeof(struct ibmveth_adapter));
 
@@ -924,7 +947,7 @@ static int __devinit ibmveth_probe(struc
 
 	SET_MODULE_OWNER(netdev);
 
-	adapter = netdev->priv;
+	adapter = netdev_priv(netdev);
 	memset(adapter, 0, sizeof(adapter));
 	dev->dev.driver_data = netdev;
 
@@ -932,6 +955,7 @@ static int __devinit ibmveth_probe(struc
 	adapter->netdev = netdev;
 	adapter->mcastFilterSize= *mcastFilterSize_p;
 	
+#ifndef CONFIG_X86_HYPERVISOR
 	/* 	Some older boxes running PHYP non-natively have an OF that
 		returns a 8-byte local-mac-address field (and the first 
 		2 bytes have to be ignored) while newer boxes' OF return
@@ -947,7 +971,12 @@ static int __devinit ibmveth_probe(struc
 	memcpy(&adapter->mac_addr, mac_addr_p, 6);
 
 	adapter->liobn = dev->iommu_table->it_index;
-	
+#else
+	ibmveth_ethaddr_convert(&adapter->mac_addr, dev->mac);
+
+	adapter->liobn = dev->liobn;
+#endif
+
 	netdev->irq = dev->irq;
 	netdev->open               = ibmveth_open;
 	netdev->poll               = ibmveth_poll;
@@ -963,6 +992,8 @@ static int __devinit ibmveth_probe(struc
 
 	memcpy(&netdev->dev_addr, &adapter->mac_addr, netdev->addr_len);
 
+	netdev->class_dev.dev = 0;
+
 	ibmveth_init_buffer_pool(&adapter->rx_buff_pool[0], 0, IbmVethPool0DftCnt, IbmVethPool0DftSize);
 	ibmveth_init_buffer_pool(&adapter->rx_buff_pool[1], 1, IbmVethPool1DftCnt, IbmVethPool1DftSize);
 	ibmveth_init_buffer_pool(&adapter->rx_buff_pool[2], 2, IbmVethPool2DftCnt, IbmVethPool2DftSize);
@@ -997,7 +1028,7 @@ static int __devinit ibmveth_probe(struc
 static int __devexit ibmveth_remove(struct vio_dev *dev)
 {
 	struct net_device *netdev = dev->dev.driver_data;
-	struct ibmveth_adapter *adapter = netdev->priv;
+	struct ibmveth_adapter *adapter = netdev_priv(netdev);
 
 	unregister_netdev(netdev);
 
@@ -1058,16 +1089,16 @@ static int ibmveth_seq_show(struct seq_f
 		   firmware_mac[3], firmware_mac[4], firmware_mac[5]);
 	
 	seq_printf(seq, "\nAdapter Statistics:\n");
-	seq_printf(seq, "  TX:  skbuffs linearized:          %ld\n", adapter->tx_linearized);
-	seq_printf(seq, "       multi-descriptor sends:      %ld\n", adapter->tx_multidesc_send);
-	seq_printf(seq, "       skb_linearize failures:      %ld\n", adapter->tx_linearize_failed);
-	seq_printf(seq, "       vio_map_single failres:      %ld\n", adapter->tx_map_failed);
-	seq_printf(seq, "       send failures:               %ld\n", adapter->tx_send_failed);
-	seq_printf(seq, "  RX:  replenish task cycles:       %ld\n", adapter->replenish_task_cycles);
-	seq_printf(seq, "       alloc_skb_failures:          %ld\n", adapter->replenish_no_mem);
-	seq_printf(seq, "       add buffer failures:         %ld\n", adapter->replenish_add_buff_failure);
-	seq_printf(seq, "       invalid buffers:             %ld\n", adapter->rx_invalid_buffer);
-	seq_printf(seq, "       no buffers:                  %ld\n", adapter->rx_no_buffer);
+	seq_printf(seq, "  TX:  skbuffs linearized:          %lld\n", adapter->tx_linearized);
+	seq_printf(seq, "       multi-descriptor sends:      %lld\n", adapter->tx_multidesc_send);
+	seq_printf(seq, "       skb_linearize failures:      %lld\n", adapter->tx_linearize_failed);
+	seq_printf(seq, "       vio_map_single failres:      %lld\n", adapter->tx_map_failed);
+	seq_printf(seq, "       send failures:               %lld\n", adapter->tx_send_failed);
+	seq_printf(seq, "  RX:  replenish task cycles:       %lld\n", adapter->replenish_task_cycles);
+	seq_printf(seq, "       alloc_skb_failures:          %lld\n", adapter->replenish_no_mem);
+	seq_printf(seq, "       add buffer failures:         %lld\n", adapter->replenish_add_buff_failure);
+	seq_printf(seq, "       invalid buffers:             %lld\n", adapter->rx_invalid_buffer);
+	seq_printf(seq, "       no buffers:                  %lld\n", adapter->rx_no_buffer);
 	
 	return 0;
 }
diff -urNpX diff.exclude linux--2.6.11/drivers/net/ibmveth.h linux--vhype--2.6.11/drivers/net/ibmveth.h
--- linux--2.6.11/drivers/net/ibmveth.h	2005-03-01 16:16:56.000000000 +0000
+++ linux--vhype--2.6.11/drivers/net/ibmveth.h	2005-03-01 21:12:57.000000000 +0000
@@ -1,6 +1,6 @@
 /**************************************************************************/
 /*                                                                        */
-/* IBM eServer i/[Series Virtual Ethernet Device Driver                   */
+/* IBM eServer i/pSeries Virtual Ethernet Device Driver                   */
 /* Copyright (C) 2003 IBM Corp.                                           */
 /*  Dave Larson (larson1@us.ibm.com)                                      */
 /*  Santiago Leon (santil@us.ibm.com)                                     */
@@ -28,20 +28,21 @@
 #define IbmVethMaxSendFrags 6
 
 /* constants for H_MULTICAST_CTRL */
-#define IbmVethMcastReceptionModifyBit     0x80000UL
-#define IbmVethMcastReceptionEnableBit     0x20000UL
-#define IbmVethMcastFilterModifyBit        0x40000UL
-#define IbmVethMcastFilterEnableBit        0x10000UL
+#define IbmVethMcastReceptionModifyBit     0x80000ULL
+#define IbmVethMcastReceptionEnableBit     0x20000ULL
+#define IbmVethMcastFilterModifyBit        0x40000ULL
+#define IbmVethMcastFilterEnableBit        0x10000ULL
 
 #define IbmVethMcastEnableRecv       (IbmVethMcastReceptionModifyBit | IbmVethMcastReceptionEnableBit)
 #define IbmVethMcastDisableRecv      (IbmVethMcastReceptionModifyBit)
 #define IbmVethMcastEnableFiltering  (IbmVethMcastFilterModifyBit | IbmVethMcastFilterEnableBit)
 #define IbmVethMcastDisableFiltering (IbmVethMcastFilterModifyBit)
-#define IbmVethMcastAddFilter        0x1UL
-#define IbmVethMcastRemoveFilter     0x2UL
-#define IbmVethMcastClearFilterTable 0x3UL
+#define IbmVethMcastAddFilter        0x1ULL
+#define IbmVethMcastRemoveFilter     0x2ULL
+#define IbmVethMcastClearFilterTable 0x3ULL
 
 /* hcall numbers */
+#ifndef CONFIG_X86_HYPERVISOR
 #define H_VIO_SIGNAL             0x104
 #define H_REGISTER_LOGICAL_LAN   0x114
 #define H_FREE_LOGICAL_LAN       0x118
@@ -49,6 +50,7 @@
 #define H_SEND_LOGICAL_LAN       0x120
 #define H_MULTICAST_CTRL         0x130
 #define H_CHANGE_LOGICAL_LAN_MAC 0x14C
+#endif
 
 /* hcall macros */
 #define h_register_logical_lan(ua, buflst, rxq, fltlst, mac) \
@@ -106,7 +108,7 @@ struct ibmveth_adapter {
     struct net_device *netdev;
     struct net_device_stats stats;
     unsigned int mcastFilterSize;
-    unsigned long mac_addr;
+    u64 mac_addr;
     unsigned long liobn;
     void * buffer_list_addr;
     void * filter_list_addr;
diff -urNpX diff.exclude linux--2.6.11/drivers/openhype/Makefile linux--vhype--2.6.11/drivers/openhype/Makefile
--- linux--2.6.11/drivers/openhype/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/openhype/Makefile	2005-03-01 21:13:02.000000000 +0000
@@ -0,0 +1,4 @@
+# Makefile for hypervisor drivers
+
+obj-y	+= hcall.o irq_reflect.o mem_hold.o
+
diff -urNpX diff.exclude linux--2.6.11/drivers/openhype/hcall.c linux--vhype--2.6.11/drivers/openhype/hcall.c
--- linux--2.6.11/drivers/openhype/hcall.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/openhype/hcall.c	2005-03-01 21:13:02.000000000 +0000
@@ -0,0 +1,164 @@
+/* /dev/hcall: device for userspace access to hypervisor, and memory.
+ *
+ * Copyright (C) 2004, Rusty Russell IBM Corporation.
+ */
+//#include <linux/hcall.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/ioctl32.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/openhype.h>
+
+#include <asm/semaphore.h>
+#include <asm/errno.h>
+#include <asm/hvcall.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+
+#include "openhype_internal.h"
+
+static LIST_HEAD(shared);
+static DECLARE_MUTEX(hcall_lock);
+
+static int do_generic_hcall(void __user* arg)
+{
+	oh_hcall_args ha;
+	int ret;
+
+	if (copy_from_user(&ha, arg, sizeof(ha)) != 0)
+		return -EFAULT;
+
+	/* This may not be necessary. */
+	down(&hcall_lock);
+
+	ret = oh_generic_hcall(&ha);
+
+	up(&hcall_lock);
+
+	if(ret < 0) return ret;
+
+	if (copy_to_user(arg, &ha, sizeof(ha)) != 0)
+		return -EFAULT;
+
+	return ret;
+}
+
+
+
+static int hcall_ioctl(struct inode *inode, struct file *file,
+		       unsigned int cmd, unsigned long arg)
+{
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	switch(cmd) {
+	case OH_GENHCALL:
+		return do_generic_hcall((void __user*)arg);
+	case OH_IRQ_REFLECT:
+		return do_config_reflect(file, (void __user*)arg);
+	case OH_MEM_HOLD:
+		return do_config_mem_hold(file, (void __user*)arg);
+	}
+
+	return -ENOTTY;
+}
+
+/* We can map any shared region, or any logical memory Linux doesn't
+ * know about. */
+static int hcall_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (down_interruptible(&hcall_lock) != 0)
+		return -EINTR;
+
+	err = -EINVAL;
+	/* This isn't actually right for all archs: works for x86 and
+	 * ppc though.  This prevents us mapping kernel memory. */
+
+	/* Second, check memory holds for memory that is within the
+	 * kernel that has been held aside for this purpose (OH_MEM_HOLD). */
+	if (pfn_valid(vma->vm_pgoff)) {
+		if(check_hold_mem(file, vma->vm_pgoff << PAGE_SHIFT,
+				  vma->vm_end - vma->vm_start)) {
+			/* Don't try to swap out physical pages.. */
+			vma->vm_flags |= VM_RESERVED;
+		} else {
+			goto unlock;
+		}
+	}
+
+	err = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+			      vma->vm_end - vma->vm_start,
+			      vma->vm_page_prot);
+unlock:
+	up(&hcall_lock);
+	return err;
+}
+
+static int hcall_open(struct inode *i, struct file *f)
+{
+	struct hcall_file_priv* hfp = kmalloc(sizeof(struct hcall_file_priv),
+					     GFP_KERNEL);
+	
+	spin_lock_init(&hfp->hfp_lock);
+	INIT_LIST_HEAD(&hfp->hfp_reflist);
+	INIT_LIST_HEAD(&hfp->hfp_holdlist);
+
+	f->private_data = hfp;
+	return 0;
+}
+
+static int hcall_release(struct inode *i, struct file *f)
+{
+
+	irq_reflect_release(i, f);
+	mem_hold_release(i, f);
+
+	kfree(f->private_data);
+	f->private_data = NULL;
+	return 0;
+}
+
+
+
+static struct file_operations hcall_fops = {
+	.open		= hcall_open,
+	.ioctl		= hcall_ioctl,
+	.mmap		= hcall_mmap,
+	.release	= hcall_release,
+};
+
+static int major;
+
+static int init(void)
+{
+	major = register_chrdev(0, "hcall", &hcall_fops);
+	if(major >= 0) {
+#ifdef CONFIG_COMPAT
+		register_ioctl32_conversion(OH_GENHCALL, NULL);
+		register_ioctl32_conversion(OH_IRQ_REFLECT, NULL);
+		register_ioctl32_conversion(OH_MEM_HOLD, NULL);
+#endif
+		devfs_mk_cdev(MKDEV(major, 0), 
+			      S_IFCHR|S_IRUGO|S_IWUGO, "hcall");
+	}
+	return major < 0 ? major : 0;
+}
+
+static void fini(void)
+{
+	unregister_chrdev(major, "hcall");
+}
+
+module_init(init);
+module_exit(fini);
+
diff -urNpX diff.exclude linux--2.6.11/drivers/openhype/irq_reflect.c linux--vhype--2.6.11/drivers/openhype/irq_reflect.c
--- linux--2.6.11/drivers/openhype/irq_reflect.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/openhype/irq_reflect.c	2005-03-01 21:13:02.000000000 +0000
@@ -0,0 +1,150 @@
+/* /dev/hcall: device for userspace access to hypervisor, and memory.
+ *
+ * Copyright (C) 2004, Rusty Russell IBM Corporation.
+ */
+//#include <linux/hcall.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/openhype.h>
+#include <linux/interrupt.h>
+#include <asm/errno.h>
+#include <asm/hvcall.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+#include "openhype_internal.h"
+
+struct reflector
+{
+	struct list_head reflist;
+	struct list_head file_list;
+	struct file* handle;
+
+	/* Here's who to signal, if we're triggered. */
+	struct task_struct *p;
+	int sig;
+	int interrupt;
+	int virq;
+};
+
+
+
+spinlock_t ref_lock = SPIN_LOCK_UNLOCKED;
+struct list_head reflist = LIST_HEAD_INIT(reflist);
+
+
+int ref_handler(int irq, void* data, struct pt_regs* regs)
+{
+	struct reflector *ref = (struct reflector*)data;
+	struct siginfo info;
+	unsigned long flags;
+	spin_lock_irqsave(&ref_lock, flags);
+	if (ref->virq == irq) {
+		info.si_errno = 0;
+		info.si_code = 0;
+		info.si_signo = ref->sig;
+		info.si_addr = (void*)(unsigned long)ref->virq;
+		send_sig_info(ref->sig, &info, ref->p);
+	}
+	spin_unlock_irqrestore(&ref_lock, flags);
+	return IRQ_HANDLED;
+}
+
+
+int do_config_reflect(struct file* f, void __user *arg)
+{
+	oh_reflect_args or;
+	struct reflector *ref;
+	struct hcall_file_priv *hfp = (struct hcall_file_priv*)f->private_data;
+	unsigned long flags;
+	int ret = 0;
+
+	if (copy_from_user(&or, arg, sizeof(or)) != 0)
+		return -EFAULT;
+
+	spin_lock_irqsave(&ref_lock, flags);
+
+	list_for_each_entry (ref, &reflist, reflist) {
+		if (ref->handle == f && ref->p == current)
+			break;
+		
+	}
+
+	/* This means deregister */
+	if (or.oh_signal == -1) {
+		if (ref) {
+			spin_lock(&hfp->hfp_lock);
+			list_del(&ref->file_list);
+			spin_unlock(&hfp->hfp_lock);
+			
+			list_del(&ref->reflist);
+			kfree(ref);
+		}
+	} else if (or.oh_signal <= _NSIG) {
+		int irq = map_openhype_xirr(or.oh_interrupt);
+		if(irq < 0) {
+			ret = -EINVAL;
+			goto abort;
+		} 
+
+
+		ref = kmalloc(sizeof(struct reflector), GFP_KERNEL);
+		ref->handle = f;
+		INIT_LIST_HEAD(&ref->reflist);
+		INIT_LIST_HEAD(&ref->file_list);
+
+		
+		ref->p = current;
+		ref->sig = or.oh_signal;
+		ref->interrupt = or.oh_interrupt;
+		ref->virq = irq;
+
+		ret = request_irq(irq, ref_handler, 0, 
+				  "OH Int Reflector", ref);
+
+		if(ret >= 0){
+			spin_lock(&hfp->hfp_lock);
+			list_add(&hfp->hfp_reflist, &ref->file_list);
+			spin_unlock(&hfp->hfp_lock);
+			list_add(&reflist, &ref->reflist);
+		} else {
+			kfree(ref);
+			ret = -EINVAL;
+		}
+		
+	} else {
+		ret = -EINVAL;
+	}
+abort:
+	spin_unlock_irqrestore(&ref_lock, flags);
+
+	return ret;
+}
+
+void irq_reflect_release(struct inode *i, struct file* f)
+{
+	struct hcall_file_priv *hfp = f->private_data;
+	
+	struct reflector *ref;
+	struct reflector *tmp;
+	unsigned long flags;
+	int ret;
+	spin_lock_irqsave(&ref_lock, flags);
+	
+	
+	list_for_each_entry_safe(ref, tmp, &hfp->hfp_reflist, file_list){
+		free_irq(ref->virq, ref);
+
+		list_del(&ref->reflist);
+		list_del(&ref->file_list);
+		kfree(ref);
+
+	}
+
+	spin_unlock_irqrestore(&ref_lock, flags);
+}
diff -urNpX diff.exclude linux--2.6.11/drivers/openhype/mem_hold.c linux--vhype--2.6.11/drivers/openhype/mem_hold.c
--- linux--2.6.11/drivers/openhype/mem_hold.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/openhype/mem_hold.c	2005-03-01 21:13:02.000000000 +0000
@@ -0,0 +1,111 @@
+/* /dev/hcall: device for userspace access to hypervisor, and memory.
+ *
+ * Copyright (C) 2004, Rusty Russell IBM Corporation.
+ */
+//#include <linux/hcall.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/openhype.h>
+#include <asm/errno.h>
+#include <asm/hvcall.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/setup.h>
+#include "openhype_internal.h"
+
+
+
+int do_config_mem_hold(struct file* f, void __user *arg)
+{
+	oh_mem_hold_args mh;
+	struct hcall_file_priv *hfp = (struct hcall_file_priv*)f->private_data;
+	struct hmem_share *hs = NULL;
+	int ret = 0;
+	char *ptr = NULL;
+	if (copy_from_user(&mh, arg, sizeof(mh)) != 0)
+		return -EFAULT;
+
+	spin_lock(&hfp->hfp_lock);
+
+	mh.size = PAGE_ALIGN(mh.size);
+
+	ret = -ENOMEM;
+	hs = kmalloc(sizeof(*hs), GFP_KERNEL);
+	if(hs) {
+		ptr = kmalloc(mh.size, GFP_KERNEL);
+		if(ptr) {
+			int i = 0;
+			for(; i < mh.size; i+= PAGE_SIZE){
+				SetPageReserved(virt_to_page(ptr + i));
+			}
+
+			mh.laddr = virt_to_phys(ptr);
+			hs->addr = (long)ptr;
+			hs->len  = mh.size;
+			ret = 0;
+		}
+	}
+	
+	spin_unlock(&hfp->hfp_lock);
+
+	if(ret == 0) {
+		if (copy_to_user(arg, &mh, sizeof(mh)) != 0) {
+			if(hs) kfree(hs);
+			if(ptr) kfree(ptr);
+			return -EFAULT;
+		}
+
+		INIT_LIST_HEAD(&hs->list);
+		list_add(&hfp->hfp_holdlist, &hs->list);
+	}
+
+	return ret;
+}
+
+int check_hold_mem(struct file *f, unsigned long start, unsigned long size)
+{
+	struct hcall_file_priv *hfp = (struct hcall_file_priv*)f->private_data;
+	struct hmem_share *hs;
+	int ret = 0;
+	spin_lock(&hfp->hfp_lock);
+
+	list_for_each_entry(hs, &hfp->hfp_holdlist, list) {
+		if(virt_to_phys((void*)hs->addr) <= start && 
+		   virt_to_phys((void*)hs->addr) + hs->len >= start + size) {
+			ret = 1;
+			break;
+		}
+	}
+	
+	spin_unlock(&hfp->hfp_lock);
+	return ret;
+}
+
+
+void mem_hold_release(struct inode *i, struct file* f)
+{
+	struct hcall_file_priv *hfp = f->private_data;
+	
+	struct hmem_share *ref;
+	struct hmem_share *tmp;
+	spin_lock(&hfp->hfp_lock);
+	
+	
+	list_for_each_entry_safe(ref, tmp, &hfp->hfp_holdlist, list){
+		int i = 0;
+		for(; i < ref->len; i+= PAGE_SIZE){
+			ClearPageReserved(virt_to_page(ref->addr + i));
+		}
+		list_del(&ref->list);
+
+		kfree((void*)ref->addr);
+		kfree(ref);
+	}
+
+	spin_unlock(&hfp->hfp_lock);
+}
diff -urNpX diff.exclude linux--2.6.11/drivers/openhype/openhype_internal.h linux--vhype--2.6.11/drivers/openhype/openhype_internal.h
--- linux--2.6.11/drivers/openhype/openhype_internal.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/openhype/openhype_internal.h	2005-03-01 21:13:02.000000000 +0000
@@ -0,0 +1,20 @@
+struct hmem_share
+{
+	struct list_head list;
+	long addr;
+	long len;
+};
+
+
+struct hcall_file_priv {
+	spinlock_t	 hfp_lock;
+	struct list_head hfp_reflist;	/* reflector request list */
+	struct list_head hfp_holdlist;  /* list of memory holds */
+};
+
+int do_config_reflect(struct file* f, void __user *arg);
+void irq_reflect_release(struct inode *i, struct file* f);
+
+int do_config_mem_hold(struct file* f, void __user *arg);
+void mem_hold_release(struct inode *i, struct file* f);
+int check_hold_mem(struct file *f, unsigned long start, unsigned long size);
diff -urNpX diff.exclude linux--2.6.11/drivers/scsi/Kconfig linux--vhype--2.6.11/drivers/scsi/Kconfig
--- linux--2.6.11/drivers/scsi/Kconfig	2005-03-01 17:45:21.000000000 +0000
+++ linux--vhype--2.6.11/drivers/scsi/Kconfig	2005-03-02 15:53:15.000000000 +0000
@@ -806,13 +806,22 @@ config SCSI_IPS
 
 config SCSI_IBMVSCSI
 	tristate "IBM Virtual SCSI support"
-	depends on PPC_PSERIES || PPC_ISERIES
+	depends on PPC_PSERIES || PPC_ISERIES || X86_HYPERVISOR
 	help
 	  This is the IBM POWER Virtual SCSI Client
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called ibmvscsic.
 
+config SCSI_IBMVSCSIS
+	tristate "IBM Virtual SCSI Target"
+	depends on PPC_PSERIES || PPC_ISERIES || X86_HYPERVISOR
+	help
+	  This is the IBM POWER Virtual SCSI Target
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ibmvscsic.
+
 config SCSI_INITIO
 	tristate "Initio 9100U(W) support"
 	depends on PCI && SCSI
diff -urNpX diff.exclude linux--2.6.11/drivers/scsi/Makefile linux--vhype--2.6.11/drivers/scsi/Makefile
--- linux--2.6.11/drivers/scsi/Makefile	2005-03-01 17:45:21.000000000 +0000
+++ linux--vhype--2.6.11/drivers/scsi/Makefile	2005-03-02 15:53:15.000000000 +0000
@@ -121,6 +121,7 @@ obj-$(CONFIG_SCSI_LASI700)	+= 53c700.o l
 obj-$(CONFIG_SCSI_NSP32)	+= nsp32.o
 obj-$(CONFIG_SCSI_IPR)		+= ipr.o
 obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsi/
+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsi/
 obj-$(CONFIG_SCSI_SATA_AHCI)	+= libata.o ahci.o
 obj-$(CONFIG_SCSI_SATA_SVW)	+= libata.o sata_svw.o
 obj-$(CONFIG_SCSI_ATA_PIIX)	+= libata.o ata_piix.o
diff -urNpX diff.exclude linux--2.6.11/drivers/scsi/ibmvscsi/Makefile linux--vhype--2.6.11/drivers/scsi/ibmvscsi/Makefile
--- linux--2.6.11/drivers/scsi/ibmvscsi/Makefile	2005-03-01 16:17:13.000000000 +0000
+++ linux--vhype--2.6.11/drivers/scsi/ibmvscsi/Makefile	2005-03-01 21:13:08.000000000 +0000
@@ -3,3 +3,6 @@ obj-$(CONFIG_SCSI_IBMVSCSI)	+= ibmvscsic
 ibmvscsic-y			+= ibmvscsi.o
 ibmvscsic-$(CONFIG_PPC_ISERIES)	+= iseries_vscsi.o 
 ibmvscsic-$(CONFIG_PPC_PSERIES)	+= rpa_vscsi.o 
+ibmvscsic-$(CONFIG_X86_HYPERVISOR)	+= rpa_vscsi.o 
+
+obj-$(CONFIG_SCSI_IBMVSCSIS)	+= ibmvscsis.o
diff -urNpX diff.exclude linux--2.6.11/drivers/scsi/ibmvscsi/ibmvscsis.c linux--vhype--2.6.11/drivers/scsi/ibmvscsi/ibmvscsis.c
--- linux--2.6.11/drivers/scsi/ibmvscsi/ibmvscsis.c	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/drivers/scsi/ibmvscsi/ibmvscsis.c	2005-03-03 20:28:11.000000000 +0000
@@ -0,0 +1,2888 @@
+#undef USE_64BITDIV
+/**************************************************************************/
+/* -*- -linux- -*-                                                        */
+/* IBM eServer i/pSeries Virtual SCSI Target Driver                       */
+/* Copyright (C) 2003 Dave Boutcher (boutcher@us.ibm.com) IBM Corp.       */
+/*                                                                        */
+/*  This program is free software; you can redistribute it and/or modify  */
+/*  it under the terms of the GNU General Public License as published by  */
+/*  the Free Software Foundation; either version 2 of the License, or     */
+/*  (at your option) any later version.                                   */
+/*                                                                        */
+/*  This program is distributed in the hope that it will be useful,       */
+/*  but WITHOUT ANY WARRANTY; without even the implied warranty of        */
+/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         */
+/*  GNU General Public License for more details.                          */
+/*                                                                        */
+/*  You should have received a copy of the GNU General Public License     */
+/*  along with this program; if not, write to the Free Software           */
+/*  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  */
+/*                                                                   USA  */
+/*                                                                        */
+/* This module contains the eServer virtual SCSI target code.  The driver */
+/* takes SRP requests from the virtual SCSI client (the linux version is  */
+/* int ibmvscsi.c, but there can be other clients, like AIX or OF) and    */
+/* passes them on to real devices in this system.                         */
+/*                                                                        */
+/* The basic hierarchy (and somewhat the organization of this file) is    */
+/* that SCSI CDBs are in SRPs are in CRQs.                                */
+/*                                                                        */
+/**************************************************************************/
+/*
+  TODO:
+  - Support redirecting SRP SCSI requests to a real SCSI driver
+*/
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/pagemap.h>
+#include <linux/dma-mapping.h>
+#include <linux/sched.h>
+#include <linux/blkdev.h>
+#include <linux/fs.h>
+#include <linux/bio.h>
+
+#include <asm/hvcall.h>
+#include <asm/vio.h>
+#include <asm/iommu.h>
+
+#include "../scsi.h"
+#include "viosrp.h"
+
+#define IBMVSCSIS_VERSION "1.2"
+
+MODULE_DESCRIPTION("IBM Virtual SCSI Target");
+MODULE_AUTHOR("Dave Boutcher");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(IBMVSCSIS_VERSION);
+
+static int ibmvscsis_debug = 0;
+
+/* These are fixed and come from the device tree...we
+ * just store them here to save getting them every time.
+ */
+static char system_id[64] = "";
+static char partition_name[97] = "UNKNOWN";
+static unsigned int partition_number = -1;
+
+/*
+ * Quick macro to enable/disable interrupts
+ * TODO: move to vio.h to be common with ibmvscsi.c
+ */
+#ifndef h_vio_signal
+#define h_vio_signal(ua, mode) \
+  plpar_hcall_norets(H_VIO_SIGNAL, ua, mode)
+#endif
+
+/* 
+ * These are indexes into the following table, and have to match!!!
+ */
+#define SENSE_SUCCESS       0
+#define SENSE_ABORT         1
+#define SENSE_INVALID_ID    2
+#define SENSE_DEVICE_FAULT  3
+#define SENSE_DEVICE_BUSY   4
+#define SENSE_UNIT_OFFLINE  5
+#define SENSE_INVALID_CMD   6
+#define SENSE_INTERMEDIATE  7
+#define SENSE_WRITE_PROT    8
+#define SENSE_INVALID_FIELD 9
+
+#define TARGET_MAX_NAME_LEN 128
+
+static unsigned char ibmvscsis_sense_data[][3] = {
+/*
+ * Sense key lookup table
+ * Format: SenseKey,AdditionalSenseCode,AdditionalSenseCodeQualifier
+ * Adapted from 3w-xxxx.h
+ */
+	{0x00, 0x00, 0x00},	/* Success           */
+	{0x0b, 0x00, 0x00},	/* Aborted command   */
+	{0x0b, 0x14, 0x00},	/* ID not found      */
+	{0x04, 0x00, 0x00},	/* Device fault      */
+	{0x0b, 0x00, 0x00},	/* Device busy       */
+	{0x02, 0x04, 0x00},	/* Unit offline      */
+	{0x05, 0x20, 0x00},	/* Invalid Command   */
+	{0x10, 0x00, 0x00},	/* Intermediate      */
+	{0x07, 0x27, 0x00},	/* Write Protected   */
+	{0x05, 0x24, 0x00},	/* Invalid field     */
+};
+
+/*
+ * SCSI defined structure for inquiry data
+ * TODO: Seral number is currently messed up if you do
+ *       scsiinfo.  I'm not sure why and I think it comes out of 
+ *       here
+ */
+struct inquiry_data {
+	u8 qual_type;
+	u8 rmb_reserve;
+	u8 version;
+	u8 aerc_naca_hisup_format;
+	u8 addl_len;
+	u8 sccs_reserved;
+	u8 bque_encserv_vs_multip_mchngr_reserved;
+	u8 reladr_reserved_linked_cmdqueue_vs;
+	char vendor[8];
+	char product[16];
+	char revision[4];
+	char vendor_specific[20];
+	char reserved1[2];
+	char version_descriptor[16];
+	char reserved2[22];
+	char unique[158];
+};
+
+extern int vio_num_address_cells;
+
+/* 
+ * an RPA command/response transport queue.  This is our structure
+ * that points to the actual queue.  feel free to modify this structure
+ * as needed
+ */
+struct crq_queue {
+	struct viosrp_crq *msgs;
+	int size, cur;
+	dma_addr_t msg_token;
+	spinlock_t lock;
+};
+
+/*
+ * This structure tracks our fundamental unit of work.  Whenever
+ * an SRP Information Unit (IU) arrives, we track all the good stuff
+ * here
+ */
+struct iu_entry {
+	union viosrp_iu *iu;
+	struct server_adapter *adapter;
+	struct list_head next;
+	dma_addr_t iu_token;
+	int aborted;
+	struct {
+		dma_addr_t remote_token;
+		char *data_buffer;
+		dma_addr_t data_token;
+		long data_len;
+		struct vdev *vd;
+		char in_use:1;
+		char diunder:1;
+		char diover:1;
+		char dounder:1;
+		char doover:1;
+		char write:1;
+		char linked:1;
+		int data_out_residual_count;
+		int data_in_residual_count;
+		int ioerr;
+	} req;
+};
+
+/* 
+ * a pool of ius for use 
+ */
+struct iu_pool {
+	spinlock_t lock;
+	struct list_head iu_entries;
+	struct iu_entry *list;
+	union viosrp_iu *iu_storage;
+	dma_addr_t iu_token;
+	u32 size;
+};
+
+/*
+ * Represents a single device that someone told us about
+ * that we treat as a LUN
+ */
+struct vdev {
+	struct list_head list;
+	char type;		/* 'B' for block, 'S' for SCSI */
+	atomic_t refcount;
+	int disabled;
+	u64 lun;
+	struct kobject kobj;
+	struct {
+		char device_name[TARGET_MAX_NAME_LEN];
+		struct block_device *bdev;
+		long blksize;
+		long blkbits;
+		long lastlba;
+		int ro;
+	} b;
+};
+
+/*
+ * Represents a bus.  target #'s in SCSI are 6 bits long,
+ * so you can have 64 targets per bus
+ */
+#define TARGETS_PER_BUS (64)
+#define BUS_PER_ADAPTER (8)
+struct vbus {
+	struct vdev *vdev[TARGETS_PER_BUS];
+	atomic_t num_targets;
+	struct kobject kobj;
+	int bus_num;
+};
+
+/*
+ * Buffer cache
+ */
+struct dma_buffer {
+	dma_addr_t token;
+	char *addr;
+	size_t len;
+};
+#define DMA_BUFFER_CACHE_SIZE (16)
+#define DMA_BUFFER_INIT_COUNT (4)
+#define DMA_BUFFER_INIT_LEN (PAGE_SIZE*16)
+
+/* all driver data associated with a host adapter */
+struct server_adapter {
+	struct device *dev;
+	struct vio_dev *dma_dev;
+	struct crq_queue queue;
+	struct work_struct crq_task;
+	struct tasklet_struct endio_tasklet;
+	struct iu_pool pool;
+	spinlock_t lock;
+	struct bio *bio_done;
+	struct bio *bio_donetail;
+	struct list_head inflight;
+	struct vbus *vbus[8];
+	int nvdevs;
+	char name[32];
+	unsigned long liobn;
+	unsigned long riobn;
+
+	atomic_t num_buses;
+	struct kobject stats_kobj;
+
+	/* This ugly expression allocates a bit array of 
+	 * in-use flags large enough for the number of buffers
+	 */
+	unsigned long dma_buffer_use[(DMA_BUFFER_CACHE_SIZE +
+				      sizeof(unsigned long) - 1)
+				     / sizeof(unsigned long)];
+	struct dma_buffer dma_buffer[DMA_BUFFER_CACHE_SIZE];
+
+	/* Statistics only */
+	atomic_t iu_count;	/* number allocated */
+	atomic_t bio_count;	/* number allocated */
+	atomic_t crq_processed;
+	atomic_t interrupts;
+	atomic_t read_processed;
+	atomic_t write_processed;
+	atomic_t buffers_allocated;
+	atomic_t errors;
+};
+
+/* 
+ * Forward declarations
+ */
+static long send_rsp(struct iu_entry *iue, int status);
+
+/*
+ * The following are lifted from usb.h
+ */
+#define DEBUG 1
+#ifdef DEBUG
+#define dbg(format, arg...) if (ibmvscsis_debug) printk(KERN_WARNING __FILE__ ": " format , ## arg)
+#else
+#define dbg(format, arg...) do {} while (0)
+#endif
+#define err(format, arg...) printk(KERN_ERR "ibmvscsis: " format , ## arg)
+#define info(format, arg...) printk(KERN_INFO "ibmvscsis: " format  , ## arg)
+#define warn(format, arg...) printk(KERN_WARNING "ibmvscsis: " format , ## arg)
+
+/* ==============================================================
+ * Utility Routines
+ * ==============================================================
+ */
+/*
+ * return an 8 byte lun given a bus, target, lun.  
+ * Today this only supports single level luns.  Should we add a level or a
+ * 64 bit LUN as input to support multi-level luns?
+ */
+u64 make_lun(unsigned int bus, unsigned int target, unsigned int lun)
+{
+	u16 result = (0x8000 |
+		      ((target & 0x003f) << 8) |
+		      ((bus & 0x0007) << 5) | (lun & 0x001f));
+	return ((u64) result) << 48;
+}
+
+/*
+ * Given an 8 byte LUN, return the first level bus/target/lun.
+ * Today this doesn't support multi-level LUNs
+ */
+
+#if __LITTLE_ENDIAN
+#define GETBUS(x) ((int)((((u64)(x)) >> 5) & 0x0007))
+#define GETTARGET(x) ((int)((((u64)(x)) >> 8) & 0x003f))
+#define GETLUN(x) ((int)((((u64)(x)) >> 0) & 0x001f))
+
+#define LUN_INDEX 3
+
+#else
+#define GETBUS(x) ((int)((((u64)(x)) >> 53) & 0x0007))
+#define GETTARGET(x) ((int)((((u64)(x)) >> 56) & 0x003f))
+#define GETLUN(x) ((int)((((u64)(x)) >> 48) & 0x001f))
+
+#define LUN_INDEX 0
+
+#endif
+
+static u8 getcontrolbyte(u8 * cdb)
+{
+	return cdb[COMMAND_SIZE(cdb[0]) - 1];
+}
+
+static u8 getlink(struct iu_entry *iue)
+{
+	return (getcontrolbyte(iue->iu->srp.cmd.cdb) & 0x01);
+}
+
+/*
+ * Given an SRP, figure out the data in length
+ */
+static int did_len(struct srp_cmd *cmd)
+{
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		offset += 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		offset += sizeof(struct memory_descriptor);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		offset += sizeof(struct indirect_descriptor)
+		    +
+		    ((cmd->data_out_count -
+		      1) * sizeof(struct memory_descriptor));
+		break;
+	default:
+		err("client error. Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	switch (cmd->data_in_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		return md->length;
+	case SRP_INDIRECT_BUFFER:
+		id = (struct indirect_descriptor *)(cmd->additional_data +
+						    offset);
+		return id->total_length;
+	default:
+		err("client error.  Invalid data_in_format %d\n",
+		    cmd->data_in_format);
+		return 0;
+	}
+}
+
+/* 
+ * We keep a pool of IUs, this routine builds the pool.  The pool is 
+ * per-adapter.  The size of the pool is negotiated as part of the SRP
+ * login, where we negotiate the number of requests (IUs) the client
+ * can send us.  This routine is not synchronized.
+ */
+static int initialize_iu_pool(struct server_adapter *adapter, int size)
+{
+	struct iu_pool *pool = &adapter->pool;
+	int i;
+
+	pool->size = size;
+	pool->lock = SPIN_LOCK_UNLOCKED;
+	INIT_LIST_HEAD(&pool->iu_entries);
+
+	pool->list = kmalloc(pool->size * sizeof(*pool->list), GFP_KERNEL);
+	if (!pool->list) {
+		err("Error: Cannot allocate memory for IU list\n");
+		return -ENOMEM;
+	}
+	memset(pool->list, 0x00, pool->size * sizeof(*pool->list));
+
+	pool->iu_storage =
+	    dma_alloc_coherent(adapter->dev,
+			       pool->size * sizeof(*pool->iu_storage),
+			       &pool->iu_token, 0);
+	if (!pool->iu_storage) {
+		err("Error: Cannot allocate memory for IU pool\n");
+		kfree(pool->list);
+		return -ENOMEM;
+	}
+
+	for (i = 0; i < pool->size; ++i) {
+		pool->list[i].iu = pool->iu_storage + i;
+		pool->list[i].iu_token =
+		    pool->iu_token + sizeof(*pool->iu_storage) * i;
+		pool->list[i].adapter = adapter;
+		list_add_tail(&pool->list[i].next, &pool->iu_entries);
+	}
+
+	return 0;
+}
+
+/*
+ * Free the pool we allocated in initialize_iu_pool
+ */
+static void release_iu_pool(struct server_adapter *adapter)
+{
+	struct iu_pool *pool = &adapter->pool;
+	int i, in_use = 0;
+	for (i = 0; i < pool->size; ++i)
+		if (pool->list[i].req.in_use)
+			++in_use;
+	if (in_use)
+		err("Releasing event pool with %d events still in use?\n", 
+		    in_use);
+	kfree(pool->list);
+	dma_free_coherent(adapter->dev, pool->size * sizeof(*pool->iu_storage),
+			  pool->iu_storage, pool->iu_token);
+}
+
+/*
+ * Get an IU from the pool.  Return NULL of the pool is empty.  This
+ * routine is syncronized by a lock.  The routine sets all the important
+ * fields to 0
+ */
+static struct iu_entry *get_iu(struct server_adapter *adapter)
+{
+	struct iu_entry *e;
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->pool.lock, flags);
+	if (!list_empty(&adapter->pool.iu_entries)) {
+		e = list_entry(adapter->pool.iu_entries.next, struct iu_entry,
+			       next);
+		list_del(adapter->pool.iu_entries.next);
+
+		if (e->req.in_use) {
+			err("Found in-use iue in free pool!");
+		}
+
+		memset(&e->req, 0x00, sizeof(e->req));
+
+		e->req.in_use = 1;
+	} else {
+		e = NULL;
+	}
+
+	spin_unlock_irqrestore(&adapter->pool.lock, flags);
+	atomic_inc(&adapter->iu_count);
+	return e;
+}
+
+/* 
+ * Return an IU to the pool.  This routine is synchronized
+ */
+static void free_iu(struct iu_entry *iue)
+{
+	unsigned long flags;
+	if (iue->req.vd) {
+		atomic_dec(&iue->req.vd->refcount);
+	}
+
+	spin_lock_irqsave(&iue->adapter->pool.lock, flags);
+	if (iue->req.in_use == 0) {
+		warn("Internal error, freeing iue twice!\n");
+	} else {
+		iue->req.in_use = 0;
+		list_add_tail(&iue->next, &iue->adapter->pool.iu_entries);
+	}
+	spin_unlock_irqrestore(&iue->adapter->pool.lock, flags);
+	atomic_dec(&iue->adapter->iu_count);
+}
+
+/*
+ * Get a CRQ from the inter-partition queue.
+ */
+static struct viosrp_crq *crq_queue_next_crq(struct crq_queue *queue)
+{
+	struct viosrp_crq *crq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock, flags);
+	crq = &queue->msgs[queue->cur];
+	if (crq->valid & 0x80) {
+		if (++queue->cur == queue->size)
+			queue->cur = 0;
+	} else
+		crq = NULL;
+	spin_unlock_irqrestore(&queue->lock, flags);
+
+	return crq;
+}
+
+#ifndef CONFIG_X86_HYPERVISOR
+/* 
+ * Make the RDMA hypervisor call.  There should be a better way to do this
+ * than inline assembler.
+ * TODO: Fix the inline assembler
+ */
+static long h_copy_rdma(long length,
+			unsigned long sliobn, unsigned long slioba,
+			unsigned long dliobn, unsigned long dlioba)
+{
+	long lpar_rc = 0;
+	__asm__ __volatile__(" li 3,0x110 \n\t"
+			     " mr 4, %1 \n\t"
+			     " mr 5, %2 \n\t"
+			     " mr 6, %3 \n\t"
+			     " mr 7, %4 \n\t"
+			     " mr 8, %5 \n\t"
+			     " .long 0x44000022 \n\t"
+			     " mr %0, 3 \n\t":"=&r"(lpar_rc)
+			     :"r"(length), "r"(sliobn), "r"(slioba),
+			     "r"(dliobn), "r"(dlioba)
+			     :"r0", "r3", "r4", "r5", "r6", "r7", "r8", "cr0",
+			     "cr1", "ctr", "xer", "memory");
+	return lpar_rc;
+}
+#else
+static long h_copy_rdma(long length,
+			unsigned long sliobn, unsigned long slioba,
+			unsigned long dliobn, unsigned long dlioba)
+{
+	return hcall_copy_rdma(NULL, length, sliobn, slioba, dliobn, dlioba);
+}
+#endif
+
+/*
+ * Send an SRP to another partition using the CRQ.
+ */
+static int send_srp(struct iu_entry *iue, u64 length)
+{
+	long rc, rc1;
+	union {
+		struct viosrp_crq cooked;
+		u64 raw[2];
+	} crq;
+
+	/* First copy the SRP */
+	rc = h_copy_rdma(length,
+			 iue->adapter->liobn,
+			 iue->iu_token,
+			 iue->adapter->riobn, iue->req.remote_token);
+
+	if (rc) {
+		err("Error %ld transferring data to client\n", rc);
+	}
+
+	crq.cooked.valid = 0x80;
+	crq.cooked.format = VIOSRP_SRP_FORMAT;
+	crq.cooked.reserved = 0x00;
+	crq.cooked.timeout = 0x00;
+	crq.cooked.IU_length = length;
+	crq.cooked.IU_data_ptr = iue->iu->srp.generic.tag;
+
+	if (rc == 0) {
+		crq.cooked.status = 0x99;	/* TODO: is this right? */
+	} else {
+		crq.cooked.status = 0x00;
+	}
+
+	rc1 =
+	    plpar_hcall_norets(H_SEND_CRQ, iue->adapter->dma_dev->unit_address,
+			       crq.raw[0], crq.raw[1]);
+
+	if (rc1) {
+		err("Error %ld sending response to client\n", rc1);
+		return rc1;
+	}
+
+	return rc;
+}
+
+/*
+ * Send data to a single SRP memory descriptor
+ * Returns amount of data sent, or negative value on error
+ */
+static long send_md_data(dma_addr_t stoken, int len,
+			 struct memory_descriptor *md,
+			 struct server_adapter *adapter)
+{
+	int tosend;
+	long rc;
+
+	if (len < md->length)
+		tosend = len;
+	else
+		tosend = md->length;
+
+	rc = h_copy_rdma(tosend,
+			 adapter->liobn,
+			 stoken, adapter->riobn, md->virtual_address);
+
+	if (rc != H_Success) {
+		err(" Error %ld transferring data to client\n", rc);
+		return -1;
+	}
+
+	return tosend;
+}
+
+/*
+ * Send data to the SRP data_in buffers
+ * Returns amount of data sent, or negative value on error
+ */
+static long send_cmd_data(dma_addr_t stoken, int len, struct iu_entry *iue)
+{
+	struct srp_cmd *cmd = &iue->iu->srp.cmd;
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = 0;
+	int total_length = 0;
+	int i;
+	int thislen;
+	int bytes;
+	int sentlen = 0;
+
+	offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		offset += 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		offset += sizeof(struct memory_descriptor);
+		break;
+	case SRP_INDIRECT_BUFFER:
+		offset += sizeof(struct indirect_descriptor)
+		    +
+		    ((cmd->data_out_count -
+		      1) * sizeof(struct memory_descriptor));
+		break;
+	default:
+		err("client error: Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	switch (cmd->data_in_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		sentlen = send_md_data(stoken, len, md, iue->adapter);
+		len -= sentlen;
+		if (len) {
+			iue->req.diover = 1;
+			iue->req.data_in_residual_count = len;
+		}
+		return sentlen;
+	}
+
+	if (cmd->data_in_format != SRP_INDIRECT_BUFFER) {
+		err("client error Invalid data_in_format %d\n",
+		    cmd->data_in_format);
+		return 0;
+	}
+
+	id = (struct indirect_descriptor *)(cmd->additional_data + offset);
+
+	total_length = id->total_length;
+
+	/* Work through the partial memory descriptor list */
+	for (i = 0; ((i < cmd->data_in_count) && (len)); i++) {
+		if (len > id->list[i].length) {
+			thislen = id->list[i].length;
+		} else {
+			thislen = len;
+		}
+
+		bytes =
+		    send_md_data(stoken + sentlen, thislen, id->list + i,
+				 iue->adapter);
+		if (bytes < 0)
+			return bytes;
+
+		if (bytes != thislen) {
+			warn("Error: Tried to send %d, sent %d\n", thislen,
+			     bytes);
+		}
+
+		sentlen += bytes;
+		total_length -= bytes;
+		len -= bytes;
+	}
+
+	if (len) {
+		iue->req.diover = 1;
+		iue->req.data_in_residual_count = len;
+	}
+
+	return sentlen;
+}
+
+/*
+ * Get data from the other partition from a single SRP memory descriptor
+ * Returns amount of data sent, or negative value on error
+ */
+static long get_md_data(dma_addr_t ttoken, int len,
+			struct memory_descriptor *md,
+			struct server_adapter *adapter)
+{
+	int toget;
+	long rc;
+
+	if (len < md->length)
+		toget = len;
+	else
+		toget = md->length;
+
+	rc = h_copy_rdma(toget,
+			 adapter->riobn,
+			 md->virtual_address, adapter->liobn, ttoken);
+
+	if (rc != H_Success) {
+		err("Error %ld transferring data to client\n", rc);
+		return -1;
+	}
+
+	return toget;
+}
+
+/*
+ * Get data from an SRP data in area.
+ * Returns amount of data sent, or negative value on error
+ */
+static long get_cmd_data(dma_addr_t stoken, int len, struct iu_entry *iue)
+{
+	struct srp_cmd *cmd = &iue->iu->srp.cmd;
+	struct memory_descriptor *md;
+	struct indirect_descriptor *id;
+	int offset = 0;
+	int total_length = 0;
+	int i;
+	int thislen;
+	int bytes;
+	int sentlen = 0;
+
+	offset = cmd->additional_cdb_len * 4;
+
+	switch (cmd->data_out_format) {
+	case SRP_NO_BUFFER:
+		return 0;
+		break;
+	case SRP_DIRECT_BUFFER:
+		md = (struct memory_descriptor *)(cmd->additional_data +
+						  offset);
+		return get_md_data(stoken, len, md, iue->adapter);
+		break;
+	}
+
+	if (cmd->data_out_format != SRP_INDIRECT_BUFFER) {
+		err("client error: Invalid data_out_format %d\n",
+		    cmd->data_out_format);
+		return 0;
+	}
+
+	id = (struct indirect_descriptor *)(cmd->additional_data + offset);
+
+	total_length = id->total_length;
+
+	/* Work through the partial memory descriptor list */
+	for (i = 0; ((i < cmd->data_out_count) && (len)); i++) {
+		if (len > id->list[i].length) {
+			thislen = id->list[i].length;
+		} else {
+			thislen = len;
+		}
+
+		bytes =
+		    get_md_data(stoken + sentlen, thislen, id->list + i,
+				iue->adapter);
+		if (bytes < 0)
+			return bytes;
+
+		if (bytes != thislen) {
+			err("Partial data sent to client (%d/%d)\n", bytes, thislen);
+		}
+
+		sentlen += bytes;
+		total_length -= bytes;
+		len -= bytes;
+	}
+
+	return sentlen;
+}
+
+/*
+ * Get some data buffers to start.  This doesn't lock the adapter structure!
+ */
+static void init_data_buffer(struct server_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < DMA_BUFFER_INIT_COUNT; i++) {
+		if (adapter->dma_buffer[i].addr == NULL) {
+			adapter->dma_buffer[i].addr = (char *)
+			    dma_alloc_coherent(adapter->dev,
+					       DMA_BUFFER_INIT_LEN,
+					       &adapter->dma_buffer[i].token,
+					       0);
+			adapter->dma_buffer[i].len = DMA_BUFFER_INIT_LEN;
+			dbg("data buf %p token %8.8x, len %ld\n",
+			    adapter->dma_buffer[i].addr,
+			    adapter->dma_buffer[i].token,
+			    (unsigned long)adapter->dma_buffer[i].len);
+			atomic_inc(&adapter->buffers_allocated);
+		}
+	}
+
+	return;
+}
+
+/*
+ * Get a memory buffer that includes a mapped TCE.  
+ */
+static void get_data_buffer(char **buffer, dma_addr_t * data_token, size_t len,
+			    struct server_adapter *adapter)
+{
+	int i;
+
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if ((adapter->dma_buffer[i].addr) &&
+		    (adapter->dma_buffer[i].len >= len) &&
+		    (!test_and_set_bit(i, adapter->dma_buffer_use))) {
+			*buffer = adapter->dma_buffer[i].addr;
+			*data_token = adapter->dma_buffer[i].token;
+			return;
+		}
+	}
+
+	/* Couldn't get a buffer!  Try and get a new one */
+	*buffer = (char *)dma_alloc_coherent(adapter->dev, len, data_token, 0);
+	atomic_inc(&adapter->buffers_allocated);
+	dbg("get:  %p, %8.8x, %ld\n", *buffer, *data_token, (unsigned long)len);
+	return;
+}
+
+/*
+ * Free a memory buffer that includes a mapped TCE.  
+ */
+static void free_data_buffer(char *buffer, dma_addr_t data_token, size_t len,
+			     struct server_adapter *adapter)
+{
+	int i;
+
+	/* First see if this buffer is already in the cache */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (adapter->dma_buffer[i].addr == buffer) {
+			if (adapter->dma_buffer[i].token != data_token) {
+				err("Inconsistent data buffer pool info!\n");
+			}
+			if (!test_and_clear_bit(i, adapter->dma_buffer_use)) {
+				err("Freeing data buffer twice!\n");
+			}
+			return;
+		}
+	}
+
+	/* See if there is an empty slot in our list */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (!test_and_set_bit(i, adapter->dma_buffer_use)) {
+			if (adapter->dma_buffer[i].addr == NULL) {
+				adapter->dma_buffer[i].addr = buffer;
+				adapter->dma_buffer[i].token = data_token;
+				adapter->dma_buffer[i].len = len;
+				clear_bit(i, adapter->dma_buffer_use);
+				return;
+			} else {
+				clear_bit(i, adapter->dma_buffer_use);
+			}
+		}
+	}
+
+	/* Now see if there is a smaller buffer we should throw out */
+	for (i = 0; i < DMA_BUFFER_CACHE_SIZE; i++) {
+		if (!test_and_set_bit(i, adapter->dma_buffer_use)) {
+			if (adapter->dma_buffer[i].len < len) {
+				dbg("fre1: %p, %8.8x, %ld\n",
+				    adapter->dma_buffer[i].addr,
+				    adapter->dma_buffer[i].token,
+				    (unsigned long)adapter->dma_buffer[i].len);
+
+				dma_free_coherent(adapter->dev,
+						  adapter->dma_buffer[i].len,
+						  adapter->dma_buffer[i].addr,
+						  adapter->dma_buffer[i].token);
+
+				atomic_dec(&adapter->buffers_allocated);
+
+				adapter->dma_buffer[i].addr = buffer;
+				adapter->dma_buffer[i].token = data_token;
+				adapter->dma_buffer[i].len = len;
+				clear_bit(i, adapter->dma_buffer_use);
+				return;
+			} else {
+				clear_bit(i, adapter->dma_buffer_use);
+			}
+		}
+	}
+
+	/* No space to cache this.  Give it back to the kernel */
+	dbg("fre2: %p, %8.8x, %ld\n", buffer, data_token, (unsigned long)len);
+	dma_free_coherent(adapter->dev, len, buffer, data_token);
+	atomic_dec(&adapter->buffers_allocated);
+}
+
+/*
+ * Release all the data buffers
+ */
+static void release_data_buffer(struct server_adapter *adapter)
+{
+	int i;
+	int free_in_use = 0;
+
+	for (i = 0; i < DMA_BUFFER_INIT_COUNT; i++) {
+		if (adapter->dma_buffer[i].addr != NULL) {
+			if (test_bit(i, adapter->dma_buffer_use)) {
+				free_in_use++;
+			}
+			dma_free_coherent(adapter->dev,
+					  adapter->dma_buffer[i].len,
+					  adapter->dma_buffer[i].addr,
+					  adapter->dma_buffer[i].token);
+
+			atomic_dec(&adapter->buffers_allocated);
+		}
+	}
+
+	if (free_in_use) {
+		err("Freeing %d in-use data buffers\n", free_in_use);
+	}
+	return;
+}
+
+/*
+ * the routine that gets called on end_io of our bios.  We basically
+ * schedule the processing to be done in our task, since we don't want
+ * do things like RDMA in someone else's interrupt handler
+ *
+ * Each iu request may result in multiple bio requests.  only proceed
+ * when all the bio requests have done.
+ */
+static int ibmvscsis_end_io(struct bio *bio, unsigned int nbytes, int error)
+{
+	struct iu_entry *iue = (struct iu_entry *)bio->bi_private;
+	struct server_adapter *adapter = iue->adapter;
+	unsigned long flags;
+
+	if (bio->bi_size)
+		return 1;
+
+	if (!test_bit(BIO_UPTODATE, &bio->bi_flags)) {
+		iue->req.ioerr = 1;
+	};
+
+	/* Add the bio to the done queue */
+	spin_lock_irqsave(&adapter->lock, flags);
+	if (adapter->bio_donetail) {
+		adapter->bio_donetail->bi_next = bio;
+		adapter->bio_donetail = bio;
+	} else
+		adapter->bio_done = adapter->bio_donetail = bio;
+	bio->bi_next = NULL;
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/* Schedule the task */
+	tasklet_schedule(&adapter->endio_tasklet);
+
+	return 0;
+}
+
+/*
+ * Find the vdev structure from the LUN field in an SRP IUE
+ * Note that this routine bumps a refcount field in the vdev.
+ * Normally this is done when free_iu is called.
+ */
+static struct vdev *find_device(struct iu_entry *iue)
+{
+	u16 *lun = (u16 *) & iue->iu->srp.cmd.lun;
+	u32 bus = (lun[LUN_INDEX] & 0x00E0) >> 5;
+	u32 target = (lun[LUN_INDEX] & 0x3F00) >> 8;
+	u32 slun = (lun[LUN_INDEX] & 0x001F);
+	struct vdev *vd;
+	unsigned long flags;
+
+	/* If asking for a lun other than 0, return nope */
+	if (slun) {
+		return NULL;
+	}
+
+	/* Only from SRP CMD */
+	if (iue->iu->srp.generic.type != SRP_CMD_TYPE)
+		return NULL;
+
+	/* if not a recognized LUN format, return NULL */
+	if ((lun[LUN_INDEX] & 0xC000) != 0x8000)
+		return NULL;
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+	if (iue->adapter->vbus[bus] == NULL) {
+		spin_unlock_irqrestore(&iue->adapter->lock, flags);
+		return NULL;
+	}
+
+	vd = iue->adapter->vbus[bus]->vdev[target];
+
+	if ((vd == NULL) || (vd->disabled)) {
+		spin_unlock_irqrestore(&iue->adapter->lock, flags);
+		return NULL;
+	}
+
+	if (vd) {
+		atomic_inc(&vd->refcount);
+	}
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	return vd;
+}
+
+/*
+ * Process BH buffer completions.  When the end_io routine gets called 
+ * we queue the bio on an internal queue and start a task to process them
+ */
+static void endio_task(unsigned long data)
+{
+	struct server_adapter *adapter = (struct server_adapter *)data;
+	struct iu_entry *iue = NULL;
+	struct bio *bio;
+	int bytes;
+	unsigned long flags;
+
+	do {
+		spin_lock_irqsave(&adapter->lock, flags);
+		if ((bio = adapter->bio_done)) {
+			if (bio == adapter->bio_donetail)
+				adapter->bio_donetail = NULL;
+			adapter->bio_done = bio->bi_next;
+			bio->bi_next = NULL;
+		}
+		if (bio) {
+			/* Remove this iue from the in-flight list */
+			iue = (struct iu_entry *)bio->bi_private;
+			if (!iue->req.in_use) {
+				err("Internal error! freed iue in bio!!!\n");
+				spin_unlock_irqrestore(&adapter->lock, flags);
+				return;
+			}
+				
+			list_del(&iue->next);
+		}
+
+		spin_unlock_irqrestore(&adapter->lock, flags);
+
+		if (bio) {
+			/* Send back the SRP and data if this request was NOT
+			 * aborted 
+			 */
+			if (!iue->aborted) {
+
+				if (!iue->req.ioerr) {
+					/* return data if this was a read */
+					if (!iue->req.write) {
+						bytes =
+						    send_cmd_data(iue->req.
+								  data_token,
+								  iue->req.
+								  data_len,
+								  iue);
+						if (bytes != iue->req.data_len) {
+							err("Error sending data "
+							    "on response "
+							    "(tried %d, sent %d\n", 
+							    bio->bi_size, bytes);
+							send_rsp(iue,
+								 SENSE_ABORT);
+						} else {
+							send_rsp(iue,
+								 SENSE_SUCCESS);
+						}
+					} else {
+						send_rsp(iue, SENSE_SUCCESS);
+					}
+				} else {
+					err("Block operation failed\n");
+					print_command(iue->iu->srp.cmd.cdb);
+					send_rsp(iue, SENSE_DEVICE_FAULT);
+				}
+			}
+
+			spin_lock_irqsave(&adapter->lock, flags);
+			free_data_buffer(iue->req.data_buffer,
+					 iue->req.data_token, iue->req.data_len,
+					 adapter);
+			spin_unlock_irqrestore(&adapter->lock, flags);
+
+			free_iu(iue);
+
+			bio_put(bio);
+			atomic_dec(&adapter->bio_count);
+		}
+	} while (bio);
+}
+
+/* ==============================================================
+ * SCSI Command Emulation Routines
+ * ==============================================================
+ */
+
+/*
+ * Process an inquiry SCSI Command
+ */
+static void process_inquiry(struct iu_entry *iue)
+{
+	struct inquiry_data *id;
+	dma_addr_t data_token;
+	u8 *raw_id;
+	int bytes;
+
+	id = (struct inquiry_data *)dma_alloc_coherent(iue->adapter->dev,
+						       sizeof(*id),
+						       &data_token, 0);
+	raw_id = (u8 *)id;
+	memset(id, 0x00, sizeof(*id));
+
+	/* If we have a valid device */
+	if (iue->req.vd) {
+		/* Standard inquiry page */
+		if ((iue->iu->srp.cmd.cdb[1] == 0x00) &&
+		    (iue->iu->srp.cmd.cdb[2] == 0x00)) {
+			dbg("  inquiry returning device\n");
+			id->qual_type = 0x00;	/* Direct Access    */
+			id->rmb_reserve = 0x00;	/* TODO: CD is removable  */
+			id->version = 0x84;	/* ISO/IE                 */
+			id->aerc_naca_hisup_format = 0x22;/* naca & fmt 0x02 */
+			id->addl_len = sizeof(*id) - 4;	
+			id->bque_encserv_vs_multip_mchngr_reserved = 0x00;
+			id->reladr_reserved_linked_cmdqueue_vs = 0x02;/*CMDQ*/
+			memcpy(id->vendor, "IBM     ", 8);
+			memcpy(id->product, "VSCSI blkdev    ", 16);
+			memcpy(id->revision, "0001", 4);
+			snprintf(id->unique,sizeof(id->unique),
+				 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
+				 system_id,
+				 partition_number,
+				 iue->adapter->dma_dev->unit_address,
+				 GETBUS(iue->req.vd->lun),
+				 GETTARGET(iue->req.vd->lun),
+				 GETLUN(iue->req.vd->lun));
+		} else if ((iue->iu->srp.cmd.cdb[1] == 0x01) &&
+			   (iue->iu->srp.cmd.cdb[2] == 0x00)) {
+			/* Supported VPD pages */
+			raw_id[0] = 0x00; /* qualifier & type */
+			raw_id[1] = 0x80; /* page */
+			raw_id[2] = 0x00; /* reserved */
+			raw_id[3] = 0x03; /* length */
+			raw_id[4] = 0x00; /* page 0 */
+			raw_id[5] = 0x80; /* serial number page */
+		} else if ((iue->iu->srp.cmd.cdb[1] == 0x01) &&
+			   (iue->iu->srp.cmd.cdb[2] == 0x80)) {
+			/* serial number page */
+			raw_id[0] = 0x00; /* qualifier & type */
+			raw_id[1] = 0x80; /* page */
+			raw_id[2] = 0x00; /* reserved */
+			snprintf((char *)(raw_id+4),
+				 sizeof(*id)-4,
+				 "IBM-VSCSI-%s-P%d-%x-%d-%d-%d\n",
+				 system_id,
+				 partition_number,
+				 iue->adapter->dma_dev->unit_address,
+				 GETBUS(iue->req.vd->lun),
+				 GETTARGET(iue->req.vd->lun),
+				 GETLUN(iue->req.vd->lun));
+			raw_id[3] = strlen((char *)raw_id+4);
+		} else {
+			/* Some unsupported data */
+			send_rsp(iue, SENSE_INVALID_FIELD);
+			free_iu(iue);
+			return;
+		}
+	} else {
+		dbg("  inquiry returning no device\n");
+		id->qual_type = 0x7F;	/* Not supported, no device */
+	}
+
+	bytes = send_cmd_data(data_token, sizeof(*id), iue);
+
+	dma_free_coherent(iue->adapter->dev, sizeof(*id), id, data_token);
+
+	if (bytes < 0) {
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+	} else {
+		send_rsp(iue, SENSE_SUCCESS);
+	}
+
+	free_iu(iue);
+}
+
+/*
+ * Handle an I/O.  Called by WRITE6, WRITE10, etc
+ */
+static void process_rw(char *cmd, int rw, struct iu_entry *iue, long lba,
+		       long len)
+{
+	char *buffer;
+	struct bio *bio;
+	int bytes;
+	int num_biovec;
+	int cur_biovec;
+	long flags;
+
+#ifdef USE_64BITDIV
+	dbg("%s %16.16lx[%d:%d:%d][%s] lba %ld len %ld reladr %d link %d\n",
+	    cmd,
+	    iue->iu->srp.cmd.lun,
+	    GETBUS(iue->iu->srp.cmd.lun),
+	    GETTARGET(iue->iu->srp.cmd.lun),
+	    GETLUN(iue->iu->srp.cmd.lun),
+	    iue->req.vd->b.device_name,
+	    lba,
+#ifdef USE_64BITDIV
+	    len / iue->req.vd->b.blksize,
+#else
+	    len >> iue->req.vd->b.blkbits,
+#endif
+	    iue->iu->srp.cmd.cdb[1] & 0x01, iue->req.linked);
+#else
+	dbg("%s %16.16lx[%d:%d:%d][%s] lba %ld len %ld reladr %d link %d\n",
+	    cmd,
+	    (long)iue->iu->srp.cmd.lun,
+	    GETBUS(iue->iu->srp.cmd.lun),
+	    GETTARGET(iue->iu->srp.cmd.lun),
+	    GETLUN(iue->iu->srp.cmd.lun),
+	    iue->req.vd->b.device_name,
+	    lba,
+	    len >> iue->req.vd->b.blkbits,
+	    iue->iu->srp.cmd.cdb[1] & 0x01, iue->req.linked);
+#endif
+
+	if (rw == WRITE) {
+		atomic_inc(&iue->adapter->write_processed);
+	} else if (rw == READ) {
+		atomic_inc(&iue->adapter->read_processed);
+	} else {
+		err("Major internal error...rw not read or write\n");
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+
+		free_iu(iue);
+		return;
+	}
+
+	if (len == 0) {
+		warn("Zero length I/O\n");
+		send_rsp(iue, SENSE_INVALID_CMD);
+
+		free_iu(iue);
+		return;
+	}
+
+	/* Writing to a read-only device */
+	if ((rw == WRITE) && (iue->req.vd->b.ro)) {
+		warn("WRITE to read-only device\n");
+		send_rsp(iue, SENSE_WRITE_PROT);
+
+		free_iu(iue);
+		return;
+	}
+
+	get_data_buffer(&buffer, &iue->req.data_token, len, iue->adapter);
+	iue->req.data_buffer = buffer;
+	iue->req.data_len = len;
+	if (buffer == NULL) {
+		err("Not able to get a data buffer (%lu pages)\n",
+		    len / PAGE_SIZE);
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+
+		free_iu(iue);
+		return;
+	}
+
+	/* if reladr */
+	if (iue->iu->srp.cmd.cdb[1] & 0x01) {
+		lba = lba + iue->req.vd->b.lastlba;
+	}
+
+	/* If this command is linked, Keep this lba */
+	if (iue->req.linked) {
+		iue->req.vd->b.lastlba = lba;
+	} else {
+		iue->req.vd->b.lastlba = 0;
+	}
+
+	if (rw == WRITE) {
+		iue->req.write = 1;
+		/* Get the data */
+		bytes = get_cmd_data(iue->req.data_token, len, iue);
+		if (bytes != len) {
+			err("Error transferring data\n");
+			send_rsp(iue, SENSE_DEVICE_FAULT);
+
+			free_iu(iue);
+			return;
+		}
+	}
+
+	num_biovec = (len - 1) / PAGE_CACHE_SIZE + 1;
+
+	bio = bio_alloc(GFP_ATOMIC, num_biovec);
+	if (!bio) {
+		/* Ouch.  couldn't get a bio.  Mark this I/O as 
+		 * in error, then decrement the outstanding bio.
+		 * If there are still outstanding bio, they will send
+		 * the error and free the IU.  If there are none, we
+		 * should do it here
+		 */
+		iue->req.ioerr = 1;
+		err("Not able to allocate a bio\n");
+		send_rsp(iue, SENSE_DEVICE_FAULT);
+		free_iu(iue);
+		return;
+	}
+
+	iue->aborted = 0;
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+	list_add_tail(&iue->next, &iue->adapter->inflight);
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	atomic_inc(&iue->adapter->bio_count);
+	bio->bi_size = len;
+	bio->bi_bdev = iue->req.vd->b.bdev;
+	bio->bi_sector = lba;
+	bio->bi_end_io = &ibmvscsis_end_io;
+	bio->bi_private = iue;
+	bio->bi_rw = (rw == WRITE) ? 1 : 0;
+	bio->bi_phys_segments = 1;
+	bio->bi_hw_segments = 1;
+
+	/* This all assumes that the buffers we get are page-aligned */
+	for (cur_biovec = 0; cur_biovec < num_biovec; cur_biovec++) {
+		long thislen;
+
+		if (len > PAGE_CACHE_SIZE) {
+			thislen = PAGE_CACHE_SIZE;
+		} else {
+			thislen = len;
+		}
+
+		bio->bi_io_vec[cur_biovec].bv_page = virt_to_page(buffer);
+		bio->bi_io_vec[cur_biovec].bv_len = thislen;
+		bio->bi_io_vec[cur_biovec].bv_offset =
+		    (unsigned long)buffer & PAGE_OFFSET_MASK;
+		bio->bi_vcnt++;
+
+		len -= thislen;
+		buffer += thislen;
+	}
+	generic_make_request(bio);
+}
+
+/*
+ * Process a READ6
+ */
+static void processRead6(struct iu_entry *iue)
+{
+	long lba = ntohl((*((u32 *) (iue->iu->srp.cmd.cdb)))) & 0x001FFFFF;
+	long len = iue->iu->srp.cmd.cdb[4];
+
+	/* Length of 0 indicates 256 */
+	if (len == 0) {
+		len = 256;
+	}
+
+	len = len * iue->req.vd->b.blksize;
+
+	process_rw("Read6", READ, iue, lba, len);
+}
+
+/*
+ * Process a READ10
+ */
+static void processRead10(struct iu_entry *iue)
+{
+	long lba = ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 2)));
+	long len =
+	    ntohs(*((u16 *) (iue->iu->srp.cmd.cdb + 7))) * iue->req.vd->b.blksize;
+
+	process_rw("Read10", READ, iue, lba, len);
+}
+
+/*
+ * Process a READ10
+ */
+static void processRead12(struct iu_entry *iue)
+{
+	long lba = ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 2)));
+	long len =
+	    ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 6))) * iue->req.vd->b.blksize;
+
+	process_rw("Read12", READ, iue, lba, len);
+}
+
+static void processWrite6(struct iu_entry *iue)
+{
+	long lba = ntohl((*((u32 *) (iue->iu->srp.cmd.cdb)))) & 0x001FFFFF;
+	long len = iue->iu->srp.cmd.cdb[4];
+
+	/* Length of 0 indicates 256 */
+	if (len == 0) {
+		len = 256;
+	}
+
+	len = len * iue->req.vd->b.blksize;
+
+	process_rw("Write6", WRITE, iue, lba, len);
+}
+
+static void processWrite10(struct iu_entry *iue)
+{
+	long lba = ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 2)));
+	long len =
+	    ntohs(*((u16 *) (iue->iu->srp.cmd.cdb + 7))) * iue->req.vd->b.blksize;
+
+	process_rw("Write10", WRITE, iue, lba, len);
+}
+
+static void processWrite12(struct iu_entry *iue)
+{
+	long lba = ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 2)));
+	long len =
+	    ntohl(*((u32 *) (iue->iu->srp.cmd.cdb + 6))) * iue->req.vd->b.blksize;
+
+	process_rw("Write12", WRITE, iue, lba, len);
+}
+
+/*
+ * Handle Read Capacity
+ */
+static void processReadCapacity(struct iu_entry *iue)
+{
+	struct ReadCapacityData {
+		u32 blocks;
+		u32 blocksize;
+	} *cap;
+	dma_addr_t data_token;
+	int bytes;
+
+	cap = (struct ReadCapacityData *)dma_alloc_coherent(iue->adapter->dev,
+							    sizeof(*cap),
+							    &data_token, 0);
+
+	/* return block size and last valid block */
+	cap->blocksize = htonl(iue->req.vd->b.blksize);
+#ifdef USE_64BITDIV
+	cap->blocks = htonl(iue->req.vd->b.bdev->bd_inode->i_size
+	    / iue->req.vd->b.blksize 
+	    - 1);
+#else
+	if (iue->req.vd->b.blksize != 512 || iue->req.vd->b.blkbits != 9)
+		panic("Invalid blocksize");
+	cap->blocks = htonl((iue->req.vd->b.bdev->bd_inode->i_size
+				>> iue->req.vd->b.blkbits) - 1);
+#endif
+
+	info("Reporting capacity as %u block of size %u\n", ntohl(cap->blocks),
+	     ntohl(cap->blocksize));
+
+	bytes = send_cmd_data(data_token, sizeof(*cap), iue);
+
+	dma_free_coherent(iue->adapter->dev, sizeof(*cap), cap, data_token);
+
+	if (bytes != sizeof(*cap)) {
+		err("Error sending read capacity data. bytes %d, wanted %ld\n",
+		    bytes, (unsigned long)sizeof(*cap));
+	}
+
+	send_rsp(iue, SENSE_SUCCESS);
+
+	free_iu(iue);
+}
+
+/*
+ * Process Mode Sense
+ * TODO: I know scsiinfo asks for a bunch of mode pages not implemented here.
+ *       Also, we need to act differently for virtual disk and virtual CD
+ */
+#define MODE_SENSE_BUFFER_SIZE (512)
+static void processModeSense(struct iu_entry *iue)
+{
+	dma_addr_t data_token;
+	int bytes;
+
+	u8 *mode = (u8 *) dma_alloc_coherent(iue->adapter->dev,
+					     MODE_SENSE_BUFFER_SIZE,
+					     &data_token, 0);
+	/* which page */
+	switch (iue->iu->srp.cmd.cdb[2]) {
+	case 0:
+	case 0x3f:
+		mode[1] = 0x00;	/* Default medium */
+		if (iue->req.vd->b.ro) {
+			mode[2] = 0x80;	/* device specific  */
+		} else {
+			mode[2] = 0x00;	/* device specific  */
+		}
+		/* note the DPOFUA bit is set to zero! */
+		mode[3] = 0x08;	/* block descriptor length */
+#ifdef USE_64BITDIV
+		*((u32 *) & mode[4]) = htonl(iue->req.vd->b.bdev->bd_inode->i_size /
+		    iue->req.vd->b.blksize);
+#else
+		if (iue->req.vd->b.blksize != 512 || iue->req.vd->b.blkbits != 9)
+			panic("Invalid blocksize");
+		*((u32 *) & mode[4]) = htonl(iue->req.vd->b.bdev->bd_inode->i_size
+						>> iue->req.vd->b.blkbits);
+#endif
+		*((u32 *) & mode[8]) = htonl(iue->req.vd->b.blksize);
+		bytes = mode[0] = 12;	/* length */
+		break;
+
+	case 0x08:		/* Cache page */
+		/* length should be 4 */
+		if (iue->iu->srp.cmd.cdb[4] != 4
+		    && iue->iu->srp.cmd.cdb[4] != 0x20) {
+			send_rsp(iue, SENSE_INVALID_CMD);
+			dma_free_coherent(iue->adapter->dev,
+					  MODE_SENSE_BUFFER_SIZE,
+					  mode, data_token);
+			free_iu(iue);
+			return;
+		}
+
+		mode[1] = 0x00;	/* Default medium */
+		if (iue->req.vd->b.ro) {
+			mode[2] = 0x80;	/* device specific */
+		} else {
+			mode[2] = 0x00;	/* device specific */
+		}
+		/* note the DPOFUA bit is set to zero! */
+		mode[3] = 0x08;	/* block descriptor length */
+#ifdef USE_64BITDIV
+		*((u32 *) & mode[4]) = htonl(iue->req.vd->b.bdev->bd_inode->i_size /
+		    iue->req.vd->b.blksize);
+#else
+		if (iue->req.vd->b.blksize != 512 || iue->req.vd->b.blkbits != 9)
+			panic("Invalid blocksize");
+		*((u32 *) & mode[4]) = htonl(iue->req.vd->b.bdev->bd_inode->i_size
+						>> iue->req.vd->b.blkbits);
+#endif
+		*((u32 *) & mode[8]) = htonl(iue->req.vd->b.blksize);
+
+		/* Cache page */
+		mode[12] = 0x08;	/* page */
+		mode[13] = 0x12;	/* page length */
+		mode[14] = 0x01;	/* no cache (0x04 for read/write cache) */
+
+		bytes = mode[0] = 12 + mode[13];	/* length */
+		break;
+	default:
+		warn("Request for unknown mode page %d\n",
+		     iue->iu->srp.cmd.cdb[2]);
+		send_rsp(iue, SENSE_INVALID_CMD);
+		dma_free_coherent(iue->adapter->dev,
+				  MODE_SENSE_BUFFER_SIZE, mode, data_token);
+		free_iu(iue);
+		return;
+	}
+
+	bytes = send_cmd_data(data_token, bytes, iue);
+
+	dma_free_coherent(iue->adapter->dev,
+			  MODE_SENSE_BUFFER_SIZE, mode, data_token);
+
+	send_rsp(iue, SENSE_SUCCESS);
+
+	free_iu(iue);
+	return;
+}
+
+/*
+ * Report LUNS command.
+ */
+static void processReportLUNs(struct iu_entry *iue)
+{
+	int listsize = did_len(&iue->iu->srp.cmd);
+	dma_addr_t data_token;
+	int index = 2;		/* Start after the two entries (length and LUN0) */
+	int bus;
+	int target;
+	int bytes;
+	unsigned long flags;
+
+	u64 *lunlist = (u64 *) dma_alloc_coherent(iue->adapter->dev,
+						  listsize,
+						  &data_token, 0);
+
+	memset(lunlist, 0x00, listsize);
+
+	/* work out list size in units of u64 */
+	listsize = listsize / 8;
+
+	if (listsize < 1) {
+		send_rsp(iue, SENSE_INVALID_CMD);
+		free_iu(iue);
+	}
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	/* send lunlist of size 1 when requesting lun is not all zeros */
+	if (iue->iu->srp.cmd.lun != 0x0LL) {
+		*lunlist = ((u64) 1 * 8) << 32;
+		goto send_lunlist;
+	}
+
+	/* return the total number of luns plus LUN0 in bytes */
+	*lunlist = (((u64) ((iue->adapter->nvdevs + 1) * 8)) << 32);
+
+	dbg("reporting %d luns\n", iue->adapter->nvdevs + 1);
+	/* loop through the bus */
+	for (bus = 0; bus < BUS_PER_ADAPTER; bus++) {
+		/* If this bus exists */
+		if (iue->adapter->vbus[bus]) {
+			/* loop through the targets */
+			for (target = 0; target < TARGETS_PER_BUS; target++) {
+				/* If the target exists */
+				if (iue->adapter->vbus[bus]->vdev[target]) {
+					if ((index < listsize) &&
+					    (!iue->adapter->vbus[bus]->
+					     vdev[target]->disabled)) {
+						lunlist[index++] =
+						    iue->adapter->vbus[bus]->
+						    vdev[target]->lun;
+						dbg("  lun %16.16lx\n",
+						    iue->adapter->vbus[bus]->
+						    vdev[target]->lun);
+					}
+				}
+			}
+		}
+	}
+
+      send_lunlist:
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+
+	bytes = send_cmd_data(data_token, (index * 8), iue);
+
+	dma_free_coherent(iue->adapter->dev, listsize * 8, lunlist, data_token);
+
+	if (bytes != (index * 8)) {
+		err("Error sending report luns data. bytes %d, wanted %d\n",
+		    bytes, index * 4);
+		send_rsp(iue, SENSE_ABORT);
+	} else {
+		send_rsp(iue, SENSE_SUCCESS);
+	}
+
+	free_iu(iue);
+	return;
+}
+
+/*
+ * Process an IU.  
+ *
+ * Note that THIS routine is responsible for returning the IU from the pool
+ * The current assumption is that all the process routines called from here
+ * are, in turn, responsible for freeing the IU
+ */
+static void process_cmd(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = iue->iu;
+
+	iue->req.vd = find_device(iue);
+
+	if ((iue->req.vd == NULL) &&
+	    (iu->srp.cmd.cdb[0] != REPORT_LUNS) &&
+	    (iu->srp.cmd.cdb[0] != INQUIRY)) {
+		dbg("Cmd %2.2x for unknown LUN %16.16lx\n",
+		    iu->srp.cmd.cdb[0], iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_INVALID_ID);
+		free_iu(iue);
+		return;
+	}
+
+	iue->req.linked = getlink(iue);
+
+	switch (iu->srp.cmd.cdb[0]) {
+	case READ_6:
+		processRead6(iue);
+		break;
+	case READ_10:
+		processRead10(iue);
+		break;
+	case READ_12:
+		processRead12(iue);
+		break;
+	case WRITE_6:
+		processWrite6(iue);
+		break;
+	case WRITE_10:
+		processWrite10(iue);
+		break;
+	case WRITE_12:
+		processWrite12(iue);
+		break;
+	case REPORT_LUNS:
+		dbg("REPORT LUNS lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processReportLUNs(iue);
+		break;
+	case INQUIRY:
+		dbg("INQUIRY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		process_inquiry(iue);
+		break;
+	case READ_CAPACITY:
+		dbg("READ CAPACITY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processReadCapacity(iue);
+		break;
+	case MODE_SENSE:
+		dbg("MODE SENSE lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		processModeSense(iue);
+		break;
+	case TEST_UNIT_READY:
+		/* we already know the device exists */
+		dbg("TEST UNIT READY lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_SUCCESS);
+		free_iu(iue);
+		break;
+	case START_STOP:
+		/* just respond OK */
+		dbg("START_STOP lun %16.16lx\n", iue->iu->srp.cmd.lun);
+		send_rsp(iue, SENSE_SUCCESS);
+		free_iu(iue);
+		break;
+	default:
+		warn("Unsupported SCSI Command 0x%2.2x\n", iu->srp.cmd.cdb[0]);
+		send_rsp(iue, SENSE_INVALID_CMD);
+		free_iu(iue);
+	}
+}
+
+u16 send_adapter_info(struct iu_entry *iue,
+		      dma_addr_t remote_buffer, u16 length)
+{
+	dma_addr_t data_token;
+	struct mad_adapter_info_data *info =
+	    (struct mad_adapter_info_data *)dma_alloc_coherent(iue->adapter->
+							       dev,
+							       sizeof(*info),
+							       &data_token, 0);
+
+	dbg("in send_adapter_info\n ");
+	if ((info) && (!dma_mapping_error(data_token))) {
+		int rc;
+		memset(info, 0x00, sizeof(*info));
+
+		dbg("building adapter_info\n ");
+		strcpy(info->srp_version, "1.6a");
+		strncpy(info->partition_name, partition_name,
+			sizeof(info->partition_name));
+		info->partition_number = partition_number;
+		info->mad_version = 1;
+		info->os_type = 3;
+
+		rc = h_copy_rdma(sizeof(*info),
+				 iue->adapter->liobn,
+				 data_token,
+				 iue->adapter->riobn,
+				 remote_buffer);
+
+		dma_free_coherent(iue->adapter->dev,
+				  sizeof(*info), info, data_token);
+
+		if (rc != H_Success) {
+			err("Error sending adapter info rc %d\n",rc);
+			return 1;
+		}
+	} else {
+		dbg("bad dma_alloc_cohereint in adapter_info\n ");
+		return 1;
+	}
+	return 0;
+
+}
+
+/* ==============================================================
+ * SRP Processing Routines
+ * ==============================================================
+ */
+/*
+ * Process an incoming SRP Login request
+ */
+static void process_login(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = iue->iu;
+	u64 tag = iu->srp.generic.tag;
+
+	/* TODO handle case that requested size is wrong and buffer format is wrong */
+	memset(iu, 0x00, sizeof(struct srp_login_rsp));
+	iu->srp.login_rsp.type = SRP_LOGIN_RSP_TYPE;
+	iu->srp.login_rsp.request_limit_delta = iue->adapter->pool.size;
+	iu->srp.login_rsp.tag = tag;
+	iu->srp.login_rsp.max_initiator_to_target_iulen = sizeof(union srp_iu);
+	iu->srp.login_rsp.max_target_to_initiator_iulen = sizeof(union srp_iu);
+	iu->srp.login_rsp.supported_buffer_formats = 0x0006;	/* direct and indirect */
+	iu->srp.login_rsp.multi_channel_result = 0x00;	/* TODO fix if we were already logged in */
+
+	send_srp(iue, sizeof(iu->srp.login_rsp));
+}
+
+/*
+ * Send an SRP response that includes sense data
+ */
+static long send_rsp(struct iu_entry *iue, int status)
+{
+	u8 *sense = iue->iu->srp.rsp.sense_and_response_data;
+	u64 tag = iue->iu->srp.generic.tag;
+	union viosrp_iu *iu = iue->iu;
+
+	if (status != SENSE_SUCCESS) {
+		atomic_inc(&iue->adapter->errors);
+	}
+
+	/* If the linked bit is on and status is good */
+	if ((iue->req.linked) && (status == SENSE_SUCCESS)) {
+		status = SENSE_INTERMEDIATE;
+	}
+
+	memset(iu, 0x00, sizeof(struct srp_rsp));
+	iu->srp.rsp.type = SRP_RSP_TYPE;
+	iu->srp.rsp.request_limit_delta = 1;
+	iu->srp.rsp.tag = tag;
+
+	iu->srp.rsp.diunder = iue->req.diunder;
+	iu->srp.rsp.diover = iue->req.diover;
+	iu->srp.rsp.dounder = iue->req.dounder;
+	iu->srp.rsp.doover = iue->req.doover;
+
+	iu->srp.rsp.data_in_residual_count = iue->req.data_in_residual_count;
+	iu->srp.rsp.data_out_residual_count = iue->req.data_out_residual_count;
+
+	iu->srp.rsp.rspvalid = 0;
+
+	iu->srp.rsp.response_data_list_length = 0;
+
+	if (status) {
+		iu->srp.rsp.status = SAM_STAT_CHECK_CONDITION;
+		iu->srp.rsp.snsvalid = 1;
+		iu->srp.rsp.sense_data_list_length = 18;	/* TODO be smarter about this */
+
+		/* Valid bit and 'current errors' */
+		sense[0] = (0x1 << 7 | 0x70);
+
+		/* Sense key */
+		sense[2] = ibmvscsis_sense_data[status][0];
+
+		/* Additional sense length */
+		sense[7] = 0xa;	/* 10 bytes */
+
+		/* Additional sense code */
+		sense[12] = ibmvscsis_sense_data[status][1];
+
+		/* Additional sense code qualifier */
+		sense[13] = ibmvscsis_sense_data[status][2];
+	} else {
+		iu->srp.rsp.status = 0;
+	}
+
+	send_srp(iue, sizeof(iu->srp.rsp));
+
+	return 0;
+}
+
+static void process_device_reset(struct iu_entry *iue)
+{
+	struct iu_entry *tmp_iue;
+	unsigned long flags;
+	union viosrp_iu *iu = iue->iu;
+
+	info("device reset for lun %16.16lx\n", iu->srp.tsk_mgmt.lun);
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	list_for_each_entry(tmp_iue, &iue->adapter->inflight, next) {
+		if (iu->srp.tsk_mgmt.lun == tmp_iue->iu->srp.cmd.lun) {
+			{
+				tmp_iue->aborted = 1;
+			}
+		}
+
+	}
+
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+	send_rsp(iue, SENSE_SUCCESS);
+}
+
+static void process_abort(struct iu_entry *iue)
+{
+	struct iu_entry *tmp_iue;
+	unsigned long flags;
+	union viosrp_iu *iu = iue->iu;
+
+	info("aborting task with tag %16.16lx, lun %16.16lx\n",
+	     iu->srp.tsk_mgmt.managed_task_tag, iu->srp.tsk_mgmt.lun);
+
+	spin_lock_irqsave(&iue->adapter->lock, flags);
+
+	list_for_each_entry(tmp_iue, &iue->adapter->inflight, next) {
+		if (tmp_iue->iu->srp.cmd.tag ==
+		    iu->srp.tsk_mgmt.managed_task_tag) {
+			{
+				tmp_iue->aborted = 1;
+				info("abort successful\n");
+				spin_unlock_irqrestore(&iue->adapter->lock,
+						       flags);
+				send_rsp(iue, SENSE_SUCCESS);
+				return;
+			}
+		}
+	}
+	info("unable to abort cmd\n");
+
+	spin_unlock_irqrestore(&iue->adapter->lock, flags);
+	send_rsp(iue, SENSE_INVALID_ID);
+}
+
+static void process_tsk_mgmt(struct iu_entry *iue)
+{
+	union viosrp_iu *iu = iue->iu;
+
+	if (iu->srp.tsk_mgmt.task_mgmt_flags == 0x01) {
+		process_abort(iue);
+	} else if (iu->srp.tsk_mgmt.task_mgmt_flags == 0x08) {
+		process_device_reset(iue);
+	} else {
+		send_rsp(iue, SENSE_INVALID_CMD);
+	}
+}
+
+static void process_iu(struct viosrp_crq *crq, struct server_adapter *adapter)
+{
+	struct iu_entry *iue = get_iu(adapter);
+	union viosrp_iu *iu;
+	int queued = 0;
+	long rc;
+
+	if (iue == NULL) {
+		/* TODO Yikes! */
+		warn("Error getting IU from pool, other side exceeded limit\n");
+		return;
+	}
+
+	iue->req.remote_token = crq->IU_data_ptr;
+
+	rc = h_copy_rdma(crq->IU_length,
+			 iue->adapter->riobn,
+			 iue->req.remote_token, adapter->liobn, iue->iu_token);
+
+	iu = iue->iu;
+
+	if (rc) {
+		err("Error %ld transferring data to client\n", rc);
+	}
+
+	if (crq->format == VIOSRP_MAD_FORMAT) {
+		switch (iu->mad.empty_iu.common.type) {
+		case VIOSRP_EMPTY_IU_TYPE:
+			warn("Unsupported EMPTY MAD IU\n");
+			break;
+		case VIOSRP_ERROR_LOG_TYPE:
+			warn("Unsupported ERROR LOG MAD IU\n");
+			iu->mad.error_log.common.status = 1;
+			send_srp(iue, sizeof(iu->mad.error_log));
+			break;
+		case VIOSRP_ADAPTER_INFO_TYPE:
+			iu->mad.adapter_info.common.status =
+			    send_adapter_info(iue,
+					      iu->mad.adapter_info.buffer,
+					      iu->mad.adapter_info.common.
+					      length);
+
+			send_srp(iue, sizeof(iu->mad.adapter_info));
+			break;
+		case VIOSRP_HOST_CONFIG_TYPE:
+			iu->mad.host_config.common.status = 1;
+			send_srp(iue, sizeof(iu->mad.host_config));
+			break;
+		default:
+			warn("Unsupported MAD type %d\n", iu->srp.generic.type);
+		}
+	} else {
+		switch (iu->srp.generic.type) {
+		case SRP_LOGIN_REQ_TYPE:
+			dbg("SRP LOGIN\n");
+			process_login(iue);
+			break;
+		case SRP_LOGIN_RSP_TYPE:
+			warn("Unsupported LOGIN_RSP SRP IU\n");
+			break;
+		case SRP_I_LOGOUT_TYPE:
+			warn("Unsupported I_LOGOUT SRP IU\n");
+			break;
+		case SRP_T_LOGOUT_TYPE:
+			warn("Unsupported T_LOGOUT SRP IU\n");
+			break;
+		case SRP_TSK_MGMT_TYPE:
+			process_tsk_mgmt(iue);
+			break;
+		case SRP_CMD_TYPE:
+			process_cmd(iue);
+			queued = 1;
+			break;
+		case SRP_RSP_TYPE:
+			warn("Unsupported RSP SRP IU\n");
+			break;
+		case SRP_CRED_REQ_TYPE:
+			warn("Unsupported CRED_REQ SRP IU\n");
+			break;
+		case SRP_CRED_RSP_TYPE:
+			warn("Unsupported CRED_RSP SRP IU\n");
+			break;
+		case SRP_AER_REQ_TYPE:
+			warn("Unsupported AER_REQ SRP IU\n");
+			break;
+		case SRP_AER_RSP_TYPE:
+			warn("Unsupported AER_RSP SRP IU\n");
+			break;
+		default:
+			warn("Unsupported SRP type %d\n", iu->srp.generic.type);
+		}
+	}
+
+	/* 
+	 * If no one has queued the IU for further work, free it 
+	 * Note that this is kind of an ugly design based on setting
+	 * this variable up above in cases where the routine we call
+	 * is responsible for freeing the IU
+	 */
+	if (!queued)
+		free_iu(iue);
+}
+
+/* ==============================================================
+ * CRQ Processing Routines
+ * ==============================================================
+ */
+
+/*
+ * Handle a CRQ event
+ */
+static void handle_crq(struct viosrp_crq *crq, struct server_adapter *adapter)
+{
+	switch (crq->valid) {
+	case 0xC0:		/* initialization */
+		switch (crq->format) {
+		case 0x01:
+			info("Client just initialized\n");
+			plpar_hcall_norets(H_SEND_CRQ,
+					   adapter->dma_dev->unit_address,
+					   0xC002000000000000ULL, 0);
+			break;
+		case 0x02:
+			info("Client initialization complete\n");
+			break;
+		default:
+			err("Client error: Unknwn msg format %d\n", 
+			    crq->format);
+		}
+		return;
+	case 0xFF:		/* transport event */
+		info("Client closed\n");
+		return;
+	case 0x80:		/* real payload */
+		{
+			switch (crq->format) {
+			case VIOSRP_SRP_FORMAT:
+			case VIOSRP_MAD_FORMAT:
+				process_iu(crq, adapter);
+				break;
+			case VIOSRP_OS400_FORMAT:
+				warn("Unsupported OS400 format CRQ\n");
+				break;
+
+			case VIOSRP_AIX_FORMAT:
+				warn("Unsupported AIX format CRQ\n");
+				break;
+
+			case VIOSRP_LINUX_FORMAT:
+				warn("Unsupported LINUX format CRQ\n");
+				break;
+
+			case VIOSRP_INLINE_FORMAT:
+				warn("Unsupported _INLINE_ format CRQ\n");
+				break;
+
+			default:
+				err("Client error: Unsupported  msg format %d\n", 
+				    crq->format);
+			}
+		}
+		break;
+	default:
+		err("Client error: unknown message type 0x%02x!?\n",
+		    crq->valid);
+		return;
+	}
+
+}
+
+/*
+ * Task to handle CRQs and completions
+ */
+static void crq_task(void *data)
+{
+	struct server_adapter *adapter = (struct server_adapter *)data;
+	struct viosrp_crq *crq;
+	long rc;
+	int done = 0;
+
+	while (!done) {
+
+		/* Loop through and process CRQs */
+		while ((crq = crq_queue_next_crq(&adapter->queue)) != NULL) {
+			atomic_inc(&adapter->crq_processed);
+			handle_crq(crq, adapter);
+			crq->valid = 0x00;
+		}
+
+		rc = h_vio_signal(adapter->dma_dev->unit_address, 1);
+		if (rc != 0) {
+			err("Error %ld enabling interrupts!!!\n", rc);
+		}
+		if ((crq = crq_queue_next_crq(&adapter->queue)) != NULL) {
+			rc = h_vio_signal(adapter->dma_dev->unit_address, 0);
+			if (rc != 0) {
+				err("Error %ld enabling interrupts!!!\n", rc);
+			}
+			handle_crq(crq, adapter);
+			crq->valid = 0x00;
+		} else {
+			done = 1;
+		}
+	}
+}
+
+/*
+ * Handle the interrupt that occurs when something is placed on our CRQ
+ */
+static irqreturn_t handle_interrupt(int irq, void *dev_instance,
+				    struct pt_regs *regs)
+{
+	struct server_adapter *adapter = (struct server_adapter *)dev_instance;
+	long rc;
+
+	rc = h_vio_signal(adapter->dma_dev->unit_address, 0);
+	if (rc != 0) {
+		err(" Error %ld disabling interrupts!!!\n", rc);
+	}
+
+	atomic_inc(&adapter->interrupts);
+
+	kblockd_schedule_work(&adapter->crq_task);
+
+	return IRQ_HANDLED;
+}
+
+/* 
+ * Initialize our CRQ
+ * return zero on success, non-zero on failure 
+ */
+static int initialize_crq_queue(struct crq_queue *queue,
+				struct server_adapter *adapter)
+{
+	int rc;
+
+	queue->msgs = (struct viosrp_crq *)get_zeroed_page(GFP_KERNEL);
+	if (!queue->msgs)
+		goto malloc_failed;
+	queue->size = PAGE_SIZE / sizeof(*queue->msgs);
+
+	queue->msg_token = dma_map_single(adapter->dev, queue->msgs,
+					  queue->size * sizeof(*queue->msgs),
+					  DMA_BIDIRECTIONAL);
+
+	if (dma_mapping_error(queue->msg_token))
+		goto map_failed;
+
+	rc = plpar_hcall_norets(H_REG_CRQ, adapter->dma_dev->unit_address,
+				queue->msg_token, PAGE_SIZE);
+
+	if ((rc != 0) && (rc != 2)) {
+		err("Error 0x%x opening virtual adapter\n", rc);
+		goto reg_crq_failed;
+	}
+
+	if (request_irq
+	    (adapter->dma_dev->irq, &handle_interrupt, SA_INTERRUPT,
+	     "ibmvscsis", adapter) != 0)
+		goto req_irq_failed;
+
+	rc = h_vio_signal(adapter->dma_dev->unit_address, 1);
+	if (rc != 0) {
+		err("Error %d enabling interrupts!!!\n", rc);
+		goto req_irq_failed;
+	}
+
+	plpar_hcall_norets(H_SEND_CRQ, adapter->dma_dev->unit_address,
+				   0xC001000000000000, 0);
+
+	queue->cur = 0;
+	queue->lock = SPIN_LOCK_UNLOCKED;
+
+	return 0;
+
+      req_irq_failed:
+	do {
+		rc = plpar_hcall_norets(H_FREE_CRQ, adapter->dma_dev->unit_address);
+	} while ((rc == H_Busy) || (H_isLongBusy(rc)));
+	
+      reg_crq_failed:
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+      map_failed:
+	free_page((unsigned long)queue->msgs);
+      malloc_failed:
+	return -1;
+}
+
+/*
+ * Release the CRQ
+ */
+static void release_crq_queue(struct crq_queue *queue,
+			      struct server_adapter *adapter)
+{
+	int rc;
+
+	info("releasing adapter\n");
+	free_irq(adapter->dma_dev->irq, adapter);
+	do {
+		rc = plpar_hcall_norets(H_FREE_CRQ, adapter->dma_dev->unit_address);
+	} while ((rc == H_Busy) || (H_isLongBusy(rc)));
+	dma_unmap_single(adapter->dev, queue->msg_token,
+			 queue->size * sizeof(*queue->msgs), DMA_BIDIRECTIONAL);
+	free_page((unsigned long)queue->msgs);
+}
+
+/* ==============================================================
+ * Module Management
+ * ==============================================================
+ */
+/*
+ * Add a block device as a SCSI LUN
+ */
+static int activate_block_device(struct vdev *vdev)
+{
+	struct block_device *bdev;
+	char *name = vdev->b.device_name;
+	int ro = vdev->b.ro;
+
+	bdev = open_bdev_excl(name, ro, activate_block_device);
+	if (IS_ERR(bdev))
+		return PTR_ERR(bdev);;
+
+	vdev->b.bdev = bdev;
+	vdev->disabled = 0;
+
+	info("Activating block device %s as %sLUN 0x%lx\n",
+	     name, ro ? "read only " : "", (long)vdev->lun);
+
+	return 0;
+}
+
+static void deactivate_block_device(struct vdev *vdev)
+{
+	info("Deactivating block device, LUN 0x%lx\n", (long)vdev->lun);
+
+	/* Wait while any users of this device finish.  Note there should
+	 * be no new users, since we have marked this disabled
+	 *
+	 * We just poll here, since we are blocking write
+	 */
+	while (atomic_read(&vdev->refcount)) {
+		schedule_timeout(HZ / 4);	/* 1/4 second */
+	}
+
+	vdev->disabled = 1;
+	close_bdev_excl(vdev->b.bdev);
+}
+
+
+#define ATTR(_type, _name, _mode)      \
+struct attribute vscsi_##_type##_##_name##_attr = {               \
+.name = __stringify(_name), .mode = _mode, .owner = THIS_MODULE \
+};
+
+static struct kobj_type ktype_vscsi_target;
+static struct kobj_type ktype_vscsi_bus;
+static struct kobj_type ktype_vscsi_stats;
+
+static void set_num_targets(struct vbus* vbus, long value)
+{
+	struct device *dev = 
+		container_of(vbus->kobj.parent, struct device , kobj);
+	struct server_adapter *adapter = (struct server_adapter *)to_vio_dev(dev)->dev.driver_data;
+	int cur_num_targets = atomic_read(&vbus->num_targets);
+	unsigned long flags;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	if (cur_num_targets < value) { //growing
+		int i;
+		for (i = cur_num_targets; i < value; i++) {
+			vbus->vdev[i] = (struct vdev *)
+				kmalloc(sizeof(struct vdev), GFP_KERNEL);
+			if (!vbus->vdev[i]) {
+				spin_unlock_irqrestore(&adapter->lock, flags);
+				err("Couldn't allocate target memory %d\n", i);
+				return;
+			}
+			memset(vbus->vdev[i], 0x00, sizeof(struct vdev));
+
+			vbus->vdev[i]->lun = make_lun(vbus->bus_num, i, 0);
+			vbus->vdev[i]->b.blksize = 512;
+			vbus->vdev[i]->b.blkbits = 9;
+			vbus->vdev[i]->disabled = 1;
+
+			vbus->vdev[i]->kobj.parent = &vbus->kobj;
+			sprintf(vbus->vdev[i]->kobj.name, "target%d", i);
+			vbus->vdev[i]->kobj.ktype = &ktype_vscsi_target;
+			kobject_register(&vbus->vdev[i]->kobj);
+			adapter->nvdevs++;
+			atomic_inc(&vbus->num_targets);
+		}
+	} else { //shrinking
+		int i;
+		for (i = cur_num_targets - 1; i >= value; i--)
+		{
+			if (!vbus->vdev[i]->disabled) {
+				spin_unlock_irqrestore(&adapter->lock, flags);
+				err("Can't remove active target %d\n", i);
+				return;
+			}
+
+			kobject_unregister(&vbus->vdev[i]->kobj);
+
+			kfree(vbus->vdev[i]);
+
+			adapter->nvdevs--;
+			atomic_dec(&vbus->num_targets);
+		}
+	}
+	spin_unlock_irqrestore(&adapter->lock, flags);
+}
+
+static void set_num_buses(struct device *dev, long value)
+{
+	struct server_adapter *adapter = (struct server_adapter *)to_vio_dev(dev)->dev.driver_data;
+	int cur_num_buses = atomic_read(&adapter->num_buses);
+	unsigned long flags = 0;
+
+
+	if (cur_num_buses < value) { // growing
+		int i;
+		for (i = cur_num_buses; i < value; i++) {
+			adapter->vbus[i] = (struct vbus *)
+				kmalloc(sizeof(struct vbus), GFP_KERNEL);
+			if (!adapter->vbus[i]) {
+				spin_unlock_irqrestore(&adapter->lock, flags);
+				err("Couldn't allocate bus %d memory\n", i);
+				return;
+			}
+			memset(adapter->vbus[i], 0x00, sizeof(struct vbus));
+
+			spin_lock_irqsave(&adapter->lock, flags);
+
+			adapter->vbus[i]->bus_num = i;
+
+			adapter->vbus[i]->kobj.parent = &dev->kobj;
+			sprintf(adapter->vbus[i]->kobj.name, "bus%d", i);
+			adapter->vbus[i]->kobj.ktype = &ktype_vscsi_bus; 
+			kobject_register(&adapter->vbus[i]->kobj);
+			
+			atomic_inc(&adapter->num_buses);
+			spin_unlock_irqrestore(&adapter->lock, flags);
+
+			set_num_targets(adapter->vbus[i], 1);
+		}
+
+	} else if (cur_num_buses > value) { //shrinking
+		int i, j, active_target;
+		for (i = cur_num_buses - 1; i >= value; i--) {
+			active_target = -1;
+			for (j = 0; j < TARGETS_PER_BUS; j++) {
+				if (adapter->vbus[i]->vdev[j] && 
+				    !adapter->vbus[i]->vdev[j]->disabled) {
+					active_target = j;
+					break;
+				}
+			}
+			if (active_target != -1) {
+				err("Can't remove bus%d, target%d active\n", 
+					i, active_target);
+				return ;
+			}
+
+			set_num_targets(adapter->vbus[i], 0);
+
+			spin_lock_irqsave(&adapter->lock, flags);
+			atomic_dec(&adapter->num_buses);
+			kobject_unregister(&adapter->vbus[i]->kobj);
+			kfree(adapter->vbus[i]);
+			adapter->vbus[i] = NULL;
+			spin_unlock_irqrestore(&adapter->lock, flags);
+		}
+	}
+}
+
+
+/* Target sysfs stuff */
+static ATTR(target, type, 0644);
+static ATTR(target, device, 0644);
+static ATTR(target, active, 0644);
+static ATTR(target, ro, 0644);
+
+static ssize_t vscsi_target_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct vdev *vdev = container_of(kobj, struct vdev, kobj);
+	struct device *dev = container_of(kobj->parent->parent, struct device, kobj);
+	struct server_adapter *adapter = (struct server_adapter *)to_vio_dev(dev)->dev.driver_data;
+	unsigned long flags;
+	ssize_t returned = 0;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	if (attr == &vscsi_target_type_attr)
+		returned = sprintf(buf, "%c\n", vdev->type);
+	else if (attr == &vscsi_target_device_attr)
+		returned = sprintf(buf, "%s\n", vdev->b.device_name);
+	else if (attr == &vscsi_target_active_attr)
+		returned = sprintf(buf, "%d\n", !vdev->disabled);
+	else if (attr == &vscsi_target_ro_attr)
+		returned = sprintf(buf, "%d\n", vdev->b.ro);
+	else {
+		spin_unlock_irqrestore(&adapter->lock, flags);
+		BUG();
+	}
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	return returned;
+}
+
+static ssize_t vscsi_target_store(struct kobject * kobj, struct attribute * attr, const char * buf, size_t count)
+{
+	struct vdev *vdev = container_of(kobj, struct vdev, kobj);
+	struct device *dev = container_of(kobj->parent->parent, struct device, kobj);
+	struct server_adapter *adapter = (struct server_adapter *)to_vio_dev(dev)->dev.driver_data;
+	long flags;
+	long value = simple_strtol(buf, NULL, 10);
+
+	if (attr != &vscsi_target_active_attr && !vdev->disabled) {
+		err("Error: Can't modify properties while target is active.\n");
+		return -EPERM;
+	}
+
+	if (attr == &vscsi_target_type_attr) {
+		if (buf[0] == 'B' ||  buf[0] == 'b')
+			vdev->type = 'B';
+		else if (buf[0] == 'S' || buf[0] == 's') {
+			// TODO
+			err ("SCSI mode not supported yet\n");		
+			return -EINVAL;
+		} else 
+			return -EINVAL;
+	} else if (attr == &vscsi_target_device_attr) {
+		int i;
+		spin_lock_irqsave(&adapter->lock, flags);
+		i  = strlcpy(vdev->b.device_name, buf, TARGET_MAX_NAME_LEN);
+		for (; i >= 0; i--)
+			if (vdev->b.device_name[i] == '\n')
+				vdev->b.device_name[i] = '\0';
+		spin_unlock_irqrestore(&adapter->lock, flags);
+	} else if (attr == &vscsi_target_active_attr) {
+		if (value) {
+			int rc;
+			if (!vdev->disabled) {
+				warn("Warning: Target was already active\n");
+				return -EINVAL;
+			}
+			if (vdev->type == '\0') {
+				err("Error: Type not specified\n");
+				return -EPERM;
+			}
+			rc = activate_block_device(vdev);
+			if (rc) {
+				err("Error opening block device=%d\n", rc);
+				return rc;
+			}
+		} else {
+			if (!vdev->disabled) 
+				deactivate_block_device(vdev);
+		}
+	} else if (attr == &vscsi_target_ro_attr)
+		vdev->b.ro = value > 0 ? 1 : 0;
+	else 
+		BUG();
+
+	return count;
+}
+
+static struct attribute * vscsi_target_attrs[] = {
+	&vscsi_target_type_attr,
+	&vscsi_target_device_attr,
+	&vscsi_target_active_attr,
+	&vscsi_target_ro_attr,
+	NULL,
+};
+
+static struct sysfs_ops vscsi_target_ops = {
+	.show   = vscsi_target_show,
+	.store  = vscsi_target_store,
+};
+
+static struct kobj_type ktype_vscsi_target = {
+	.release        = NULL,
+	.sysfs_ops      = &vscsi_target_ops, 
+	.default_attrs  = vscsi_target_attrs,
+};
+
+
+
+/* Bus sysfs stuff */
+static ssize_t vscsi_bus_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct vbus *vbus = container_of(kobj, struct vbus, kobj);
+	return sprintf(buf, "%d\n", atomic_read(&vbus->num_targets));
+}
+
+static ssize_t vscsi_bus_store(struct kobject * kobj, struct attribute * attr, 
+const char * buf, size_t count)
+{
+	struct vbus *vbus = container_of(kobj, struct vbus, kobj);
+	long value = simple_strtol(buf, NULL, 10);
+	
+	if (value < 0 || value > TARGETS_PER_BUS)
+		return -EINVAL;
+	
+	set_num_targets(vbus, value);
+
+	return count;
+}
+
+
+static ATTR(bus, num_targets, 0644);
+
+static struct attribute * vscsi_bus_attrs[] = {
+	&vscsi_bus_num_targets_attr,
+	NULL,
+};
+
+static struct sysfs_ops vscsi_bus_ops = {
+	.show   = vscsi_bus_show,
+	.store  = vscsi_bus_store,
+};
+
+static struct kobj_type ktype_vscsi_bus = {
+	.release        = NULL,
+	.sysfs_ops      = &vscsi_bus_ops, 
+	.default_attrs  = vscsi_bus_attrs,
+};
+
+
+/* Device attributes */
+static ssize_t vscsi_dev_bus_show(struct device * dev, char * buf)
+{
+	struct server_adapter *adapter = (struct server_adapter *)to_vio_dev(dev)->dev.driver_data;
+
+	return sprintf(buf, "%d\n", atomic_read(&adapter->num_buses));
+}
+
+static ssize_t vscsi_dev_bus_store(struct device * dev, const char * buf, size_t count)
+{
+	long value = simple_strtol(buf, NULL, 10);
+	
+	if (value < 0 || value > BUS_PER_ADAPTER)
+		return -EINVAL;
+
+	set_num_buses(dev, value);
+	return count;
+}
+
+static DEVICE_ATTR(num_buses, 0644, vscsi_dev_bus_show, vscsi_dev_bus_store);
+
+
+/* Stats kobj stuff */
+
+static ATTR(stats, interrupts, 0444);
+static ATTR(stats, read_ops, 0444);
+static ATTR(stats, write_ops, 0444);
+static ATTR(stats, crq_msgs, 0444);
+static ATTR(stats, iu_allocs, 0444);
+static ATTR(stats, bio_allocs, 0444);
+static ATTR(stats, buf_allocs, 0444);
+static ATTR(stats, errors, 0444);
+
+static struct attribute * vscsi_stats_attrs[] = {
+	&vscsi_stats_interrupts_attr,
+	&vscsi_stats_read_ops_attr,
+	&vscsi_stats_write_ops_attr,
+	&vscsi_stats_crq_msgs_attr,
+	&vscsi_stats_iu_allocs_attr,
+	&vscsi_stats_bio_allocs_attr,
+	&vscsi_stats_buf_allocs_attr,
+	&vscsi_stats_errors_attr,
+	NULL,
+};
+
+
+static ssize_t vscsi_stats_show(struct kobject * kobj, struct attribute * attr, char * buf)
+{
+	struct server_adapter *adapter= container_of(kobj, struct server_adapter, stats_kobj);
+	if (attr == &vscsi_stats_interrupts_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->interrupts));
+	if (attr == &vscsi_stats_read_ops_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->read_processed));
+	if (attr == &vscsi_stats_write_ops_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->write_processed));
+	if (attr == &vscsi_stats_crq_msgs_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->crq_processed));
+	if (attr == &vscsi_stats_iu_allocs_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->iu_count));
+	if (attr == &vscsi_stats_bio_allocs_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->bio_count));
+	if (attr == &vscsi_stats_buf_allocs_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->buffers_allocated));
+	if (attr == &vscsi_stats_errors_attr)
+		return sprintf(buf, "%d\n", 
+		 atomic_read(&adapter->errors));
+	
+	BUG();
+	return 0;
+}
+
+static struct sysfs_ops vscsi_stats_ops = {
+	.show   = vscsi_stats_show,
+	.store  = NULL,
+};
+
+static struct kobj_type ktype_vscsi_stats = {
+	.release        = NULL,
+	.sysfs_ops      = &vscsi_stats_ops, 
+	.default_attrs  = vscsi_stats_attrs,
+};
+
+
+static int ibmvscsis_probe(struct vio_dev *dev, const struct vio_device_id *id)
+{
+	struct server_adapter *adapter;
+	int rc;
+	unsigned int *dma_window;
+	unsigned int dma_window_property_size;
+
+	adapter = kmalloc(sizeof(*adapter), GFP_KERNEL);
+	if (!adapter) {
+		err("couldn't allocate adapter memory\n");
+		return -1;
+	}
+	memset(adapter, 0x00, sizeof(*adapter));
+	adapter->dma_dev = dev;
+	adapter->dev = &dev->dev;
+	dev->dev.driver_data = adapter;
+	sprintf(adapter->name, "%x", dev->unit_address);
+	adapter->lock = SPIN_LOCK_UNLOCKED;
+
+	dma_window =
+	    (unsigned int *)vio_get_attribute(dev, "ibm,my-dma-window",
+					      &dma_window_property_size);
+	if (!dma_window) {
+		warn("Couldn't find ibm,my-dma-window property\n");
+	}
+
+	adapter->liobn = dma_window[0];
+	/* RPA docs say that #address-cells is always 1 for virtual
+	   devices, but some older boxes' OF returns 2.  This should
+	   be removed by GA, unless there is legacy OFs that still
+	   have 2 or 3 for #address-cells */
+	/*adapter->riobn = dma_window[2+vio_num_address_cells]; */
+
+	/* This is just an ugly kludge. Remove as soon as the OF for all
+	   machines actually follow the spec and encodes the offset field
+	   as phys-encode (that is, #address-cells wide) */
+	if (dma_window_property_size == 24) {
+		adapter->riobn = dma_window[3];
+	} else if (dma_window_property_size == 40) {
+		adapter->riobn = dma_window[5];
+	} else {
+		warn("Invalid size of ibm,my-dma-window=%i\n",
+		     dma_window_property_size);
+	}
+
+	INIT_WORK(&adapter->crq_task, crq_task, adapter);
+
+	tasklet_init(&adapter->endio_tasklet,
+		     endio_task, (unsigned long)adapter);
+
+	INIT_LIST_HEAD(&adapter->inflight);
+
+	/* Initialize the buffer cache */
+	init_data_buffer(adapter);
+
+	/* Arbitrarily support 16 IUs right now */
+	rc = initialize_iu_pool(adapter, 16);
+	if (rc) {
+		kfree(adapter);
+		return rc;
+	}
+
+	rc = initialize_crq_queue(&adapter->queue, adapter);
+	if (rc != 0) {
+		kfree(adapter);
+		return rc;
+	}
+
+	set_num_buses(&dev->dev, 1);
+	device_create_file(&dev->dev, &dev_attr_num_buses);
+
+	adapter->stats_kobj.parent = &dev->dev.kobj;
+	strcpy(adapter->stats_kobj.name, "stats");
+	adapter->stats_kobj.ktype = & ktype_vscsi_stats;
+	kobject_register(&adapter->stats_kobj);
+
+	return 0;
+}
+
+static int ibmvscsis_remove(struct vio_dev *dev)
+{
+	int bus;
+	int target;
+	unsigned long flags;
+	struct server_adapter *adapter =
+	    (struct server_adapter *)dev->dev.driver_data;
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	/* 
+	 * Loop through the bus
+	 */
+	for (bus = 0; bus < BUS_PER_ADAPTER; bus++) {
+		/* If this bus exists */
+		if (adapter->vbus[bus]) {
+			/* loop through the targets */
+			for (target = 0; target < TARGETS_PER_BUS; target++) {
+				/* If the target exists */
+				if (adapter->vbus[bus]->vdev[target] &&
+				    !adapter->vbus[bus]->vdev[target]
+				     ->disabled) {
+					deactivate_block_device(adapter->
+					 vbus[bus]->vdev[target]);
+				}
+			}
+			spin_unlock_irqrestore(&adapter->lock, flags);
+			set_num_targets(adapter->vbus[bus], 0);
+			spin_lock_irqsave(&adapter->lock, flags);
+		}
+	}
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+	set_num_buses(adapter->dev, 0);
+	release_crq_queue(&adapter->queue, adapter);
+
+	release_iu_pool(adapter);
+
+	release_data_buffer(adapter);
+
+	kobject_unregister(&adapter->stats_kobj);
+	device_remove_file(&dev->dev, &dev_attr_num_buses);
+
+	kfree(adapter);
+
+	return 0;
+}
+
+static struct vio_device_id ibmvscsis_device_table[] __devinitdata = {
+	{"v-scsi-host", "IBM,v-scsi-host"},
+	{0,}
+};
+
+MODULE_DEVICE_TABLE(vio, ibmvscsis_device_table);
+
+static struct vio_driver ibmvscsis_driver = {
+	.name = "ibmvscsis",
+	.id_table = ibmvscsis_device_table,
+	.probe = ibmvscsis_probe,
+	.remove = ibmvscsis_remove,
+};
+
+static int mod_init(void)
+{
+#ifndef CONFIG_X86_HYPERVISOR
+	struct device_node *rootdn;
+	char *ppartition_name;
+	char *psystem_id;
+	char *pmodel;
+	unsigned int *p_number_ptr;
+#endif
+	int rc;
+
+#ifndef CONFIG_X86_HYPERVISOR
+	/* Retrieve information about this partition */
+	rootdn = find_path_device("/");
+	if (rootdn) {
+		pmodel = get_property(rootdn, "model", NULL);
+		psystem_id = get_property(rootdn, "system-id", NULL);
+		if (pmodel && psystem_id) 
+			snprintf(system_id,sizeof(system_id),
+				 "%s-%s",
+				 pmodel, psystem_id);
+		ppartition_name =
+			get_property(rootdn, "ibm,partition-name", NULL);
+		if (ppartition_name)
+			strncpy(partition_name, ppartition_name,
+				sizeof(partition_name));
+		p_number_ptr =
+			(unsigned int *)get_property(rootdn, "ibm,partition-no",
+						     NULL);
+		if (p_number_ptr)
+			partition_number = *p_number_ptr;
+	}
+#endif
+
+	info("initialized version "IBMVSCSIS_VERSION"\n");
+
+	rc = vio_register_driver(&ibmvscsis_driver);
+
+	if (rc) {
+		warn("rc %d from vio_register_driver\n", rc);
+	}
+
+	return rc;
+}
+
+static void mod_exit(void)
+{
+	info("terminated\n");
+
+	vio_unregister_driver(&ibmvscsis_driver);
+}
+
+module_init(mod_init);
+module_exit(mod_exit);
diff -urNpX diff.exclude linux--2.6.11/drivers/scsi/ibmvscsi/viosrp.h linux--vhype--2.6.11/drivers/scsi/ibmvscsi/viosrp.h
--- linux--2.6.11/drivers/scsi/ibmvscsi/viosrp.h	2005-03-01 16:17:13.000000000 +0000
+++ linux--vhype--2.6.11/drivers/scsi/ibmvscsi/viosrp.h	2005-03-01 21:13:08.000000000 +0000
@@ -45,12 +45,21 @@ enum viosrp_crq_formats {
 };
 
 struct viosrp_crq {
+#if __LITTLE_ENDIAN
+	u16 IU_length;
+	u16 timeout;
+	u8 status;
+	u8 reserved;
+	u8 format;
+	u8 valid;
+#else
 	u8 valid;		/* used by RPA */
 	u8 format;		/* SCSI vs out-of-band */
 	u8 reserved;
 	u8 status;		/* non-scsi failure? (e.g. DMA failure) */
 	u16 timeout;		/* in seconds */
 	u16 IU_length;		/* in bytes */
+#endif
 	u64 IU_data_ptr;	/* the TCE for transferring data */
 };
 
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/atomic.h linux--vhype--2.6.11/include/asm-i386/atomic.h
--- linux--2.6.11/include/asm-i386/atomic.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/atomic.h	2005-03-01 21:13:36.000000000 +0000
@@ -218,6 +218,17 @@ static __inline__ int atomic_sub_return(
 #define atomic_inc_return(v)  (atomic_add_return(1,v))
 #define atomic_dec_return(v)  (atomic_sub_return(1,v))
 
+/*
+ * Atomically test *v and decrement if it is greater than 0.
+ * The function returns the old value of *v minus 1.
+ */
+static __inline__ int atomic_dec_if_positive(atomic_t *v)
+{
+	if (atomic_add_negative(-1, v))
+		atomic_inc(v);
+	return atomic_read(v);
+}
+
 /* These are x86-specific, used by some header files */
 #define atomic_clear_mask(mask, addr) \
 __asm__ __volatile__(LOCK "andl %0,%1" \
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/bug.h linux--vhype--2.6.11/include/asm-i386/bug.h
--- linux--2.6.11/include/asm-i386/bug.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/bug.h	2005-03-01 21:13:36.000000000 +0000
@@ -11,10 +11,13 @@
 
 #ifdef CONFIG_DEBUG_BUGVERBOSE
 #define BUG()				\
+ do {					\
+ __asm__ __volatile__(	"int $129\n");	\
  __asm__ __volatile__(	"ud2\n"		\
 			"\t.word %c0\n"	\
 			"\t.long %c1\n"	\
-			 : : "i" (__LINE__), "i" (__FILE__))
+			 : : "i" (__LINE__), "i" (__FILE__)); \
+ } while (0)
 #else
 #define BUG() __asm__ __volatile__("ud2\n")
 #endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/bugs.h linux--vhype--2.6.11/include/asm-i386/bugs.h
--- linux--2.6.11/include/asm-i386/bugs.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/bugs.h	2005-03-01 21:13:36.000000000 +0000
@@ -26,6 +26,8 @@
 #include <asm/i387.h>
 #include <asm/msr.h>
 
+#ifndef CONFIG_X86_HYPERVISOR
+
 static int __init no_halt(char *s)
 {
 	boot_cpu_data.hlt_works_ok = 0;
@@ -211,3 +213,5 @@ static void __init check_bugs(void)
 	system_utsname.machine[1] = '0' + (boot_cpu_data.x86 > 6 ? 6 : boot_cpu_data.x86);
 	alternative_instructions(); 
 }
+
+#endif /* CONFIG_X86_HYPERVISOR */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/desc.h linux--vhype--2.6.11/include/asm-i386/desc.h
--- linux--2.6.11/include/asm-i386/desc.h	2005-03-01 16:22:25.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/desc.h	2005-03-01 21:17:52.000000000 +0000
@@ -11,6 +11,7 @@
 #include <linux/percpu.h>
 
 #include <asm/mmu.h>
+#include <asm/openhype.h>
 
 extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
 DECLARE_PER_CPU(struct desc_struct, cpu_gdt_table[GDT_ENTRIES]);
@@ -88,9 +89,26 @@ static inline void set_ldt_desc(unsigned
 
 static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
 {
+#ifndef CONFIG_X86_HYPERVISOR
 #define C(i) per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_TLS_MIN + i] = t->tls_array[i]
 	C(0); C(1); C(2);
 #undef C
+#else
+	int i;
+	for (i = 0; i < GDT_ENTRY_TLS_ENTRIES; i++) {
+		if (!desc_equal(&per_cpu(cpu_gdt_table,
+					 cpu)[GDT_ENTRY_TLS_MIN + i],
+				&t->tls_array[i])) {
+			per_cpu(cpu_gdt_table, cpu)[GDT_ENTRY_TLS_MIN + i] =
+				t->tls_array[i];
+			if (hcall_dt_entry(NULL, H_DT_GDT,
+					   GDT_ENTRY_TLS_MIN + i,
+					   t->tls_array[i].a,
+					   t->tls_array[i].b) != H_Success)
+				BUG();
+		}
+	}
+#endif /* CONFIG_X86_HYPERVISOR */
 }
 
 static inline void clear_LDT(void)
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/dma-mapping.h linux--vhype--2.6.11/include/asm-i386/dma-mapping.h
--- linux--2.6.11/include/asm-i386/dma-mapping.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/dma-mapping.h	2005-03-01 21:13:36.000000000 +0000
@@ -7,6 +7,27 @@
 #include <asm/io.h>
 #include <asm/scatterlist.h>
 
+#ifdef CONFIG_X86_HYPERVISOR
+/* 
+ * Due to circular dependencies I need to give some
+ * prototypes here and MUST NOT include vio.h here
+ * vio.h depends on some prototypes in this file
+ * as well.
+ */
+#define	DMA_ERROR_CODE		(~(dma_addr_t)0x0)
+#if NO_GCC_INLINE_BUG
+static inline struct vio_dev *to_vio_dev(struct device * dev);
+#else
+extern struct vio_dev *to_vio_dev(struct device * dev);
+#endif
+static inline int dma_mapping_error(dma_addr_t dma_addr);
+dma_addr_t vio_map_single(struct vio_dev *dev, void *vaddr,
+			  size_t size, enum dma_data_direction direction);
+void vio_unmap_single(struct vio_dev *dev, dma_addr_t dma_handle,
+		      size_t size, enum dma_data_direction direction);
+extern struct bus_type vio_bus_type;
+#endif
+
 #define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
 #define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
 
@@ -22,13 +43,40 @@ dma_map_single(struct device *dev, void 
 {
 	BUG_ON(direction == DMA_NONE);
 	flush_write_buffers();
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		return vio_map_single(to_vio_dev(dev),ptr,size,(int)direction);
+	}
+
+	{
+		u32 pte;
+		if (hcall_get_pte(&pte, H_GET_ENTRY_PTE|H_GET_ENTRY_PHYSICAL,
+								(u32) ptr) != H_Success)
+			BUG();
+		if ((pte & _PAGE_PSE) == 0) {
+			dma_addr_t ret;
+			ret = (pte & PAGE_MASK) + ((u32)ptr & ~PAGE_MASK);
+			return ret;
+		} else {
+			dma_addr_t ret;
+			ret = (pte & LARGE_PAGE_MASK) + ((u32)ptr & ~LARGE_PAGE_MASK);
+			return ret;
+		}
+	}
+#else
 	return virt_to_phys(ptr);
+#endif /* CONFIG_X86_HYPERVISOR */
 }
 
 static inline void
 dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,
 		 enum dma_data_direction direction)
 {
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		return vio_unmap_single(to_vio_dev(dev),dma_addr,size,(int)direction);
+	}
+#endif
 	BUG_ON(direction == DMA_NONE);
 }
 
@@ -42,8 +90,19 @@ dma_map_sg(struct device *dev, struct sc
 
 	for (i = 0; i < nents; i++ ) {
 		BUG_ON(!sg[i].page);
-
+#ifdef CONFIG_X86_HYPERVISOR
+	{
+		dma_addr_t addr =
+			dma_map_single(dev,
+			               phys_to_virt(page_to_phys(sg[i].page)),
+			               sg[i].length,
+			               direction);
+		addr += sg[i].offset;
+		sg[i].dma_address = addr;
+	}
+#else
 		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
+#endif /* CONFIG_X86_HYPERVISOR */
 	}
 
 	flush_write_buffers();
@@ -55,6 +114,11 @@ dma_map_page(struct device *dev, struct 
 	     size_t size, enum dma_data_direction direction)
 {
 	BUG_ON(direction == DMA_NONE);
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		panic("%s: On VIO bus! NOT IMPLEMENTED!\n",__FUNCTION__);
+	}
+#endif
 	return page_to_phys(page) + offset;
 }
 
@@ -63,6 +127,11 @@ dma_unmap_page(struct device *dev, dma_a
 	       enum dma_data_direction direction)
 {
 	BUG_ON(direction == DMA_NONE);
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		panic("%s: On VIO bus! NOT IMPLEMENTED!\n",__FUNCTION__);
+	}
+#endif
 }
 
 
@@ -71,6 +140,11 @@ dma_unmap_sg(struct device *dev, struct 
 	     enum dma_data_direction direction)
 {
 	BUG_ON(direction == DMA_NONE);
+#ifdef CONFIG_X86_HYPERVISOR
+	if (dev->bus == &vio_bus_type) {
+		printk("%s: On VIO bus! NOT IMPLEMENTED!\n",__FUNCTION__);
+	}
+#endif
 }
 
 static inline void
@@ -174,4 +248,9 @@ extern void *
 dma_mark_declared_memory_occupied(struct device *dev,
 				  dma_addr_t device_addr, size_t size);
 
+#ifdef CONFIG_X86_HYPERVISOR
+/* order of includes unfortunately matters a lot here */
+#include <asm/vio.h>
+#endif
+
 #endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/fixmap.h linux--vhype--2.6.11/include/asm-i386/fixmap.h
--- linux--2.6.11/include/asm-i386/fixmap.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/fixmap.h	2005-03-01 21:13:36.000000000 +0000
@@ -20,7 +20,11 @@
  * Leave one empty page between vmalloc'ed areas and
  * the start of the fixmap.
  */
+#ifdef CONFIG_X86_HYPERVISOR
+#define __FIXADDR_TOP	0xfbfff000
+#else
 #define __FIXADDR_TOP	0xfffff000
+#endif
 
 #ifndef __ASSEMBLY__
 #include <linux/kernel.h>
@@ -83,6 +87,11 @@ enum fixed_addresses {
 #ifdef CONFIG_PCI_MMCONFIG
 	FIX_PCIE_MCFG,
 #endif
+#ifdef CONFIG_X86_HYPERVISOR
+#define	NR_FIX_ISAMAP	96
+	FIX_ISAMAP_END,
+	FIX_ISAMAP_BEGIN = FIX_ISAMAP_END + NR_FIX_ISAMAP - 1,
+#endif
 	__end_of_permanent_fixed_addresses,
 	/* temporary boot-time mappings, used before ioremap() is functional */
 #define NR_FIX_BTMAPS	16
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/hvcall.h linux--vhype--2.6.11/include/asm-i386/hvcall.h
--- linux--2.6.11/include/asm-i386/hvcall.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/hvcall.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,427 @@
+/*
+ * asm-i386/hvcall.h
+ *
+ * Hypervisor interface definitions.
+ */
+#ifndef _ASM_X86_HVCALL_H
+#define _ASM_X86_HVCALL_H
+
+/*
+ * Hcall opcodes
+ */
+/*
+ * Hypervisor Call Function Name to Token (Table 170)
+ *
+ * Class is one fo the following:
+ *
+ *   Crit: Continuous forward progress must be made, encountering any
+ *   busy resource must cause the function to be backed out and return
+ *   with a "hardware busy" return code.
+ *
+ *   Norm: Similar to Crit, however, wait loops for slow hardware
+ *   access are allowed.
+ *
+ */
+/*	NAME			Token	  Class Mandatory 	Set	*/
+#define	H_UNUSED		0x0000	/* Crit Yes             pft     */
+#define	H_REMOVE		0x0004	/* Crit Yes             pft     */
+#define	H_ENTER			0x0008	/* Crit Yes             pft     */
+#define	H_READ			0x000c	/* Crit Yes             pft     */
+#define	H_CLEAR_MOD		0x0010	/* Crit Yes             pft     */
+#define	H_CLEAR_REF		0x0014	/* Crit Yes             pft     */
+#define	H_PROTECT		0x0018	/* Crit Yes             pft     */
+#define	H_GET_TCE		0x001c	/* Crit Yes             tce     */
+#define	H_PUT_TCE		0x0020	/* Crit Yes             tce     */
+#define	H_SET_SPRG0		0x0024	/* Crit Yes             sprg0   */
+#define	H_SET_DABR		0x0028	/* Crit Yes-dabr exists dabr    */
+#define	H_PAGE_INIT		0x002c	/* Crit Yes             copy    */
+#define	H_SET_ASR		0x0030	/* Crit Yes-on Istar    asr     */
+#define	H_ASR_ON		0x0034	/* Crit Yes-on Istar    asr     */
+#define	H_ASR_OFF		0x0038	/* Crit Yes-on Istar    asr     */
+#define	H_LOGICAL_CI_LOAD	0x003c	/* Norm Yes             debug   */
+#define	H_LOGICAL_CI_STORE	0x0040	/* Norm Yes             debug   */
+#define	H_LOGICAL_CACHE_LOAD	0x0044	/* Crit Yes             debug   */
+#define	H_LOGICAL_CACHE_STORE	0x0048	/* Crit Yes             debug   */
+#define	H_LOGICAL_ICBI		0x004c	/* Norm Yes             debug   */
+#define	H_LOGICAL_DCBF		0x0050	/* Norm Yes             debug   */
+#define	H_GET_TERM_CHAR		0x0054	/* Crit Yes             term    */
+#define	H_PUT_TERM_CHAR		0x0058	/* Crit Yes             term    */
+#define	H_REAL_TO_LOGICAL	0x005c	/* Norm Yes             perf    */
+#define	H_HYPERVISOR_DATA	0x0060	/* Norm See below       dump    */
+					/* is mandatory if enabled by HSC
+					 * and is disabled by default */
+#define	H_EOI			0x0064	/* Crit Yes             int     */
+#define	H_CPPR			0x0068	/* Crit Yes             int     */
+#define	H_IPI			0x006c	/* Crit Yes             int     */
+#define	H_IPOLL			0x0070	/* Crit Yes             int     */
+#define	H_XIRR			0x0074	/* Crit Yes             int     */
+#define	H_MIGRATE_PCI_TCE	0x0078	/* Norm Yes-if LRDR     migrate */
+#define H_CEDE         	        0x00e0	/* Crit Yes             splpar  */
+#define H_CONFER		0x00e4
+#define H_PROD			0x00e8
+#define H_GET_PPP		0x00ec
+#define H_SET_PPP		0x00f0
+#define H_PURR			0x00f4
+#define H_PIC			0x00f8
+#define H_REG_CRQ		0x00fc
+#define H_FREE_CRQ		0x0100
+#define H_VIO_SIGNAL		0x0104
+#define H_SEND_CRQ		0x0108
+#define H_PUTRTCE		0x010c
+#define H_COPY_RDMA		0x0110
+#define H_REGISTER_LOGICAL_LAN	0x0114
+#define H_FREE_LOGICAL_LAN	0x0118
+#define H_ADD_LOGICAL_LAN_BUFFER 0x011c
+#define H_SEND_LOGICAL_LAN	0x0120
+#define H_BULK_REMOVE		0x0124
+#define H_WRITE_RDMA		0x0128
+#define H_READ_RDMA		0x012c
+#define H_MULTICAST_CTRL	0x0130
+#define H_SET_XDABR		0x0134
+#define H_STUFF_TCE		0x0138
+#define H_PUT_TCE_INDIRECT	0x013c
+#define H_PUT_RTCE_INDERECT	0x0140
+#define H_MASS_MAP_TCE		0x0144
+#define H_ALRDMA		0x0148
+#define H_CHANGE_LOGICAL_LAN_MAC 0x014c
+#define H_VTERM_PARTNER_INFO	0x0150
+#define H_REGISTER_VTERM	0x0154
+#define H_FREE_VTERM		0x0158
+#define H_HCA_RESV_BEGIN	0x015c
+#define H_HCA_RESV_END		0x01c0
+#define H_GRANT_LOGICAL		0x01c4
+#define H_RESCIND_LOGICAL	0x01c8
+#define H_ACCEPT_LOGICAL	0x01cc
+#define H_RETURN_LOGICAL	0x01d0
+#define H_FREE_LOGICAL_LAN_BUFFER 0x01d4
+
+#define RPA_HCALL_END		0x01d4	/* set to last entry */
+
+#define H_IS_ILLEGAL(tok) (((tok) & 0x3) != 0)
+
+/*
+ * The 0x6xxx range is allotted * to embedded hypervisor.
+ */
+#define VHYPE_HCALL_BASE	0x6000
+#define H_EMBEDDED_BASE		0x6000
+#define H_LPAR_INFO		0x6004	/* Get partition info struct */
+#define H_MEM_DEFINE		0x6008
+#define	H_YIELD			0x600c	/* Needs to become H_CEDE. @@@ */
+#define	H_CREATE_PARTITION	0x6010
+#define	H_START			0x6014
+#define	H_VIO_CTL		0x6018
+#define H_DEBUG			0x601c
+#define	H_SET_EXCEPTION_INFO	0x6020
+#define	H_GET_LPID		0x6024
+#define	H_SET_SCHED_PARAMS	0x6028
+#define H_RESOURCE_TRANSFER     0x602C
+#define H_MULTI_PAGE		0x6030
+#define H_VM_MAP                0x6034
+#define H_DESTROY_PARTITION     0x6038
+#define H_CREATE_MSGQ		0x603c
+#define H_SEND_ASYNC		0x6040
+#define H_PCI_CONFIG		0x6044
+#define H_EIC_CONFIG		0x6048
+#define	H_REUSE_0x604c		0x604c
+
+/* bp.h */
+#define H_SPC_ACQUIRE		0x6050
+#define H_SPC_RELEASE		0x6054
+#define H_SPC_INTR_MASK		0x6058
+#define H_SPC_INTR_STAT		0x605c
+#define H_IIC_SPU		0x6060
+#define H_IIC_PU		0x6064
+#define H_REUSE_0x6068		0x6068
+#define H_MFC_MAP		0x606c
+#define H_MFC_MULTI_PAGE	0x6070
+
+/* x86 specific hcalls */
+#define H_DT_ENTRY		0x6074
+#define H_PAGE_DIR		0x6078
+#define H_FLUSH_TLB		0x607c
+#define H_SYS_STACK		0x6080
+#define H_GET_PFAULT_ADDR	0x6084
+
+/* experimental */
+#define H_RTAS			0x608c
+
+/* the IIC */
+#define H_IIC_EOI		0x6090
+#define H_IIC_CPPR		0x6094
+#define H_IIC_XIRR		0x60a0
+#define H_IIC_QIRR		0x60a4
+
+/* MFC TLB */
+#define H_MFC_TLBIA		0x60a8
+#define H_MFC_TLBIE		0x60ac
+
+/* RAG */
+#define H_RAG_CTL		0x60b0
+
+#define	H_SET_MBOX		0x60b4
+#define	H_GET_PTE		0x60b8
+#define H_DR			0x60bc	/* debug registers */
+
+/*
+ * Hidden
+ */
+#define H_PCI_CONFIG_READ	0x610c	/* PHYP # 0x500c */
+#define H_PCI_CONFIG_WRITE	0x6110	/* PHYP # 0x5010 */
+#define H_THREAD_CONTROL	0x6144	/* PHYP # 0x5044 H_CPU_CONTROL */
+#define H_GET_XIVE		0x614c	/* PHYP # 0x504c */
+#define H_SET_XIVE		0x6150	/* PHYP # 0x5050 */
+#define H_INTERRUPT		0x6154	/* PHYP # 0x5054 */
+
+#define VHYPE_HCALL_END		H_INTERRUPT	/* XXX */
+
+/* Yield flags */
+#define H_SELF_SYSID		-1
+
+/* x86 specific h_get_pte flags */
+#define	H_GET_ENTRY_ROOT	2
+#define	H_GET_ENTRY_PDE		4
+#define	H_GET_ENTRY_PTE		8
+#define	H_GET_ENTRY_PHYSICAL	1
+
+/* x86 specific h_page_dir flags */
+#define	H_PGD_FLUSH		0x01	/* flush page cache */
+#define	H_PGD_PREFETCH		0x02	/* prefetch shadow pages */
+#define	H_PGD_ACTIVATE		0x04	/* set mapping */
+
+#define H_FLUSH_TLB_ALL		0x01
+#define H_FLUSH_TLB_GLOBAL	0x02
+#define H_FLUSH_TLB_SINGLE	0x04
+#define H_FLUSH_TLB_PREFETCH	0x08
+
+/*
+ * Hypervisor Call Return Codes
+ */
+#define H_Success	0
+#define H_Busy		1	/* Hardware busy -- retry later */
+#define H_Constrained	4	/* Resource request constrained to max allowed */
+#define H_LongBusyStartRange   9900	/* Start of long busy range */
+#define H_LongBusyOrder1msec   9900	/* Long busy, hint that 1msec is a good time to retry */
+#define H_LongBusyOrder10msec  9901	/* Long busy, hint that 10msec is a good time to retry */
+#define H_LongBusyOrder100msec 9902	/* Long busy, hint that 100msec is a good time to retry */
+#define H_LongBusyOrder1sec    9903	/* Long busy, hint that 1sec is a good time to retry */
+#define H_LongBusyOrder10sec   9904	/* Long busy, hint that 10sec is a good time to retry */
+#define H_LongBusyOrder100sec  9905	/* Long busy, hint that 100sec is a good time to retry */
+#define H_LongBusyEndRange     9905	/* End of long busy range */
+#define H_Hardware	-1	/* Hardware error */
+#define H_Function	-2	/* Function not supported */
+#define H_Privilege	-3	/* Caller not privileged */
+#define H_Parameter	-4	/* Parameter invalid, out-of-range or conflicting */
+#define H_Bad_Mode	-5	/* Illegal msr value */
+#define H_PTEG_Full	-6	/* PTEG is full */
+#define H_Not_Found	-7	/* PTE was not found" */
+#define H_Reserved_DABR	-8	/* DABR address is reserved by the hypervisor on this processor" */
+#define H_NoMem                 -9
+#define H_Authority            -10
+#define H_Permission           -11
+#define H_Dropped              -12
+#define H_SourceParm           -13
+#define H_DestParm             -14
+#define H_RemoteParm           -15
+#define H_Resource             -16
+
+/*
+ * Long Busy is a condition that can be returned by the firmware
+ * when a call cannot be completed now, but the identical call
+ * should be retried later.  This prevents calls blocking in the
+ * firmware for long periods of time. Annoyingly the firmware can return
+ * a range of return codes, hinting at how long we should wait before
+ * retrying.  If you don't care for the hint, the macro below is a good
+ * way to check for the long_busy return codes
+ */
+#define H_isLongBusy(x)  ((x >= H_LongBusyStartRange) && (x <= H_LongBusyEndRange))
+
+/* h_dr selector flags */
+#define H_DR0 (1 << 0)
+#define H_DR1 (1 << 1)
+#define H_DR2 (1 << 2)
+#define H_DR3 (1 << 3)
+/* 4 and 5 are reserved */
+#define H_DR6 (1 << 6)
+#define H_DR7 (1 << 7)
+
+#ifndef __ASSEMBLY__
+
+/* Constants for the type field of the load desc table hcall */
+#define H_DT_GDT	0	/* Global descriptor table */
+#define H_DT_IDT	1	/* Interrupt descriptor table */
+
+#define	H_GET_PINFO	0x1000	/* Load pinfo to LA arg1 */
+#define	H_GET_MEM_INFO	0x2000
+
+/* Generic RPA interfaces */
+extern u32 hcall_yield(u32 * retvals, u32 condition);
+extern u32 hcall_get_term_char(u32 * retvals, u32 index, u32 count);
+extern u32 hcall_put_term_char(u32 * retvals, u32 index, u32 count,
+			       u32 word1, u32 word2, u32 word3, u32 word4);
+extern u32 hcall_xirr(u32 * retvals);
+extern u32 hcall_eoi(u32 * retvals, u32 xirr);
+extern u32 hcall_interrupt(u32 * retvals, u32 xirr, u32 state);
+extern u32 hcall_vio_signal(u32 * retvals, u32 uaddr, u32 mode);
+extern u32 hcall_get_tce(u32 * retvals, u32 liobn, u32 ioba);
+extern u32 hcall_put_tce(u32 * retvals, u32 liobn, u32 ioba, u64 tce_dword);
+
+/* CRQ support */
+extern u32 hcall_reg_crq(u32 * retvals, u32 u_addr, u32 queue, u32 len);
+extern u32 hcall_send_crq(u32 * retvals, u32 u_addr, u64 msg_hi, u64 msg_lo);
+extern u32 hcall_free_crq(u32 * retvals, u32 u_addr);
+
+extern u32 hcall_copy_rdma(u32 * retvals, u32 len, u32 sliobn, u32 sioba,
+			   u32 dliobn, u32 dioba);
+
+/* VETH support */
+extern u32 hcall_register_logical_lan(u32 * retvals, u32 uaddr,
+				      u32 bl, u64 rq, u32 fl, u64 mac);
+extern u32 hcall_free_logical_lan(u32 * retvals, u32 uaddr);
+extern u32 hcall_add_logical_lan_buffer(u32 * retvals, u32 uaddr, u64 bufd);
+extern u32 hcall_send_logical_lan(u32 * retvals, u32 uaddr,
+				  u64 bd1, u64 bd2, u64 bd3,
+				  u64 bd4, u64 bd5, u64 bd6, u64 token);
+extern u32 hcall_multicast_ctrl(u32 * retvals, u32 uaddr, u64 flags, u64 mmac);
+extern u32 hcall_change_logical_lan_mac(u32 * retvals, u32 uaddr, u64 mac);
+
+/* IA32 specific hcalls */
+extern u32 hcall_page_dir(u32 * retvals, u32 flags, u32 pgdir_laddr);
+extern u32 hcall_get_pte(u32 * retvals, u32 flags, u32 vaddr);
+extern u32 hcall_flush_tlb(u32 * retvals, u32 flags, u32 vaddr);
+extern u32 hcall_dt_entry(u32 * retvals, u32 type,
+			  u32 index, u32 word0, u32 word1);
+extern u32 hcall_sys_stack(u32 * retvals, u32 ss, u32 esp);
+extern u32 hcall_get_pfault_addr(u32 * retvals);
+extern u32 hcall_set_mbox(u32 * retvals, u32 mbox_laddr);
+extern u32 hcall_lpar_info(u32 * retvals, u32 cmd, u32, u32, u32, u32);
+extern u32 hcall_dr(u32 * retvals, u32 select,
+		    u32, u32, u32, u32, u32, u32, u32, u32);
+
+static inline u32
+hcall_get_drs(unsigned long *retvals)
+{
+	return hcall_dr((u32 *) retvals, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+}
+
+static inline u32
+hcall_get_dr(unsigned long regn, unsigned long *val)
+{
+	static unsigned long vals[8];
+	unsigned long rc;
+
+	rc = hcall_dr((u32 *) vals, 0, 0, 0, 0, 0, 0, 0, 0, 0);
+	*val = vals[regn];
+	return rc;
+}
+
+static inline u32
+hcall_set_drs(unsigned long *drs)
+{
+	static u32 null[8];
+
+	return hcall_dr(null, H_DR0 | H_DR1 | H_DR2 | H_DR3 | H_DR6 | H_DR7,
+			drs[0], drs[1], drs[2], drs[3], 0, 0, drs[6], drs[7]);
+}
+
+static inline u32
+hcall_set_dr(unsigned long regn, unsigned long val)
+{
+	static u32 null[8];
+
+	return hcall_dr(null, 1 << regn, val, val, val, val, 0, 0, val, val);
+}
+
+/* Other misc. interfaces */
+
+#define H_GET_PINFO	0x1000
+#define H_GET_MEM_INFO	0x2000
+extern u32 hcall_lpar_info(u32 * retvals, u32 cmd, u32 arg1,
+			   u32 arg2, u32 arg3, u32 arg4);
+
+/* plpar_hcall() -- Generic call interface
+ *
+ * plpar_hcall_norets is used like a vararg function. The first
+ * parameter gives the name of the hypervisor call. I am using
+ * that name to redefine this function call to call my own
+ * functions below. This allows us not to have to use vararg
+ * operations.
+ */
+#define plpar_hcall_norets(X, a...)	\
+		hvcall_##X##_x86( a );
+
+#define plpar_hcall_8arg_2ret(X, a...)	\
+		hvcall_##X##_x86( a );
+
+static inline u32
+hvcall_H_VIO_SIGNAL_x86(u32 ua, u32 mode)
+{
+	return hcall_vio_signal(NULL, ua, mode);
+}
+
+static inline u32
+hvcall_H_SEND_CRQ_x86(u32 ua, u64 msg_hi, u64 msg_lo)
+{
+	return hcall_send_crq(NULL, ua, msg_hi, msg_lo);
+}
+
+static inline u32
+hvcall_H_REG_CRQ_x86(u32 ua, u32 queue, u32 len)
+{
+	return hcall_reg_crq(NULL, ua, queue, len);
+}
+
+static inline u32
+hvcall_H_FREE_CRQ_x86(u32 ua)
+{
+	return hcall_free_crq(NULL, ua);
+}
+
+static inline u32
+hvcall_H_REGISTER_LOGICAL_LAN_x86(u32 ua, u32 buflst, u64 rxq, u32 fltlst,
+				  u64 mac)
+{
+	return hcall_register_logical_lan(NULL, ua, buflst, rxq, fltlst, mac);
+}
+
+static inline u32
+hvcall_H_FREE_LOGICAL_LAN_x86(u32 ua)
+{
+	return hcall_free_logical_lan(NULL, ua);
+}
+
+static inline u32
+hvcall_H_ADD_LOGICAL_LAN_BUFFER_x86(u32 ua, u64 buf)
+{
+	return hcall_add_logical_lan_buffer(NULL, ua, buf);
+}
+
+static inline u32
+hvcall_H_SEND_LOGICAL_LAN_x86(u32 ua, u64 buf1, u64 buf2, u64 buf3, u64 buf4,
+			      u64 buf5, u64 buf6, u64 correlator, u64 * rets)
+{
+	return hcall_send_logical_lan((u32 *) rets, ua, buf1, buf2, buf3, buf4,
+				      buf5, buf6, correlator);
+}
+
+static inline u32
+hvcall_H_MULTICAST_CTRL_x86(u32 ua, u64 cmd, u64 mac)
+{
+	return hcall_multicast_ctrl(NULL, ua, cmd, mac);
+}
+
+static inline u32
+hvcall_H_CHANGE_LOGICAL_LAN_MAC_x86(u32 ua, u64 mac)
+{
+	return hcall_change_logical_lan_mac(NULL, ua, mac);
+}
+
+static inline u32
+hvcall_H_COPY_RDMA_x86(u32 length, u32 sliobn, u32 slioba, u32 dliobn,
+		       u32 dlioba)
+{
+	return hcall_copy_rdma(NULL, length, sliobn, slioba, dliobn, dlioba);
+}
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _ASM_X86_HVCALL_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/hvconsole.h linux--vhype--2.6.11/include/asm-i386/hvconsole.h
--- linux--2.6.11/include/asm-i386/hvconsole.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/hvconsole.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+ * asm-i386/hvconsole.h
+ *
+ * Hypervisor interface definitions.
+ */
+#ifndef _ASM_X86_HVCONSOLE_H
+#define _ASM_X86_HVCONSOLE_H
+
+/*
+ * This is the max number of console adapters that can/will be found as
+ * console devices on first stage console init.  Any number beyond this range
+ * can't be used as a console device but is still a valid tty device.
+ */
+#define MAX_NR_HVC_CONSOLES     4
+
+extern int hvc_get_chars(uint32_t vtermno, char *buf, int count);
+extern int hvc_put_chars(uint32_t vtermno, const char *buf, int count);
+
+extern int hvc_find_vtys(void);
+
+/* Implemented by a console driver */
+extern int hvc_instantiate(uint32_t vtermno, int index);
+
+#endif /* _ASM_X86_HVCALL_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/i8259.h linux--vhype--2.6.11/include/asm-i386/i8259.h
--- linux--2.6.11/include/asm-i386/i8259.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/i8259.h	2005-03-01 21:13:36.000000000 +0000
@@ -14,4 +14,11 @@ extern void enable_8259A_irq(unsigned in
 extern void disable_8259A_irq(unsigned int irq);
 extern unsigned int startup_8259A_irq(unsigned int irq);
 
+#ifdef CONFIG_X86_HYPERVISOR
+extern void init_8259V(int auto_eoi);
+extern void enable_8259V_irq(unsigned int irq);
+extern void disable_8259V_irq(unsigned int irq);
+extern unsigned int startup_8259V_irq(unsigned int irq);
+#endif
+
 #endif	/* __ASM_I8259_H__ */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/io.h linux--vhype--2.6.11/include/asm-i386/io.h
--- linux--2.6.11/include/asm-i386/io.h	2005-03-01 16:17:52.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/io.h	2005-03-01 21:13:36.000000000 +0000
@@ -123,6 +123,9 @@ extern void bt_iounmap(void *addr, unsig
 /*
  * ISA I/O bus memory addresses are 1:1 with the physical address.
  */
+#ifdef CONFIG_X86_HYPERVISOR
+extern void setup_isamap(void);
+#endif
 #define isa_virt_to_bus virt_to_phys
 #define isa_page_to_bus page_to_phys
 #define isa_bus_to_virt phys_to_virt
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/iommu.h linux--vhype--2.6.11/include/asm-i386/iommu.h
--- linux--2.6.11/include/asm-i386/iommu.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/iommu.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,8 @@
+#ifndef IOMMU_X86_H
+#define IOMMU_X86_H
+
+#include <linux/config.h>
+
+#include <asm-ppc64/iommu.h>
+
+#endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/irq.h linux--vhype--2.6.11/include/asm-i386/irq.h
--- linux--2.6.11/include/asm-i386/irq.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/irq.h	2005-03-01 21:13:36.000000000 +0000
@@ -23,6 +23,9 @@ static __inline__ int irq_canonicalize(i
 
 extern void release_vm86_irqs(struct task_struct *);
 
+/* this number is used when no interrupt has been assigned */
+#define NO_IRQ                  (-1)
+
 #ifdef CONFIG_X86_LOCAL_APIC
 # define ARCH_HAS_NMI_WATCHDOG		/* See include/linux/nmi.h */
 #endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/mach-default/irq_vectors_limits.h linux--vhype--2.6.11/include/asm-i386/mach-default/irq_vectors_limits.h
--- linux--2.6.11/include/asm-i386/mach-default/irq_vectors_limits.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/mach-default/irq_vectors_limits.h	2005-03-01 21:13:36.000000000 +0000
@@ -13,9 +13,14 @@
 # define NR_IRQ_VECTORS (32 * NR_CPUS)
 # endif
 #else
+#ifdef CONFIG_X86_HYPERVISOR
+#define NR_IRQS 256
+#define NR_IRQ_VECTORS 32
+#else
 #define NR_IRQS 16
 #define NR_IRQ_VECTORS NR_IRQS
 #endif
 #endif
+#endif
 
 #endif /* _ASM_IRQ_VECTORS_LIMITS_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/mach-hypervisor/do_timer.h linux--vhype--2.6.11/include/asm-i386/mach-hypervisor/do_timer.h
--- linux--2.6.11/include/asm-i386/mach-hypervisor/do_timer.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/mach-hypervisor/do_timer.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,39 @@
+/* defines for inline arch setup functions */
+
+#include <asm/apic.h>
+
+/**
+ * do_timer_interrupt_hook - hook into timer tick
+ * @regs:	standard registers from interrupt
+ *
+ * Description:
+ *	This hook is called immediately after the timer interrupt is ack'd.
+ *	It's primary purpose is to allow architectures that don't possess
+ *	individual per CPU clocks (like the CPU APICs supply) to broadcast the
+ *	timer interrupt as a means of triggering reschedules etc.
+ **/
+
+static inline void do_timer_interrupt_hook(struct pt_regs *regs)
+{
+	u64 hv_ticks, lost_ticks;
+	hv_ticks = oh_mbox.ticks;  /* Not done atomically, doesn't matter */
+
+	/* This logic depends on the fact that do_timer processes atleast one tick. */
+	lost_ticks = hv_ticks - jiffies_64;
+
+	if (lost_ticks > 1)
+		jiffies_64 += lost_ticks - 1;
+	do_timer(regs);
+#ifndef CONFIG_SMP 
+	update_process_times(user_mode(regs)); 
+#endif 
+}
+
+/* This function is declared just to keep compiler happy. */
+static inline int do_timer_overflow(int count)
+{
+	/* This function does nothing since a guest running in HV doesn't need
+	 * this.
+	 */
+	return count;
+}
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/mach-hypervisor/setup_arch_post.h linux--vhype--2.6.11/include/asm-i386/mach-hypervisor/setup_arch_post.h
--- linux--2.6.11/include/asm-i386/mach-hypervisor/setup_arch_post.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/mach-hypervisor/setup_arch_post.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,26 @@
+/**
+ * machine_specific_memory_setup - Hook for machine specific memory setup.
+ *
+ * Description:
+ *	This is included late in kernel/setup.c so that it can make
+ *	use of all of the static functions.
+ */
+#include "linux/openhype.h"
+
+static char * __init
+machine_specific_memory_setup(void)
+{
+	u32 retvals[5];
+
+	/*
+	 * This is wrong. It assumes that all memory is available in
+	 * contiguous chunks. That's not necessarily the case.
+	 */
+	if (hcall_lpar_info(retvals, H_GET_MEM_INFO, 0 /* query addr 0 */,
+			0, 0, 0) != H_Success)
+		 BUG();
+
+	add_memory_region(retvals[0], retvals[1], E820_RAM);
+
+	return "hypervisor";
+}
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/machdep.h linux--vhype--2.6.11/include/asm-i386/machdep.h
--- linux--2.6.11/include/asm-i386/machdep.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/machdep.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,6 @@
+#ifndef MACHDEP_X86_H
+#define MACHDEP_X86_H
+ 
+#include <asm-ppc64/machdep.h>
+ 
+#endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/mmu.h linux--vhype--2.6.11/include/asm-i386/mmu.h
--- linux--2.6.11/include/asm-i386/mmu.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/mmu.h	2005-03-01 21:13:36.000000000 +0000
@@ -12,6 +12,9 @@ typedef struct { 
 	int size;
 	struct semaphore sem;
 	void *ldt;
+#ifdef CONFIG_X86_HYPERVISOR
+	int prefetch;
+#endif
 } mm_context_t;
 
 #endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/mmu_context.h linux--vhype--2.6.11/include/asm-i386/mmu_context.h
--- linux--2.6.11/include/asm-i386/mmu_context.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/mmu_context.h	2005-03-01 21:13:36.000000000 +0000
@@ -23,6 +23,16 @@ static inline void enter_lazy_tlb(struct
 #endif
 }
 
+#ifdef CONFIG_X86_HYPERVISOR
+static inline void load_page_dir(u32 flags, void *pgdir)
+{
+	u32 rc = hcall_page_dir(NULL, flags, __pa(pgdir));
+
+	if (rc != H_Success)
+		panic("load_page_dir: hcall_page_dir failed (rc %d)\n", rc);
+}
+#endif
+
 static inline void switch_mm(struct mm_struct *prev,
 			     struct mm_struct *next,
 			     struct task_struct *tsk)
@@ -39,7 +49,15 @@ static inline void switch_mm(struct mm_s
 		cpu_set(cpu, next->cpu_vm_mask);
 
 		/* Re-load page tables */
+#ifndef CONFIG_X86_HYPERVISOR
 		load_cr3(next->pgd);
+#else
+		if (unlikely(next->context.prefetch)) {
+			next->context.prefetch = 0;
+			load_page_dir(H_PGD_ACTIVATE|H_PGD_PREFETCH, next->pgd);
+		} else
+			load_page_dir(H_PGD_ACTIVATE, next->pgd);
+#endif
 
 		/*
 		 * load the LDT, if the LDT is different:
@@ -56,15 +74,27 @@ static inline void switch_mm(struct mm_s
 			/* We were in lazy tlb mode and leave_mm disabled 
 			 * tlb flush IPI delivery. We must reload %cr3.
 			 */
+#ifndef CONFIG_X86_HYPERVISOR
 			load_cr3(next->pgd);
+#else
+			load_page_dir(H_PGD_FLUSH|H_PGD_PREFETCH, next->pgd);
+#endif
 			load_LDT_nolock(&next->context, cpu);
 		}
 	}
 #endif
 }
 
+#ifdef CONFIG_X86_HYPERVISOR
+#define deactivate_mm(tsk, mm) do { \
+		if (mm && mm->pgd) \
+			load_page_dir(H_PGD_FLUSH, mm->pgd); \
+		asm("movl %0,%%fs ; movl %0,%%gs": :"r" (0)); \
+	} while (0)
+#else
 #define deactivate_mm(tsk, mm) \
 	asm("movl %0,%%fs ; movl %0,%%gs": :"r" (0))
+#endif
 
 #define activate_mm(prev, next) \
 	switch_mm((prev),(next),NULL)
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/openhype.h linux--vhype--2.6.11/include/asm-i386/openhype.h
--- linux--2.6.11/include/asm-i386/openhype.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/openhype.h	2005-03-01 21:13:36.000000000 +0000
@@ -0,0 +1,55 @@
+/* 
+ * Hypervisor structures
+ */
+#ifndef __I386_OPENHYPE_H_
+#define __I386_OPENHYPE_H_
+
+#include <asm/types.h>
+
+#define MAX_MEM_RANGES 5
+#define OPENHYPE_PARTITION_INFO_MAGIC_NUMBER 0xBADC0FFEE0DDF00D
+
+/* i386 register size type */
+typedef __u32 oh_reg_t;
+
+typedef struct {
+	u32	addr;
+	u32	size;
+} oh_mem_range_t;
+
+typedef struct {
+	u32 	IF;
+	u32 	irq_masked;
+	u32	irq_pending;
+	u64	ticks;
+} oh_mailbox_t;
+
+typedef struct {
+	void	*arch_pinfo;
+	u32	htab_size;
+	u32	chunk_size;
+	u32	large_page_size1;
+	u32	large_page_size2;
+	u32	mbox;
+	oh_mem_range_t mem[MAX_MEM_RANGES];
+	u32	lpid;
+	u32	sfw_tlb;
+} oh_partition_info_t;
+
+#ifndef X86_EFLAGS_IOPL
+#define	X86_EFLAGS_IOPL	0x00003000
+#endif
+
+static inline int
+oh_iopriv(void)
+{
+	unsigned long eflags;
+	__asm__ __volatile__("pushfl ; popl %0":"=g" (eflags): /* no input */);
+	return (eflags & X86_EFLAGS_IOPL) == 0 ? 0 : 1;
+}
+
+extern volatile oh_mailbox_t oh_mbox;
+
+extern oh_partition_info_t *oh_get_partition_info(void);
+
+#endif /* __I386_OPENHYPE_H_ */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/page.h linux--vhype--2.6.11/include/asm-i386/page.h
--- linux--2.6.11/include/asm-i386/page.h	2005-03-01 16:37:43.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/page.h	2005-03-01 21:24:18.000000000 +0000
@@ -5,6 +5,9 @@
 #define PAGE_SHIFT	12
 #define PAGE_SIZE	(1UL << PAGE_SHIFT)
 #define PAGE_MASK	(~(PAGE_SIZE-1))
+#ifdef CONFIG_X86_HYPERVISOR
+#define PAGE_OFFSET_MASK (PAGE_SIZE-1)
+#endif
 
 #define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
 #define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/param.h linux--vhype--2.6.11/include/asm-i386/param.h
--- linux--2.6.11/include/asm-i386/param.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/param.h	2005-03-01 21:13:36.000000000 +0000
@@ -1,8 +1,15 @@
 #ifndef _ASMi386_PARAM_H
 #define _ASMi386_PARAM_H
 
+#include <linux/config.h>
+
 #ifdef __KERNEL__
+#ifndef CONFIG_X86_HYPERVISOR
 # define HZ		1000		/* Internal kernel timer frequency */
+#else
+# define HZ		100		/* In case of vhype kernel's clock runs
+					   as fast as vhype's */
+#endif
 # define USER_HZ	100		/* .. some user interfaces are in "ticks" */
 # define CLOCKS_PER_SEC		(USER_HZ)	/* like times() */
 #endif
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/processor.h linux--vhype--2.6.11/include/asm-i386/processor.h
--- linux--2.6.11/include/asm-i386/processor.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/processor.h	2005-03-01 21:13:36.000000000 +0000
@@ -16,6 +16,7 @@
 #include <asm/cpufeature.h>
 #include <asm/msr.h>
 #include <asm/system.h>
+#include <asm/hvcall.h>
 #include <linux/cache.h>
 #include <linux/config.h>
 #include <linux/threads.h>
@@ -191,9 +192,10 @@ static inline unsigned int cpuid_edx(uns
 	return edx;
 }
 
+#ifndef CONFIG_X86_HYPERVISOR
 #define load_cr3(pgdir) \
 	asm volatile("movl %0,%%cr3": :"r" (__pa(pgdir)))
-
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  * Intel CPU features in CR4
@@ -218,6 +220,10 @@ static inline unsigned int cpuid_edx(uns
  */
 extern unsigned long mmu_cr4_features;
 
+#ifdef CONFIG_X86_HYPERVISOR
+static inline void set_in_cr4 (unsigned long mask) {}
+static inline void clear_in_cr4 (unsigned long mask) {}
+#else
 static inline void set_in_cr4 (unsigned long mask)
 {
 	mmu_cr4_features |= mask;
@@ -237,6 +243,7 @@ static inline void clear_in_cr4 (unsigne
 		: : "irg" (~mask)
 		:"ax");
 }
+#endif /* CONFIG_X86_HYPERVISOR */
 
 /*
  *      NSC/Cyrix CPU configuration register indexes
@@ -475,6 +482,10 @@ static inline void load_esp0(struct tss_
 		tss->ss1 = thread->sysenter_cs;
 		wrmsr(MSR_IA32_SYSENTER_CS, thread->sysenter_cs, 0);
 	}
+#ifdef CONFIG_X86_HYPERVISOR
+	if (hcall_sys_stack(NULL, tss->ss0, tss->esp0) != H_Success) 
+		BUG();
+#endif
 }
 
 #define start_thread(regs, new_eip, new_esp) do {		\
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/ptrace.h linux--vhype--2.6.11/include/asm-i386/ptrace.h
--- linux--2.6.11/include/asm-i386/ptrace.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/ptrace.h	2005-03-01 21:13:36.000000000 +0000
@@ -57,7 +57,7 @@ struct pt_regs {
 #ifdef __KERNEL__
 struct task_struct;
 extern void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs, int error_code);
-#define user_mode(regs) ((VM_MASK & (regs)->eflags) || (3 & (regs)->xcs))
+#define user_mode(regs) ((VM_MASK & (regs)->eflags) || ((3 & (regs)->xcs))==3)
 #define instruction_pointer(regs) ((regs)->eip)
 #if defined(CONFIG_SMP) && defined(CONFIG_FRAME_POINTER)
 extern unsigned long profile_pc(struct pt_regs *regs);
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/segment.h linux--vhype--2.6.11/include/asm-i386/segment.h
--- linux--2.6.11/include/asm-i386/segment.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/segment.h	2005-03-01 21:13:36.000000000 +0000
@@ -59,11 +59,17 @@
 
 #define GDT_ENTRY_KERNEL_BASE	12
 
+#ifdef CONFIG_X86_HYPERVISOR
+#define __KERNEL_RPL	2
+#else
+#define __KERNEL_RPL	0
+#endif
+
 #define GDT_ENTRY_KERNEL_CS		(GDT_ENTRY_KERNEL_BASE + 0)
-#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8)
+#define __KERNEL_CS (GDT_ENTRY_KERNEL_CS * 8 + __KERNEL_RPL)
 
 #define GDT_ENTRY_KERNEL_DS		(GDT_ENTRY_KERNEL_BASE + 1)
-#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8)
+#define __KERNEL_DS (GDT_ENTRY_KERNEL_DS * 8 + __KERNEL_RPL)
 
 #define GDT_ENTRY_TSS			(GDT_ENTRY_KERNEL_BASE + 4)
 #define GDT_ENTRY_LDT			(GDT_ENTRY_KERNEL_BASE + 5)
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/setup.h linux--vhype--2.6.11/include/asm-i386/setup.h
--- linux--2.6.11/include/asm-i386/setup.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/setup.h	2005-03-01 21:13:36.000000000 +0000
@@ -19,11 +19,15 @@
 #define PARAM_SIZE 2048
 #define COMMAND_LINE_SIZE 256
 
+/* for the virtual device data */
+#define VDEV_DESCRIPTION_SIZE  (2 * 1024)
+
 #define OLD_CL_MAGIC_ADDR	0x90020
 #define OLD_CL_MAGIC		0xA33F
 #define OLD_CL_BASE_ADDR	0x90000
 #define OLD_CL_OFFSET		0x90022
 #define NEW_CL_POINTER		0x228	/* Relative to real mode data */
+#define NEW_VD_POINTER  	0x22c   /* for virtual device data */
 
 #ifndef __ASSEMBLY__
 /*
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/suspend.h linux--vhype--2.6.11/include/asm-i386/suspend.h
--- linux--2.6.11/include/asm-i386/suspend.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/suspend.h	2005-03-01 21:13:36.000000000 +0000
@@ -34,10 +34,17 @@ struct saved_context {
 	unsigned long return_address;
 } __attribute__((packed));
 
+#ifdef CONFIG_X86_HYPERVISOR
+#define loaddebug(thread,register)					\
+	if (hcall_set_dr(register,					\
+			 (thread)->debugreg[register]) != H_Success)	\
+		BUG();
+#else
 #define loaddebug(thread,register) \
                __asm__("movl %0,%%db" #register  \
                        : /* no output */ \
                        :"r" ((thread)->debugreg[register]))
+#endif
 
 #ifdef CONFIG_ACPI_SLEEP
 extern unsigned long saved_eip;
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/system.h linux--vhype--2.6.11/include/asm-i386/system.h
--- linux--2.6.11/include/asm-i386/system.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/system.h	2005-03-01 21:13:37.000000000 +0000
@@ -6,6 +6,7 @@
 #include <asm/segment.h>
 #include <asm/cpufeature.h>
 #include <linux/bitops.h> /* for LOCK_PREFIX */
+#include <linux/openhype.h> /* for CONFIG_X86_HYPERVISOR */
 
 #ifdef __KERNEL__
 
@@ -441,6 +442,29 @@ struct alt_instr { 
 #define set_wmb(var, value) do { var = value; wmb(); } while (0)
 
 /* interrupt control.. */
+#ifdef CONFIG_X86_HYPERVISOR
+
+#define local_save_flags(x)	do { x = oh_mbox.IF; } while(0)
+#define local_irq_restore(x) \
+	do { \
+		if ((oh_mbox.IF = (x)) && \
+		    (oh_mbox.irq_pending & ~oh_mbox.irq_masked)) { \
+			hcall_yield(NULL, H_SELF_SYSID); \
+		} \
+	} while(0)
+#define local_irq_disable(x)	do { oh_mbox.IF = 0; } while(0)
+#define local_irq_enable(x)	local_irq_restore(1)
+
+/* used in the idle loop; sti takes one instruction cycle to complete */
+#define safe_halt()		do { oh_mbox.IF = 1; } while(0)
+
+#define irqs_disabled()		(oh_mbox.IF == 0)
+
+/* For spinlocks etc */
+#define local_irq_save(x)       do { x = oh_mbox.IF; oh_mbox.IF = 0;} while(0);
+
+#else /* !CONFIG_X86_HYPERVISOR */
+
 #define local_save_flags(x)	do { typecheck(unsigned long,x); __asm__ __volatile__("pushfl ; popl %0":"=g" (x): /* no input */); } while (0)
 #define local_irq_restore(x) 	do { typecheck(unsigned long,x); __asm__ __volatile__("pushl %0 ; popfl": /* no output */ :"g" (x):"memory", "cc"); } while (0)
 #define local_irq_disable() 	__asm__ __volatile__("cli": : :"memory")
@@ -458,6 +482,8 @@ struct alt_instr { 
 /* For spinlocks etc */
 #define local_irq_save(x)	__asm__ __volatile__("pushfl ; popl %0 ; cli":"=g" (x): /* no input */ :"memory")
 
+#endif /* CONFIG_X86_HYPERVISOR */
+
 /*
  * disable hlt during certain critical i/o operations
  */
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/tlbflush.h linux--vhype--2.6.11/include/asm-i386/tlbflush.h
--- linux--2.6.11/include/asm-i386/tlbflush.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/tlbflush.h	2005-03-01 21:13:37.000000000 +0000
@@ -4,6 +4,32 @@
 #include <linux/config.h>
 #include <linux/mm.h>
 #include <asm/processor.h>
+#include <asm/hvcall.h>
+
+#ifdef CONFIG_X86_HYPERVISOR
+
+static inline void __flush_tlb(void)
+{
+       if (hcall_flush_tlb(NULL, H_FLUSH_TLB_ALL|H_FLUSH_TLB_PREFETCH, 0)
+       								!= H_Success)
+               BUG();
+}
+
+static inline void __flush_tlb_global(void)
+{
+       if (hcall_flush_tlb(NULL, H_FLUSH_TLB_GLOBAL|H_FLUSH_TLB_PREFETCH, 0)
+       								!= H_Success)
+               BUG();
+}
+
+static inline void __flush_tlb_single(unsigned long addr)
+{
+       if (hcall_flush_tlb(NULL, H_FLUSH_TLB_SINGLE|H_FLUSH_TLB_PREFETCH,
+							(u32)addr) != H_Success)
+               BUG();
+}
+
+#else /* CONFIG_X86_HYPERVISOR */
 
 #define __flush_tlb()							\
 	do {								\
@@ -35,6 +61,11 @@
 			: "memory");					\
 	} while (0)
 
+#define __flush_tlb_single(addr) \
+	__asm__ __volatile__("invlpg %0": :"m" (*(char *) addr))
+
+#endif /* CONFIG_X86_HYPERVISOR */
+
 extern unsigned long pgkern_mask;
 
 # define __flush_tlb_all()						\
@@ -47,9 +78,6 @@ extern unsigned long pgkern_mask;
 
 #define cpu_has_invlpg	(boot_cpu_data.x86 > 3)
 
-#define __flush_tlb_single(addr) \
-	__asm__ __volatile__("invlpg %0": :"m" (*(char *) addr))
-
 #ifdef CONFIG_X86_INVLPG
 # define __flush_tlb_one(addr) __flush_tlb_single(addr)
 #else
@@ -87,6 +115,10 @@ static inline void flush_tlb_mm(struct m
 {
 	if (mm == current->active_mm)
 		__flush_tlb();
+#ifdef CONFIG_X86_HYPERVISOR
+	else
+		mm->context.prefetch = 1;
+#endif
 }
 
 static inline void flush_tlb_page(struct vm_area_struct *vma,
@@ -94,6 +126,10 @@ static inline void flush_tlb_page(struct
 {
 	if (vma->vm_mm == current->active_mm)
 		__flush_tlb_one(addr);
+#ifdef CONFIG_X86_HYPERVISOR
+	else
+		vma->vm_mm->context.prefetch = 1;
+#endif
 }
 
 static inline void flush_tlb_range(struct vm_area_struct *vma,
@@ -101,6 +137,10 @@ static inline void flush_tlb_range(struc
 {
 	if (vma->vm_mm == current->active_mm)
 		__flush_tlb();
+#ifdef CONFIG_X86_HYPERVISOR
+	else
+		vma->vm_mm->context.prefetch = 1;
+#endif
 }
 
 #else
@@ -133,7 +173,6 @@ struct tlb_state
 };
 DECLARE_PER_CPU(struct tlb_state, cpu_tlbstate);
 
-
 #endif
 
 #define flush_tlb_kernel_range(start, end) flush_tlb_all()
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/vga.h linux--vhype--2.6.11/include/asm-i386/vga.h
--- linux--2.6.11/include/asm-i386/vga.h	2005-03-01 16:17:53.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/vga.h	2005-03-01 21:13:37.000000000 +0000
@@ -11,8 +11,11 @@
  *	On the PC, we can just recalculate addresses and then
  *	access the videoram directly without any black magic.
  */
-
+#ifdef CONFIG_X86_HYPERVISOR
+#define VGA_MAP_MEM(x) (unsigned long)ioremap(x, 0x8000)
+#else
 #define VGA_MAP_MEM(x) (unsigned long)phys_to_virt(x)
+#endif
 
 #define vga_readb(x) (*(x))
 #define vga_writeb(x,y) (*(y) = (x))
diff -urNpX diff.exclude linux--2.6.11/include/asm-i386/vio.h linux--vhype--2.6.11/include/asm-i386/vio.h
--- linux--2.6.11/include/asm-i386/vio.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-i386/vio.h	2005-03-01 21:13:37.000000000 +0000
@@ -0,0 +1,119 @@
+/*
+ * Virtual I/O infrastructure support.
+ */
+
+#ifndef _ASM_VIO_H
+#define _ASM_VIO_H
+
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/device.h>
+#include <linux/pci.h>
+#include <linux/dma-mapping.h>
+#include <linux/openhype.h>
+#include <asm/hvcall.h>
+#include <asm/scatterlist.h>
+#include <asm/setup.h>
+#include <asm/iommu.h>
+
+/*
+ * The vio_dev structure is used to describe virtual I/O devices
+ */
+struct vio_dev {
+	uint32_t	unit_address;
+	unsigned long	liobn;			/* logical I/O bus number */
+	unsigned long	liobs;			/* logical I/O bus size */
+	unsigned int	xirr;			/* interrupt as per vhype */
+	unsigned int	irq;			/* interrupt shown to driver*/
+	struct iommu_table *iommu_table;	/* TCE allocator table */
+
+	int		devtype;		/* VIO device type */
+	int		probed;			/* device probed successfully */
+
+	/* device specific attributes */
+	u8		mac[8];			/* ethernet address */
+	unsigned int	filters;		/* filter size */
+
+	char * name;
+	char * type;
+
+	struct device	dev;
+	
+	unsigned long   dma_window[6];		/* must be either 4*6=24 bytes or
+						   4*10=40 bytes long */
+};
+#define VIO_DEV_ETH	1
+#define VIO_DEV_SCSI	2
+#define VIO_DEV_SCSIS	3
+#define VIO_DEV_TPM     4
+#define VIO_DEV_TPMS    5
+#define VIO_DEV_VTY     6
+
+extern struct bus_type vio_bus_type;
+
+/*
+ * Virtual device id
+ */
+struct vio_device_id {
+	char *type;
+	char *compat;
+};
+
+/*
+ * Virtual I/O device driver structure
+ */
+struct vio_driver {
+	struct list_head node;
+	char *name;
+	const struct vio_device_id *id_table;   /* NULL if wants all devices */
+	int (*probe)(struct vio_dev *dev, const struct vio_device_id *id);
+						/* New device inserted */
+	int (*remove)(struct vio_dev *dev);	/* Device removed (NULL if not
+						   a hot-plug capable driver) */
+	unsigned long driver_data;
+
+	struct device_driver driver;
+};
+
+#define VIO_IRQ_DISABLE         0UL
+#define VIO_IRQ_ENABLE          1UL
+
+#define h_vio_signal(ua, mode) \
+	hcall_vio_signal(NULL, ua, mode)
+
+extern const void * vio_get_attribute(struct vio_dev *vdev, void* which, int* length);
+
+extern int vio_register_driver(struct vio_driver *drv);
+extern void vio_unregister_driver(struct vio_driver *drv);
+
+int vio_enable_interrupts(struct vio_dev *dev);
+int vio_disable_interrupts(struct vio_dev *dev);
+dma_addr_t vio_map_single(struct vio_dev *dev, void *vaddr,
+			  size_t size, enum dma_data_direction direction);
+void vio_unmap_single(struct vio_dev *dev, dma_addr_t dma_handle,
+		      size_t size, enum dma_data_direction direction);
+
+static inline struct vio_driver *to_vio_driver(struct device_driver *drv)
+{
+	return container_of(drv, struct vio_driver, driver);
+}
+
+#if NO_GCC_INLINE_BUG
+/* cannot use the inline function due to a compiler bug */
+static inline struct vio_dev *to_vio_dev(struct device * dev)
+{
+	return container_of(dev, struct vio_dev, dev);
+}
+#else
+extern struct vio_dev *to_vio_dev(struct device * dev);
+#endif
+
+extern int dma_mapping_error(dma_addr_t);
+
+static inline int vio_dma_mapping_error(dma_addr_t dma_addr)
+{
+	return dma_mapping_error(dma_addr);
+}
+EXPORT_SYMBOL(vio_dma_mapping_error);
+
+#endif /* _ASM_VIO_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-ppc64/hvcall.h linux--vhype--2.6.11/include/asm-ppc64/hvcall.h
--- linux--2.6.11/include/asm-ppc64/hvcall.h	2005-03-01 16:18:09.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-ppc64/hvcall.h	2005-03-01 21:13:46.000000000 +0000
@@ -166,4 +166,14 @@ long plpar_hcall_4out(unsigned long opco
 		      unsigned long *out3,
 		      unsigned long *out4);
 
+/* plpar_hcall_generic()
+ * 
+ * generic hcall pass-thru mechanism
+ *
+ */
+long plpar_hcall_generic(unsigned long opcode, 
+			 unsigned long in_args[8],	
+			 unsigned long out_args[8]);
+
+
 #endif /* _PPC64_HVCALL_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-ppc64/iommu.h linux--vhype--2.6.11/include/asm-ppc64/iommu.h
--- linux--2.6.11/include/asm-ppc64/iommu.h	2005-03-01 16:18:10.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-ppc64/iommu.h	2005-03-01 21:13:46.000000000 +0000
@@ -45,6 +45,20 @@
  * Used by pSeries (SMP) and iSeries/pSeries LPAR, but there it's
  * abstracted so layout is irrelevant.
  */
+#ifdef CONFIG_X86_HYPERVISOR
+union tce_entry {
+	u64 te_word;
+	struct {
+		u64 tb_cachebits :6;  /* cache hash bits - not used */
+		u64 tb_rsvd      :6;
+		u64 tb_rpn       :40; /* real page number */
+		u64 tb_valid     :1;  /* tce is valid (vb only) */
+		u64 tb_allio     :1;  /* tce is valid for all lps (vb only) */
+		u64 tb_lpindex   :8;  /* lpindex for user of TCE (vb only) */
+		u64 tb_pciwr     :1;  /* write allowed (pci only) */
+		u64 tb_rdwr      :1;  /* read allowed (pci), Write allowed (vb) */
+	} te_bits;
+#else
 union tce_entry {
    	unsigned long te_word;
 	struct {
@@ -57,6 +71,7 @@ union tce_entry {
 		unsigned int  tb_pciwr     :1;	/* Write allowed (pci only) */
 		unsigned int  tb_rdwr      :1;	/* Read allowed  (pci), Write allowed (vb) */
 	} te_bits;
+#endif
 #define te_cacheBits te_bits.tb_cacheBits
 #define te_rpn       te_bits.tb_rpn
 #define te_valid     te_bits.tb_valid
diff -urNpX diff.exclude linux--2.6.11/include/asm-ppc64/openhype.h linux--vhype--2.6.11/include/asm-ppc64/openhype.h
--- linux--2.6.11/include/asm-ppc64/openhype.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-ppc64/openhype.h	2005-03-01 21:13:46.000000000 +0000
@@ -0,0 +1,57 @@
+/* 
+ * Hypervisor structures
+ */
+#ifndef __PPC64_OH_MAILBOX_H_
+#define __PPC64_OH_MAILBOX_H_
+
+#include <asm/types.h>
+
+#define MAX_MEM_RANGES 5
+#define OPENHYPE_PARTITION_INFO_MAGIC_NUMBER 0xBADC0FFEE0DDF00D
+
+#ifndef __ASSEMBLY__
+
+/* ppc64 register size type */
+typedef __u64 oh_reg_t;
+
+typedef struct {
+	u64	addr;
+	u64	size;
+} oh_mem_range_t;
+
+typedef struct {
+	u8 	IF;
+	u16 	irq_mask;
+	u64   ticks;
+} oh_mailbox_t;
+
+typedef struct {
+	void	*arch_pinfo;
+	u64	htab_size;
+	u64	chunk_size;
+	u64	large_page_size1;
+	u64	large_page_size2;
+	u64	mbox;
+	oh_mem_range_t mem[MAX_MEM_RANGES];
+	u32	lpid;
+	u32	sfw_tlb;
+} oh_partition_info_t;
+
+extern volatile oh_mailbox_t oh_mbox;
+
+extern oh_partition_info_t oh_partition_info[2];
+
+static inline oh_partition_info_t*
+oh_get_partition_info(void) {
+	return &oh_partition_info[1];
+}
+
+extern void oh_use_virq(unsigned long virq);
+
+struct pt_regs;
+extern int ohic_get_irq(struct pt_regs *regs);
+
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __PPC64_OH_MAILBOX_H_ */
diff -urNpX diff.exclude linux--2.6.11/include/asm-ppc64/plpar_wrappers.h linux--vhype--2.6.11/include/asm-ppc64/plpar_wrappers.h
--- linux--2.6.11/include/asm-ppc64/plpar_wrappers.h	2005-03-01 16:18:10.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-ppc64/plpar_wrappers.h	2005-03-01 21:13:46.000000000 +0000
@@ -107,5 +107,25 @@ static inline long plpar_put_term_char(u
 				  lbuf[1]);
 }
 
+static inline long plpar_eoi(unsigned long xirr)
+{
+	return plpar_hcall_norets(H_EOI, xirr);
+}
+
+static inline long plpar_cppr(unsigned long cppr)
+{
+	return plpar_hcall_norets(H_CPPR, cppr);
+}
+
+static inline long plpar_ipi(unsigned long servernum, unsigned long mfrr)
+{
+	return plpar_hcall_norets(H_IPI, servernum, mfrr);
+}
+
+static inline long plpar_xirr(unsigned long *xirr_ret)
+{
+	unsigned long dummy;
+	return plpar_hcall(H_XIRR, 0, 0, 0, 0, xirr_ret, &dummy, &dummy);
+}
 
 #endif /* _PPC64_PLPAR_WRAPPERS_H */
diff -urNpX diff.exclude linux--2.6.11/include/asm-ppc64/processor.h linux--vhype--2.6.11/include/asm-ppc64/processor.h
--- linux--2.6.11/include/asm-ppc64/processor.h	2005-03-01 16:22:26.000000000 +0000
+++ linux--vhype--2.6.11/include/asm-ppc64/processor.h	2005-03-01 21:17:53.000000000 +0000
@@ -416,6 +416,7 @@
 #define PLATFORM_LPAR         0x0001
 #define PLATFORM_POWERMAC     0x0400
 #define PLATFORM_MAPLE        0x0500
+#define PLATFORM_MAPLE_LPAR   0x0501
 
 /* Compatibility with drivers coming from PPC32 world */
 #define _machine	(systemcfg->platform)
diff -urNpX diff.exclude linux--2.6.11/include/linux/openhype.h linux--vhype--2.6.11/include/linux/openhype.h
--- linux--2.6.11/include/linux/openhype.h	1970-01-01 00:00:00.000000000 +0000
+++ linux--vhype--2.6.11/include/linux/openhype.h	2005-03-01 21:14:02.000000000 +0000
@@ -0,0 +1,47 @@
+/* 
+ * Hypervisor structures
+ */
+#ifndef __LINUX_OPENHYPE_H_
+#define __LINUX_OPENHYPE_H_
+
+#include <asm/types.h>
+#include <linux/ioctl.h>
+#include <asm/openhype.h>
+
+
+#ifndef __ASSEMBLY__
+
+#define INVALID_MEM_RANGE (~((unsigned long)0))
+
+#define OH_HCALL_NUM_ARGS	8
+typedef struct {
+	oh_reg_t retval;
+	oh_reg_t opcode;
+	oh_reg_t args[OH_HCALL_NUM_ARGS];
+} oh_hcall_args;
+
+typedef struct
+{
+	int	oh_interrupt;
+	int	oh_signal;
+} oh_reflect_args;
+
+typedef struct 
+{
+	oh_reg_t laddr; /* output, logical address given */
+	oh_reg_t size;  /* input/output, size of region */
+} oh_mem_hold_args;
+
+extern int oh_generic_hcall(oh_hcall_args *args);
+
+#define OH_GENHCALL	_IOWR('h', 0, oh_hcall_args)
+#define OH_IRQ_REFLECT	_IOWR('h', 1, oh_reflect_args)
+#define OH_MEM_HOLD	_IOWR('h', 2, oh_mem_hold_args)
+
+
+extern int unmap_openhype_xirr(unsigned int xirr);
+extern int map_openhype_xirr(unsigned int xirr);
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __LINUX_OPENHYPE_H_ */
diff -urNpX diff.exclude linux--2.6.11/init/main.c linux--vhype--2.6.11/init/main.c
--- linux--2.6.11/init/main.c	2005-03-01 16:37:44.000000000 +0000
+++ linux--vhype--2.6.11/init/main.c	2005-03-01 21:24:23.000000000 +0000
@@ -506,7 +506,9 @@ asmlinkage void __init start_kernel(void
 #ifdef CONFIG_PROC_FS
 	proc_root_init();
 #endif
+#ifndef CONFIG_X86_HYPERVISOR
 	check_bugs();
+#endif
 
 	acpi_early_init(); /* before LAPIC and SMP init */
 
diff -urNpX diff.exclude linux--2.6.11/kernel/workqueue.c linux--vhype--2.6.11/kernel/workqueue.c
--- linux--2.6.11/kernel/workqueue.c	2005-03-01 17:45:22.000000000 +0000
+++ linux--vhype--2.6.11/kernel/workqueue.c	2005-03-02 15:53:16.000000000 +0000
@@ -390,6 +390,17 @@ static struct workqueue_struct *keventd_
 
 int fastcall schedule_work(struct work_struct *work)
 {
+#ifdef CONFIG_X86_HYPERVISOR
+	/*
+	 * There is a race condition whereby schedule_work() is called
+	 * before init_workqueues() (for example, console (vt.c) screen
+	 * blanking). This causes a null pointer derefence and crashes
+	 * the kernel. This race only occurs under vhype/bochs where
+	 * the real-time between con_init() and init_workqueues() can
+	 * be larger than the screen blank timeout.
+	 */
+	if (!keventd_wq) return 0;
+#endif
 	return queue_work(keventd_wq, work);
 }
 
